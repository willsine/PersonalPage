<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta http-equiv="content-type" content="text/html" charset="UTF-8">
    <style>


        html, body {
            font-family: "Corbel",'Hiragino Sans GB','Microsoft Yahei','微软雅黑',sans-serif;
            font-size: 18px;
            height: 100%;
            width: 100%;
            background-color: #C4C4C4;
        }
        .slide {
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2) inset;
            height: 100%;
            position: relative;
            width: 100%;
        }
        * {
            border: 0 none;
            font-size: 100%;
            margin: 0;
            outline: medium none;
            padding: 0;
            vertical-align: baseline;
        }


        #slider1 {
            position: relative;
            background: url("img/10.jpg") repeat scroll 0 0 / cover rgba(0, 0, 0, 0);
            height: 100%;
            width: 100%;
            overflow: hidden;


        }

        .button {
            background: url("img/arrow.png") repeat scroll 0 0 rgba(0, 0, 0, 0);
            bottom: 20px;
            display: block;
            height: 60px;
            left: 50%;
            margin-left: -30px;
            opacity: 0.75;
            position: absolute;
            width: 60px;
            z-index: 9999;

            /*animation: 2.7s ease-in-out 0s normal none infinite first-down-btn;*/
            transition:all 0.1s ease-in;
        }
        a.totop{
            background-position: -60px 0;
            /*top: 30px;*/
            width: 80px;
            height: 80px;
            bottom: 10px;
            margin-left: -40px;

        }
        img.center{
            margin: auto;
            position: absolute;
            display: block;
            top: 0;left: 0;right: 0; bottom: 0;

            /*-webkit-box-shadow:2px 2px 3px rgba(135, 139, 144, 0.4); -moz-box-shadow:2px 2px 3px rgba(135, 139, 144, 0.4); box-shadow:2px 2px 3px rgba(135, 139, 144, 0.4);*/
            -webkit-transition:all 0.5s ease-in;    /*表示所有属性都执行过度效果，执行时间为0.5秒，过渡动画类型为先慢后快 */
            -moz-transition:all 0.5s ease-in;
            transition:all 0.5s ease-in;


        }
        .center:hover,.center:focus,.center:active{

            /*-webkit-box-shadow:15px 15px 20px rgba(50, 50, 50, 0.4); -moz-box-shadow:15px 15px 20px rgba(50, 50, 50, 0.4); box-shadow:15px 15px 20px rgba(50, 50, 50, 0.4);*/
            -webkit-transform: scale(1.05); -moz-transform:scale(1.05); transform: scale(1.05);  /*图片为原来的1.05倍产生拉近的效果*/
        }

        .button:hover,.button:focus,.button:active{
            background-position: 0 -60px;
            -webkit-transform: scale(1.05); -moz-transform:scale(1.05); transform: scale(1.05);
            cursor: pointer;

        }
        .first:hover,.first:focus,.first:active{
            background: url("img/arrow.png") repeat scroll 0 0 rgba(0, 0, 0, 0);
            -webkit-transform: scale(1.05); -moz-transform:scale(1.05); transform: scale(1.05);
            cursor: pointer;
        }
        .totop:hover,.totop:focus,.totop:active{
            background-position: -60px 0;

        }
        #slider2{
            position: relative;
            height: 100%;
            width: 100%;
        }
        div.common{
            position: absolute;  /*会触发BFC 可以包含浮动*/
            margin: auto;
            top:0;right: 0;bottom: 0; left: 0;
            zoo :1;
            padding: 20px;
            width: 1200px;
            height: 400px;
            background-color: #F6F6F6;
            border-radius: 6px;
            box-shadow: 3px 5px 2px rgba(135, 139, 144, 1);
        }

        div#introduction{
            height: 400px;
        }


        div#left{
            float: left;
            height: 100%;
            width: 58.3%;
            box-shadow: 0 2px 2px rgba(135, 139, 144, 0.4);
        }

        ul ,li{
            list-style-type: none;
            height: 100%;
            padding: 0;
            margin: 0;
        }
        li.intro{
            float: left;
            position: relative;
            top:50%;
            height: 260px;

            width: 173px;
            margin-top: -130px;
            /*border: 1px solid lightblue;*/

        }
        img.intro{
            -webkit-filter: blur(1px);
            -moz-filter: blur(1px);
            filter:blur(1px);
            transition:all 0.5s ease-in;
        }

        img.intro:hover,img.intro:focus,img.intro:active{
            -webkit-box-shadow:15px 15px 20px rgba(50, 50, 50, 0.4);
            -moz-box-shadow:15px 15px 20px rgba(50, 50, 50, 0.4);
            box-shadow:15px 15px 20px rgba(50, 50, 50, 0.4);
            -webkit-transform: scale(1.05);
            -moz-transform: scale(1.05);

            transform:  scale(1.08);  /*图片为原来的1.05倍产生拉近的效果*/
            z-index: 1;

            -webkit-filter: blur(0px);
            -moz-filter: blur(0px);
            filter:blur(0px);

        }
        li.intro:hover{
            cursor: pointer;
        }
        div#right{
            float: right;
            display: table;
            width: 460px;
            height: 400px;
            /*line-height: 360px;*/
            padding: 20px;
            text-indent: 8px;
        }
        div.head{
            height: 120px;
            position: relative;
        }

        img.profile {
            box-shadow: 0 0 2px 3px rgba(255, 255, 255, 0.7), 0 0 8px 8px rgba(0, 0, 0, 0.25);
            position: absolute;
            margin:auto ;
            left: 0;right: 0; top: 0; bottom: 0;
            max-width: 100px;
            transition: all 500ms ease 0s;
            border-radius: 120px;
            border: 0 none;
            height: auto;
            vertical-align: middle;
        }
        div.article{
            height: 240px;
            display: none;
            /*vertical-align: middle;*/
            line-height: 40px;
            text-indent: 20px;
        }
        div[class$=two]{

        }
        span{
            display: table-cell;
            vertical-align:middle;
        }

        a.link{
           background: url(img/externalLink.gif) right top no-repeat;
            padding-right: 10px;
            text-decoration: none;

        }
        div#special{
            padding: 0;
            height: 450px;
        }

        div#activity{
            /*float: left;*/
            position: relative;
            /*margin: auto;*/
            height: 100%;
            width: 600px;
            overflow: hidden;
            box-shadow: 2px 2px 2px rgba(135, 139, 144, 0.4);
        }
        img.ac-content{
            /*position: absolute;*/
            /*left: 0; top: 0; right: 0;bottom: 0;*/
            /*margin-left:40px ;*/
            /*margin-top: 25px;*/
        }

        a.cursor{
            border-radius: 23px;
            font-size: 60px;
            font-weight: 100;
            height: 40px;
            line-height: 30px;
            margin-top: -20px;
            opacity: 0.5;
            position: absolute;
            text-align: center;
            top: 50%;
            width: 40px;
            cursor: pointer;
            transition:all 0.1s ease-in;
        }
        a.pre{
            background: url("img/pre-arrow-glow.png") no-repeat scroll 0 0 #222222;
            left: 20px;
        }

        a.next{
            background: url("img/next-arrow-glow.png") no-repeat scroll 0 0 #222222;
            left: 530px;
        }


        .cursor:hover,.cursor:focus,.cursor:active{
            -webkit-transform: scale(1.05); -moz-transform:scale(1.05);
            transform: scale(1.05);  /*图片为原来的1.05倍产生拉近的效果*/
        }
        div#ac-wrapper{
            position: absolute;
            width: 3600px;
            height: 100%;
            top: 0;
            left: 0;
        }

         li.ac-content{
            float: left;
            list-style:none;
            margin:0;
            padding:0;
            /*margin-left: 520px;*/
        }


        div#ac-discription{
            position: absolute;
            top: 0;
            right: 0;
            /*float: right;*/
            width: 560px;
            height: 100%;
            padding: 20px;
            display: table;
            line-height: 40px;
        }
        p.discription{
            display: table-cell;
            vertical-align: middle;
            text-indent: 30px;
        }
        .carousel-indicators {
            position: absolute;
            bottom: 20px;
            right: 15px;
            top: auto;
        }
        .carousel-indicators li {
            display: block;
            float: left;
            width: 10px;
            height: 10px;
            margin-left: 5px;
            text-indent: -999px;
            background-color: #ccc;
            background-color: rgba(255,255,255,0.25);
            border-radius: 5px;
        }
    li.current{
        background-color: #ffffff;
    }

    #slider4{
        /*background:url(img/title.jpg) no-repeat right top;*/
    }
    canvas#circle{
        position: relative;
        top: 50%;
        margin-top: -150px;
        /*margin-left: 100px;*/
    }
    img.titles{
        position: absolute;
        top: -6px;
        right: -8px;
        max-width: 150px;

    }

    div#professional{
       /*position: relative;*/
    }
    div.pie{
        left: 420px;
        margin-top: -150px;
        position: absolute;
        top: 50%;
        width: 250px;
    }

    div.scroll-item {
        float: left;
        height: 50px;
        margin-top: 10px;
        width: 250px;
    }

    div.scroll-item div.rect{
        float: left;
        height: 50px;
        width: 31px;
    }

    div.scroll-item div.item-text{
        float: right;
        height: 50px;
        line-height: 50px;
        width: 200px;
        font-size: 1.1em;
    }

    div.item-even{
        background-color: #E7E8EC;
    }
    div.item-odd{
        background-color: #E0ECF6;
    }

    canvas#cvs{
        height: 80%;
        position: absolute;
        right: 155px;
        top: 10%;
        width: 360px;

    }

    div#contact-me{
        position: relative;
        height: 100px;
        top: 40px;

    }

    div#contact-me img{
        position: relative;
        left: 50%;
        margin-left:-251px;
        /*top: 40px;*/

    }
    div#icon-show{
        overflow: hidden;
        position: relative;
        width: 60%;
        height: 150px;
        left: 25%;
        top: 10%;
    }

    li.icon{
        float: left;
        margin-left:40px;
        position: relative;
    }
    a:hover{
        cursor: pointer;

    }
    img.icon-img{
        position: relative;
        top: 13px;
        height: 74px;
        width: 74px;
        border-radius: 38px;
        -webkit-transition:all 0.5s ease-in;
        -moz-transition:all 0.5s ease-in;
        transition:all 0.5s ease-in;
    }

    img.icon-img:hover,img.icon-img:focus,img.icon-img:active{
        -webkit-box-shadow:15px 15px 20px rgba(50, 50, 50, 0.4);
        -moz-box-shadow:15px 15px 20px rgba(50, 50, 50, 0.4);
        box-shadow:15px 15px 20px rgba(50, 50, 50, 0.4);
        -webkit-transform: scale(1.05);
        -moz-transform: scale(1.05);
        transform: scale(1.05);
    }

    span.icon-text{
        position: relative;
        height: 63px;
        width: 74px;
        line-height: 63px;
        text-align: center;
        color: #FBD244;
    }

    img.show-tel{
        position: relative;
        left: 50%;
        margin-left: -150px;
        height: 50px;
        top: 55px;
        display: none;
    }

    img.wei{
        height: 105px;
        position: relative;
        left: 50%;
        margin-left: -200px;
        top:40px;
        display: none;
    }



    </style>
</head>
<body>
   <div id="slider1" class="slide" data-slide="1">
       <img class="center title" alt="Harrsion Wu" data-stellar-ratio="1" src="img/name3.gif">
       <a class="first button " title="" data-slide="2"></a>
   </div>
   <div id="slider2" class="slide" data-slide="2">
       <div id="introduction" class="common">
           <img src="img/grow.gif" class="pro titles">
           <div id="left">
               <ul>
                   <!--<li class="intro"><img src="img/baby.jpg"></li>-->
                   <li class="intro one"><img class="intro photo" src="img/child.jpg" title=""></li>
                   <li class="intro two"><img class="intro photo" src="img/school.jpg"></li>
                   <li class="intro three"><img class="intro photo" src="img/company.jpg"></li>
                   <li class="intro four"><img class="intro photo" src="img/future.jpg"></li>

               </ul>
           </div>
           <div id="right">
               <div class="head">
                   <img class="profile" src="img/head1.jpg">
               </div>
               <div class="article one">
                   <span>我是吴浩，1992年的夏天我出生于有着中国第一将军县的
                   <a class="link" href="http://zh.wikipedia.org/zh-cn/%E7%BA%A2%E5%AE%89%E5%8E%BF" target="_blank">红安县</a>， 这片红色的土地深深的感染着我.
                   </span>
               </div>
               <div class="article two">
                   <span>2010年进入<a class="link" href="http://www.hbtcm.edu.cn/" target="_blank">湖北中医药大学</a>信息工程学院学习医学信息工程，主修编程基础(delphi、java)，数据库原理、医院信息系统等课程。
                   大概是大三的下学期开始接触到了前端，立刻让我产生了浓厚的兴趣，于是自学了javacript、css等课程，决心加入这个让人激动的行业。
                   </span>
               </div>
               <div class="article three">
                   <span>2013年10月在<a class="link" href="http://www.founderinternational.com/" target="_blank">方正国际软件(北京)有限公司</a> 医疗卫生事业部
                       研发实习，在这里真正感受都工作的氛围以及团队合作、沟通的重要，获益良多</span>
               </div>
               <div class="article four">
                   <span>关于未来...web这个令人兴奋的行业会不会有我的一席之地？<br>路漫漫其修远兮，吾将上下而求索</span>
               </div>

           </div>
       </div>
       <a class="button" title="" data-slide="3"></a>
   </div>
   <div id="slider3" class="slide" data-slide="3">

       <div class="common" id="professional">
           <img src="img/top.gif" class="pro titles">
           <canvas id="circle" width="400" height="300">您的浏览器暂不支持Canvas</canvas>
           <div class="pie discription">
               <div class="scroll-item item-even">
                   <div class="rect" style="background-color: rgb(119, 209, 246); "></div>
                   <div class="item-text">20% &nbsp; Java</div>
               </div>
               <div class="scroll-item item-odd">
                   <div class="rect" style="background-color: rgb(44, 168, 224); "></div>
                   <div class="item-text">15% &nbsp; HTML(HTML5)</div>
               </div>
               <div class="scroll-item item-even">
                   <div class="rect" style="background-color: rgb(54, 102, 176); "></div>
                   <div class="item-text">25% &nbsp; JavaScript</div>
               </div>
               <div class="scroll-item item-odd">
                   <div class="rect" style="background-color: rgb(47, 54, 143); "></div>
                   <div class="item-text">25% &nbsp; CSS(CSS3)</div>
               </div>
               <div class="scroll-item item-even">
                   <div class="rect" style="background-color: rgb(39, 37, 95); "></div>
                   <div class="item-text">15% &nbsp; JQuery</div>
               </div>
           </div>


           <canvas id="cvs" width="360" height="320">您的浏览器暂不支持Canvas</canvas>

       </div>

       <a class="button" title="" data-slide="4"></a>

   </div>
   <div id="slider4" class="slide" data-slide="4">
       <div class="common" id="special">
           <img src="img/school.gif" class="pro titles">
          <div id="activity" title="test">

              <div id="ac-wrapper">
                  <ul>
                      <li class="ac-content"><img class="ac-content" src="img/game1.jpg"></li>
                      <li class="ac-content"><img class="ac-content" src="img/game2.jpg"></li>
                      <li class="ac-content"><img class="ac-content" src="img/game3.jpg"></li>
                      <li class="ac-content"><img class="ac-content" src="img/game4.jpg"></li>
                      <li class="ac-content"><img class="ac-content" src="img/game5.jpg"></li>
                      <li class="ac-content"><img class="ac-content" src="img/game6.jpg"></li>
                  </ul>
              </div>
              <a class="cursor control pre"></a>
              <a class="cursor control next"></a>
              <ol class="carousel-indicators">
                  <li class="current"></li>
                  <li></li>
                  <li></li>
                  <li></li>
                  <li></li>
                  <li></li>
              </ol>
          </div>
          <div id="ac-discription">
               <p class="discription">大学生活可谓丰富多彩，精彩纷呈的球赛、欢乐无限的班级活动，让人留恋不已。在大学期间我担任系志愿者协会副部长，
                   组织参加了各种志愿者活动，乐在其中。在学习之余也曾外出兼职做过商场促销员、酒店服务员等，充实自己的大学生活，更是一种锻炼。</p>
          </div>
       </div>
       <a class="button" title="" data-slide="6"></a>
   </div>



   <!--<div id="slider5" class="slide" data-slide="5">-->
       <!--<div class="common" id="hobby">-->
           <!--<img src="img/hobby.gif" class="hobby titles">-->


       <!--</div>-->
       <!--<a class="button" title="" data-slide="6"></a>-->
   <!--</div>-->

   <div id="slider6" class="slide" data-slide="6">
       <div class="common" id="contact">
           <img src="img/contact.gif" class="contact titles">
           <div id="contact-me">
               <img src="img/contactme.png">
           </div>
           <div id="icon-show">
               <ul>
                   <li class="icon">
                       <a>
                           <img src="img/phone1.png" class="icon-img tel">
                       </a>
                       <span class="icon-text">电话</span>
                   </li>
                   <li class="icon">
                       <a>
                           <img src="img/wechat.png" class="icon-img wechat">
                       </a>
                       <span class="icon-text">微信</span>
                   </li>
                   <li class="icon">
                       <a href="mailto:willsine.caffery@gmail.com">
                           <img src="img/contacts-email.png" class="icon-img">
                       </a>
                       <span class="icon-text">邮件</span>
                   </li>
                   <li class="icon">
                       <a target="_blank" href="http://weibo.com/signup/signup.php?inviteCode=2648239850">
                           <img src="img/contacts-weibo.png" class="icon-img">
                       </a>
                       <span class="icon-text">新浪微博</span>
                   </li>
                   <li class="icon">
                       <a target="_blank" href="http://www.zhihu.com/people/caffery-willsine">
                           <img src="img/contacts-zhihu.png" class="icon-img">
                       </a>
                       <span class="icon-text">知乎</span>
                   </li>

               </ul>
           </div>

           <img src="img/tel.png" class="show-tel">
           <img src="img/code.png" class="wei code">

       </div>
       <a class="button totop" title="" data-slide="7"></a>

   </div>

   <script type="text/javascript">
   /*!
    * jQuery JavaScript Library v1.6.1
    * http://jquery.com/
    *
    * Copyright 2011, John Resig
    * Dual licensed under the MIT or GPL Version 2 licenses.
    * http://jquery.org/license
    *
    * Includes Sizzle.js
    * http://sizzlejs.com/
    * Copyright 2011, The Dojo Foundation
    * Released under the MIT, BSD, and GPL Licenses.
    *
    * Date: Thu May 12 15:04:36 2011 -0400
    */
   (function( window, undefined ) {


// Use the correct document accordingly with window argument (sandbox)
       var document = window.document,
               navigator = window.navigator,
               location = window.location;
       var jQuery = (function() {

// Define a local copy of jQuery
           var jQuery = function( selector, context ) {
                       // The jQuery object is actually just the init constructor 'enhanced'
                       return new jQuery.fn.init( selector, context, rootjQuery );
                   },

           // Map over jQuery in case of overwrite
                   _jQuery = window.jQuery,

           // Map over the $ in case of overwrite
                   _$ = window.$,

           // A central reference to the root jQuery(document)
                   rootjQuery,

           // A simple way to check for HTML strings or ID strings
           // (both of which we optimize for)
                   quickExpr = /^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

           // Check if a string has a non-whitespace character in it
                   rnotwhite = /\S/,

           // Used for trimming whitespace
                   trimLeft = /^\s+/,
                   trimRight = /\s+$/,

           // Check for digits
                   rdigit = /\d/,

           // Match a standalone tag
                   rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

           // JSON RegExp
                   rvalidchars = /^[\],:{}\s]*$/,
                   rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
                   rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
                   rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

           // Useragent RegExp
                   rwebkit = /(webkit)[ \/]([\w.]+)/,
                   ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
                   rmsie = /(msie) ([\w.]+)/,
                   rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

           // Keep a UserAgent string for use with jQuery.browser
                   userAgent = navigator.userAgent,

           // For matching the engine and version of the browser
                   browserMatch,

           // The deferred used on DOM ready
                   readyList,

           // The ready event handler
                   DOMContentLoaded,

           // Save a reference to some core methods
                   toString = Object.prototype.toString,
                   hasOwn = Object.prototype.hasOwnProperty,
                   push = Array.prototype.push,
                   slice = Array.prototype.slice,
                   trim = String.prototype.trim,
                   indexOf = Array.prototype.indexOf,

           // [[Class]] -> type pairs
                   class2type = {};

           jQuery.fn = jQuery.prototype = {
               constructor: jQuery,
               init: function( selector, context, rootjQuery ) {
                   var match, elem, ret, doc;

                   // Handle $(""), $(null), or $(undefined)
                   if ( !selector ) {
                       return this;
                   }

                   // Handle $(DOMElement)
                   if ( selector.nodeType ) {
                       this.context = this[0] = selector;
                       this.length = 1;
                       return this;
                   }

                   // The body element only exists once, optimize finding it
                   if ( selector === "body" && !context && document.body ) {
                       this.context = document;
                       this[0] = document.body;
                       this.selector = selector;
                       this.length = 1;
                       return this;
                   }

                   // Handle HTML strings
                   if ( typeof selector === "string" ) {
                       // Are we dealing with HTML string or an ID?
                       if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
                           // Assume that strings that start and end with <> are HTML and skip the regex check
                           match = [ null, selector, null ];

                       } else {
                           match = quickExpr.exec( selector );
                       }

                       // Verify a match, and that no context was specified for #id
                       if ( match && (match[1] || !context) ) {

                           // HANDLE: $(html) -> $(array)
                           if ( match[1] ) {
                               context = context instanceof jQuery ? context[0] : context;
                               doc = (context ? context.ownerDocument || context : document);

                               // If a single string is passed in and it's a single tag
                               // just do a createElement and skip the rest
                               ret = rsingleTag.exec( selector );

                               if ( ret ) {
                                   if ( jQuery.isPlainObject( context ) ) {
                                       selector = [ document.createElement( ret[1] ) ];
                                       jQuery.fn.attr.call( selector, context, true );

                                   } else {
                                       selector = [ doc.createElement( ret[1] ) ];
                                   }

                               } else {
                                   ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
                                   selector = (ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment).childNodes;
                               }

                               return jQuery.merge( this, selector );

                               // HANDLE: $("#id")
                           } else {
                               elem = document.getElementById( match[2] );

                               // Check parentNode to catch when Blackberry 4.6 returns
                               // nodes that are no longer in the document #6963
                               if ( elem && elem.parentNode ) {
                                   // Handle the case where IE and Opera return items
                                   // by name instead of ID
                                   if ( elem.id !== match[2] ) {
                                       return rootjQuery.find( selector );
                                   }

                                   // Otherwise, we inject the element directly into the jQuery object
                                   this.length = 1;
                                   this[0] = elem;
                               }

                               this.context = document;
                               this.selector = selector;
                               return this;
                           }

                           // HANDLE: $(expr, $(...))
                       } else if ( !context || context.jquery ) {
                           return (context || rootjQuery).find( selector );

                           // HANDLE: $(expr, context)
                           // (which is just equivalent to: $(context).find(expr)
                       } else {
                           return this.constructor( context ).find( selector );
                       }

                       // HANDLE: $(function)
                       // Shortcut for document ready
                   } else if ( jQuery.isFunction( selector ) ) {
                       return rootjQuery.ready( selector );
                   }

                   if (selector.selector !== undefined) {
                       this.selector = selector.selector;
                       this.context = selector.context;
                   }

                   return jQuery.makeArray( selector, this );
               },

               // Start with an empty selector
               selector: "",

               // The current version of jQuery being used
               jquery: "1.6.1",

               // The default length of a jQuery object is 0
               length: 0,

               // The number of elements contained in the matched element set
               size: function() {
                   return this.length;
               },

               toArray: function() {
                   return slice.call( this, 0 );
               },

               // Get the Nth element in the matched element set OR
               // Get the whole matched element set as a clean array
               get: function( num ) {
                   return num == null ?

                       // Return a 'clean' array
                           this.toArray() :

                       // Return just the object
                           ( num < 0 ? this[ this.length + num ] : this[ num ] );
               },

               // Take an array of elements and push it onto the stack
               // (returning the new matched element set)
               pushStack: function( elems, name, selector ) {
                   // Build a new jQuery matched element set
                   var ret = this.constructor();

                   if ( jQuery.isArray( elems ) ) {
                       push.apply( ret, elems );

                   } else {
                       jQuery.merge( ret, elems );
                   }

                   // Add the old object onto the stack (as a reference)
                   ret.prevObject = this;

                   ret.context = this.context;

                   if ( name === "find" ) {
                       ret.selector = this.selector + (this.selector ? " " : "") + selector;
                   } else if ( name ) {
                       ret.selector = this.selector + "." + name + "(" + selector + ")";
                   }

                   // Return the newly-formed element set
                   return ret;
               },

               // Execute a callback for every element in the matched set.
               // (You can seed the arguments with an array of args, but this is
               // only used internally.)
               each: function( callback, args ) {
                   return jQuery.each( this, callback, args );
               },

               ready: function( fn ) {
                   // Attach the listeners
                   jQuery.bindReady();

                   // Add the callback
                   readyList.done( fn );

                   return this;
               },

               eq: function( i ) {
                   return i === -1 ?
                           this.slice( i ) :
                           this.slice( i, +i + 1 );
               },

               first: function() {
                   return this.eq( 0 );
               },

               last: function() {
                   return this.eq( -1 );
               },

               slice: function() {
                   return this.pushStack( slice.apply( this, arguments ),
                           "slice", slice.call(arguments).join(",") );
               },

               map: function( callback ) {
                   return this.pushStack( jQuery.map(this, function( elem, i ) {
                       return callback.call( elem, i, elem );
                   }));
               },

               end: function() {
                   return this.prevObject || this.constructor(null);
               },

               // For internal use only.
               // Behaves like an Array's method, not like a jQuery method.
               push: push,
               sort: [].sort,
               splice: [].splice
           };

// Give the init function the jQuery prototype for later instantiation
           jQuery.fn.init.prototype = jQuery.fn;

           jQuery.extend = jQuery.fn.extend = function() {
               var options, name, src, copy, copyIsArray, clone,
                       target = arguments[0] || {},
                       i = 1,
                       length = arguments.length,
                       deep = false;

               // Handle a deep copy situation
               if ( typeof target === "boolean" ) {
                   deep = target;
                   target = arguments[1] || {};
                   // skip the boolean and the target
                   i = 2;
               }

               // Handle case when target is a string or something (possible in deep copy)
               if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
                   target = {};
               }

               // extend jQuery itself if only one argument is passed
               if ( length === i ) {
                   target = this;
                   --i;
               }

               for ( ; i < length; i++ ) {
                   // Only deal with non-null/undefined values
                   if ( (options = arguments[ i ]) != null ) {
                       // Extend the base object
                       for ( name in options ) {
                           src = target[ name ];
                           copy = options[ name ];

                           // Prevent never-ending loop
                           if ( target === copy ) {
                               continue;
                           }

                           // Recurse if we're merging plain objects or arrays
                           if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                               if ( copyIsArray ) {
                                   copyIsArray = false;
                                   clone = src && jQuery.isArray(src) ? src : [];

                               } else {
                                   clone = src && jQuery.isPlainObject(src) ? src : {};
                               }

                               // Never move original objects, clone them
                               target[ name ] = jQuery.extend( deep, clone, copy );

                               // Don't bring in undefined values
                           } else if ( copy !== undefined ) {
                               target[ name ] = copy;
                           }
                       }
                   }
               }

               // Return the modified object
               return target;
           };

           jQuery.extend({
               noConflict: function( deep ) {
                   if ( window.$ === jQuery ) {
                       window.$ = _$;
                   }

                   if ( deep && window.jQuery === jQuery ) {
                       window.jQuery = _jQuery;
                   }

                   return jQuery;
               },

               // Is the DOM ready to be used? Set to true once it occurs.
               isReady: false,

               // A counter to track how many items to wait for before
               // the ready event fires. See #6781
               readyWait: 1,

               // Hold (or release) the ready event
               holdReady: function( hold ) {
                   if ( hold ) {
                       jQuery.readyWait++;
                   } else {
                       jQuery.ready( true );
                   }
               },

               // Handle when the DOM is ready
               ready: function( wait ) {
                   // Either a released hold or an DOMready/load event and not yet ready
                   if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
                       // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                       if ( !document.body ) {
                           return setTimeout( jQuery.ready, 1 );
                       }

                       // Remember that the DOM is ready
                       jQuery.isReady = true;

                       // If a normal DOM Ready event fired, decrement, and wait if need be
                       if ( wait !== true && --jQuery.readyWait > 0 ) {
                           return;
                       }

                       // If there are functions bound, to execute
                       readyList.resolveWith( document, [ jQuery ] );

                       // Trigger any bound ready events
                       if ( jQuery.fn.trigger ) {
                           jQuery( document ).trigger( "ready" ).unbind( "ready" );
                       }
                   }
               },

               bindReady: function() {
                   if ( readyList ) {
                       return;
                   }

                   readyList = jQuery._Deferred();

                   // Catch cases where $(document).ready() is called after the
                   // browser event has already occurred.
                   if ( document.readyState === "complete" ) {
                       // Handle it asynchronously to allow scripts the opportunity to delay ready
                       return setTimeout( jQuery.ready, 1 );
                   }

                   // Mozilla, Opera and webkit nightlies currently support this event
                   if ( document.addEventListener ) {
                       // Use the handy event callback
                       document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

                       // A fallback to window.onload, that will always work
                       window.addEventListener( "load", jQuery.ready, false );

                       // If IE event model is used
                   } else if ( document.attachEvent ) {
                       // ensure firing before onload,
                       // maybe late but safe also for iframes
                       document.attachEvent( "onreadystatechange", DOMContentLoaded );

                       // A fallback to window.onload, that will always work
                       window.attachEvent( "onload", jQuery.ready );

                       // If IE and not a frame
                       // continually check to see if the document is ready
                       var toplevel = false;

                       try {
                           toplevel = window.frameElement == null;
                       } catch(e) {}

                       if ( document.documentElement.doScroll && toplevel ) {
                           doScrollCheck();
                       }
                   }
               },

               // See test/unit/core.js for details concerning isFunction.
               // Since version 1.3, DOM methods and functions like alert
               // aren't supported. They return false on IE (#2968).
               isFunction: function( obj ) {
                   return jQuery.type(obj) === "function";
               },

               isArray: Array.isArray || function( obj ) {
                   return jQuery.type(obj) === "array";
               },

               // A crude way of determining if an object is a window
               isWindow: function( obj ) {
                   return obj && typeof obj === "object" && "setInterval" in obj;
               },

               isNaN: function( obj ) {
                   return obj == null || !rdigit.test( obj ) || isNaN( obj );
               },

               type: function( obj ) {
                   return obj == null ?
                           String( obj ) :
                           class2type[ toString.call(obj) ] || "object";
               },

               isPlainObject: function( obj ) {
                   // Must be an Object.
                   // Because of IE, we also have to check the presence of the constructor property.
                   // Make sure that DOM nodes and window objects don't pass through, as well
                   if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
                       return false;
                   }

                   // Not own constructor property must be Object
                   if ( obj.constructor &&
                           !hasOwn.call(obj, "constructor") &&
                           !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
                       return false;
                   }

                   // Own properties are enumerated firstly, so to speed up,
                   // if last one is own, then all properties are own.

                   var key;
                   for ( key in obj ) {}

                   return key === undefined || hasOwn.call( obj, key );
               },

               isEmptyObject: function( obj ) {
                   for ( var name in obj ) {
                       return false;
                   }
                   return true;
               },

               error: function( msg ) {
                   throw msg;
               },

               parseJSON: function( data ) {
                   if ( typeof data !== "string" || !data ) {
                       return null;
                   }

                   // Make sure leading/trailing whitespace is removed (IE can't handle it)
                   data = jQuery.trim( data );

                   // Attempt to parse using the native JSON parser first
                   if ( window.JSON && window.JSON.parse ) {
                       return window.JSON.parse( data );
                   }

                   // Make sure the incoming data is actual JSON
                   // Logic borrowed from http://json.org/json2.js
                   if ( rvalidchars.test( data.replace( rvalidescape, "@" )
                           .replace( rvalidtokens, "]" )
                           .replace( rvalidbraces, "")) ) {

                       return (new Function( "return " + data ))();

                   }
                   jQuery.error( "Invalid JSON: " + data );
               },

               // Cross-browser xml parsing
               // (xml & tmp used internally)
               parseXML: function( data , xml , tmp ) {

                   if ( window.DOMParser ) { // Standard
                       tmp = new DOMParser();
                       xml = tmp.parseFromString( data , "text/xml" );
                   } else { // IE
                       xml = new ActiveXObject( "Microsoft.XMLDOM" );
                       xml.async = "false";
                       xml.loadXML( data );
                   }

                   tmp = xml.documentElement;

                   if ( ! tmp || ! tmp.nodeName || tmp.nodeName === "parsererror" ) {
                       jQuery.error( "Invalid XML: " + data );
                   }

                   return xml;
               },

               noop: function() {},

               // Evaluates a script in a global context
               // Workarounds based on findings by Jim Driscoll
               // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
               globalEval: function( data ) {
                   if ( data && rnotwhite.test( data ) ) {
                       // We use execScript on Internet Explorer
                       // We use an anonymous function so that context is window
                       // rather than jQuery in Firefox
                       ( window.execScript || function( data ) {
                           window[ "eval" ].call( window, data );
                       } )( data );
                   }
               },

               nodeName: function( elem, name ) {
                   return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
               },

               // args is for internal usage only
               each: function( object, callback, args ) {
                   var name, i = 0,
                           length = object.length,
                           isObj = length === undefined || jQuery.isFunction( object );

                   if ( args ) {
                       if ( isObj ) {
                           for ( name in object ) {
                               if ( callback.apply( object[ name ], args ) === false ) {
                                   break;
                               }
                           }
                       } else {
                           for ( ; i < length; ) {
                               if ( callback.apply( object[ i++ ], args ) === false ) {
                                   break;
                               }
                           }
                       }

                       // A special, fast, case for the most common use of each
                   } else {
                       if ( isObj ) {
                           for ( name in object ) {
                               if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
                                   break;
                               }
                           }
                       } else {
                           for ( ; i < length; ) {
                               if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
                                   break;
                               }
                           }
                       }
                   }

                   return object;
               },

               // Use native String.trim function wherever possible
               trim: trim ?
                       function( text ) {
                           return text == null ?
                                   "" :
                                   trim.call( text );
                       } :

                   // Otherwise use our own trimming functionality
                       function( text ) {
                           return text == null ?
                                   "" :
                                   text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
                       },

               // results is for internal usage only
               makeArray: function( array, results ) {
                   var ret = results || [];

                   if ( array != null ) {
                       // The window, strings (and functions) also have 'length'
                       // The extra typeof function check is to prevent crashes
                       // in Safari 2 (See: #3039)
                       // Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
                       var type = jQuery.type( array );

                       if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
                           push.call( ret, array );
                       } else {
                           jQuery.merge( ret, array );
                       }
                   }

                   return ret;
               },

               inArray: function( elem, array ) {

                   if ( indexOf ) {
                       return indexOf.call( array, elem );
                   }

                   for ( var i = 0, length = array.length; i < length; i++ ) {
                       if ( array[ i ] === elem ) {
                           return i;
                       }
                   }

                   return -1;
               },

               merge: function( first, second ) {
                   var i = first.length,
                           j = 0;

                   if ( typeof second.length === "number" ) {
                       for ( var l = second.length; j < l; j++ ) {
                           first[ i++ ] = second[ j ];
                       }

                   } else {
                       while ( second[j] !== undefined ) {
                           first[ i++ ] = second[ j++ ];
                       }
                   }

                   first.length = i;

                   return first;
               },

               grep: function( elems, callback, inv ) {
                   var ret = [], retVal;
                   inv = !!inv;

                   // Go through the array, only saving the items
                   // that pass the validator function
                   for ( var i = 0, length = elems.length; i < length; i++ ) {
                       retVal = !!callback( elems[ i ], i );
                       if ( inv !== retVal ) {
                           ret.push( elems[ i ] );
                       }
                   }

                   return ret;
               },

               // arg is for internal usage only
               map: function( elems, callback, arg ) {
                   var value, key, ret = [],
                           i = 0,
                           length = elems.length,
                   // jquery objects are treated as arrays
                           isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

                   // Go through the array, translating each of the items to their
                   if ( isArray ) {
                       for ( ; i < length; i++ ) {
                           value = callback( elems[ i ], i, arg );

                           if ( value != null ) {
                               ret[ ret.length ] = value;
                           }
                       }

                       // Go through every key on the object,
                   } else {
                       for ( key in elems ) {
                           value = callback( elems[ key ], key, arg );

                           if ( value != null ) {
                               ret[ ret.length ] = value;
                           }
                       }
                   }

                   // Flatten any nested arrays
                   return ret.concat.apply( [], ret );
               },

               // A global GUID counter for objects
               guid: 1,

               // Bind a function to a context, optionally partially applying any
               // arguments.
               proxy: function( fn, context ) {
                   if ( typeof context === "string" ) {
                       var tmp = fn[ context ];
                       context = fn;
                       fn = tmp;
                   }

                   // Quick check to determine if target is callable, in the spec
                   // this throws a TypeError, but we will just return undefined.
                   if ( !jQuery.isFunction( fn ) ) {
                       return undefined;
                   }

                   // Simulated bind
                   var args = slice.call( arguments, 2 ),
                           proxy = function() {
                               return fn.apply( context, args.concat( slice.call( arguments ) ) );
                           };

                   // Set the guid of unique handler to the same of original handler, so it can be removed
                   proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

                   return proxy;
               },

               // Mutifunctional method to get and set values to a collection
               // The value/s can be optionally by executed if its a function
               access: function( elems, key, value, exec, fn, pass ) {
                   var length = elems.length;

                   // Setting many attributes
                   if ( typeof key === "object" ) {
                       for ( var k in key ) {
                           jQuery.access( elems, k, key[k], exec, fn, value );
                       }
                       return elems;
                   }

                   // Setting one attribute
                   if ( value !== undefined ) {
                       // Optionally, function values get executed if exec is true
                       exec = !pass && exec && jQuery.isFunction(value);

                       for ( var i = 0; i < length; i++ ) {
                           fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
                       }

                       return elems;
                   }

                   // Getting an attribute
                   return length ? fn( elems[0], key ) : undefined;
               },

               now: function() {
                   return (new Date()).getTime();
               },

               // Use of jQuery.browser is frowned upon.
               // More details: http://docs.jquery.com/Utilities/jQuery.browser
               uaMatch: function( ua ) {
                   ua = ua.toLowerCase();

                   var match = rwebkit.exec( ua ) ||
                           ropera.exec( ua ) ||
                           rmsie.exec( ua ) ||
                           ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
                           [];

                   return { browser: match[1] || "", version: match[2] || "0" };
               },

               sub: function() {
                   function jQuerySub( selector, context ) {
                       return new jQuerySub.fn.init( selector, context );
                   }
                   jQuery.extend( true, jQuerySub, this );
                   jQuerySub.superclass = this;
                   jQuerySub.fn = jQuerySub.prototype = this();
                   jQuerySub.fn.constructor = jQuerySub;
                   jQuerySub.sub = this.sub;
                   jQuerySub.fn.init = function init( selector, context ) {
                       if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
                           context = jQuerySub( context );
                       }

                       return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
                   };
                   jQuerySub.fn.init.prototype = jQuerySub.fn;
                   var rootjQuerySub = jQuerySub(document);
                   return jQuerySub;
               },

               browser: {}
           });

// Populate the class2type map
           jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
               class2type[ "[object " + name + "]" ] = name.toLowerCase();
           });

           browserMatch = jQuery.uaMatch( userAgent );
           if ( browserMatch.browser ) {
               jQuery.browser[ browserMatch.browser ] = true;
               jQuery.browser.version = browserMatch.version;
           }

// Deprecated, use jQuery.browser.webkit instead
           if ( jQuery.browser.webkit ) {
               jQuery.browser.safari = true;
           }

// IE doesn't match non-breaking spaces with \s
           if ( rnotwhite.test( "\xA0" ) ) {
               trimLeft = /^[\s\xA0]+/;
               trimRight = /[\s\xA0]+$/;
           }

// All jQuery objects should point back to these
           rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
           if ( document.addEventListener ) {
               DOMContentLoaded = function() {
                   document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
                   jQuery.ready();
               };

           } else if ( document.attachEvent ) {
               DOMContentLoaded = function() {
                   // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
                   if ( document.readyState === "complete" ) {
                       document.detachEvent( "onreadystatechange", DOMContentLoaded );
                       jQuery.ready();
                   }
               };
           }

// The DOM ready check for Internet Explorer
           function doScrollCheck() {
               if ( jQuery.isReady ) {
                   return;
               }

               try {
                   // If IE is used, use the trick by Diego Perini
                   // http://javascript.nwbox.com/IEContentLoaded/
                   document.documentElement.doScroll("left");
               } catch(e) {
                   setTimeout( doScrollCheck, 1 );
                   return;
               }

               // and execute any waiting functions
               jQuery.ready();
           }

// Expose jQuery to the global object
           return jQuery;

       })();


       var // Promise methods
               promiseMethods = "done fail isResolved isRejected promise then always pipe".split( " " ),
       // Static reference to slice
               sliceDeferred = [].slice;

       jQuery.extend({
           // Create a simple deferred (one callbacks list)
           _Deferred: function() {
               var // callbacks list
                       callbacks = [],
               // stored [ context , args ]
                       fired,
               // to avoid firing when already doing so
                       firing,
               // flag to know if the deferred has been cancelled
                       cancelled,
               // the deferred itself
                       deferred  = {

                           // done( f1, f2, ...)
                           done: function() {
                               if ( !cancelled ) {
                                   var args = arguments,
                                           i,
                                           length,
                                           elem,
                                           type,
                                           _fired;
                                   if ( fired ) {
                                       _fired = fired;
                                       fired = 0;
                                   }
                                   for ( i = 0, length = args.length; i < length; i++ ) {
                                       elem = args[ i ];
                                       type = jQuery.type( elem );
                                       if ( type === "array" ) {
                                           deferred.done.apply( deferred, elem );
                                       } else if ( type === "function" ) {
                                           callbacks.push( elem );
                                       }
                                   }
                                   if ( _fired ) {
                                       deferred.resolveWith( _fired[ 0 ], _fired[ 1 ] );
                                   }
                               }
                               return this;
                           },

                           // resolve with given context and args
                           resolveWith: function( context, args ) {
                               if ( !cancelled && !fired && !firing ) {
                                   // make sure args are available (#8421)
                                   args = args || [];
                                   firing = 1;
                                   try {
                                       while( callbacks[ 0 ] ) {
                                           callbacks.shift().apply( context, args );
                                       }
                                   }
                                   finally {
                                       fired = [ context, args ];
                                       firing = 0;
                                   }
                               }
                               return this;
                           },

                           // resolve with this as context and given arguments
                           resolve: function() {
                               deferred.resolveWith( this, arguments );
                               return this;
                           },

                           // Has this deferred been resolved?
                           isResolved: function() {
                               return !!( firing || fired );
                           },

                           // Cancel
                           cancel: function() {
                               cancelled = 1;
                               callbacks = [];
                               return this;
                           }
                       };

               return deferred;
           },

           // Full fledged deferred (two callbacks list)
           Deferred: function( func ) {
               var deferred = jQuery._Deferred(),
                       failDeferred = jQuery._Deferred(),
                       promise;
               // Add errorDeferred methods, then and promise
               jQuery.extend( deferred, {
                   then: function( doneCallbacks, failCallbacks ) {
                       deferred.done( doneCallbacks ).fail( failCallbacks );
                       return this;
                   },
                   always: function() {
                       return deferred.done.apply( deferred, arguments ).fail.apply( this, arguments );
                   },
                   fail: failDeferred.done,
                   rejectWith: failDeferred.resolveWith,
                   reject: failDeferred.resolve,
                   isRejected: failDeferred.isResolved,
                   pipe: function( fnDone, fnFail ) {
                       return jQuery.Deferred(function( newDefer ) {
                           jQuery.each( {
                               done: [ fnDone, "resolve" ],
                               fail: [ fnFail, "reject" ]
                           }, function( handler, data ) {
                               var fn = data[ 0 ],
                                       action = data[ 1 ],
                                       returned;
                               if ( jQuery.isFunction( fn ) ) {
                                   deferred[ handler ](function() {
                                       returned = fn.apply( this, arguments );
                                       if ( returned && jQuery.isFunction( returned.promise ) ) {
                                           returned.promise().then( newDefer.resolve, newDefer.reject );
                                       } else {
                                           newDefer[ action ]( returned );
                                       }
                                   });
                               } else {
                                   deferred[ handler ]( newDefer[ action ] );
                               }
                           });
                       }).promise();
                   },
                   // Get a promise for this deferred
                   // If obj is provided, the promise aspect is added to the object
                   promise: function( obj ) {
                       if ( obj == null ) {
                           if ( promise ) {
                               return promise;
                           }
                           promise = obj = {};
                       }
                       var i = promiseMethods.length;
                       while( i-- ) {
                           obj[ promiseMethods[i] ] = deferred[ promiseMethods[i] ];
                       }
                       return obj;
                   }
               });
               // Make sure only one callback list will be used
               deferred.done( failDeferred.cancel ).fail( deferred.cancel );
               // Unexpose cancel
               delete deferred.cancel;
               // Call given func if any
               if ( func ) {
                   func.call( deferred, deferred );
               }
               return deferred;
           },

           // Deferred helper
           when: function( firstParam ) {
               var args = arguments,
                       i = 0,
                       length = args.length,
                       count = length,
                       deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
                               firstParam :
                               jQuery.Deferred();
               function resolveFunc( i ) {
                   return function( value ) {
                       args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
                       if ( !( --count ) ) {
                           // Strange bug in FF4:
                           // Values changed onto the arguments object sometimes end up as undefined values
                           // outside the $.when method. Cloning the object into a fresh array solves the issue
                           deferred.resolveWith( deferred, sliceDeferred.call( args, 0 ) );
                       }
                   };
               }
               if ( length > 1 ) {
                   for( ; i < length; i++ ) {
                       if ( args[ i ] && jQuery.isFunction( args[ i ].promise ) ) {
                           args[ i ].promise().then( resolveFunc(i), deferred.reject );
                       } else {
                           --count;
                       }
                   }
                   if ( !count ) {
                       deferred.resolveWith( deferred, args );
                   }
               } else if ( deferred !== firstParam ) {
                   deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
               }
               return deferred.promise();
           }
       });



       jQuery.support = (function() {

           var div = document.createElement( "div" ),
                   documentElement = document.documentElement,
                   all,
                   a,
                   select,
                   opt,
                   input,
                   marginDiv,
                   support,
                   fragment,
                   body,
                   bodyStyle,
                   tds,
                   events,
                   eventName,
                   i,
                   isSupported;

           // Preliminary tests
           div.setAttribute("className", "t");
           div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

           all = div.getElementsByTagName( "*" );
           a = div.getElementsByTagName( "a" )[ 0 ];

           // Can't get basic test support
           if ( !all || !all.length || !a ) {
               return {};
           }

           // First batch of supports tests
           select = document.createElement( "select" );
           opt = select.appendChild( document.createElement("option") );
           input = div.getElementsByTagName( "input" )[ 0 ];

           support = {
               // IE strips leading whitespace when .innerHTML is used
               leadingWhitespace: ( div.firstChild.nodeType === 3 ),

               // Make sure that tbody elements aren't automatically inserted
               // IE will insert them into empty tables
               tbody: !div.getElementsByTagName( "tbody" ).length,

               // Make sure that link elements get serialized correctly by innerHTML
               // This requires a wrapper element in IE
               htmlSerialize: !!div.getElementsByTagName( "link" ).length,

               // Get the style information from getAttribute
               // (IE uses .cssText instead)
               style: /top/.test( a.getAttribute("style") ),

               // Make sure that URLs aren't manipulated
               // (IE normalizes it by default)
               hrefNormalized: ( a.getAttribute( "href" ) === "/a" ),

               // Make sure that element opacity exists
               // (IE uses filter instead)
               // Use a regex to work around a WebKit issue. See #5145
               opacity: /^0.55$/.test( a.style.opacity ),

               // Verify style float existence
               // (IE uses styleFloat instead of cssFloat)
               cssFloat: !!a.style.cssFloat,

               // Make sure that if no value is specified for a checkbox
               // that it defaults to "on".
               // (WebKit defaults to "" instead)
               checkOn: ( input.value === "on" ),

               // Make sure that a selected-by-default option has a working selected property.
               // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
               optSelected: opt.selected,

               // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
               getSetAttribute: div.className !== "t",

               // Will be defined later
               submitBubbles: true,
               changeBubbles: true,
               focusinBubbles: false,
               deleteExpando: true,
               noCloneEvent: true,
               inlineBlockNeedsLayout: false,
               shrinkWrapBlocks: false,
               reliableMarginRight: true
           };

           // Make sure checked status is properly cloned
           input.checked = true;
           support.noCloneChecked = input.cloneNode( true ).checked;

           // Make sure that the options inside disabled selects aren't marked as disabled
           // (WebKit marks them as disabled)
           select.disabled = true;
           support.optDisabled = !opt.disabled;

           // Test to see if it's possible to delete an expando from an element
           // Fails in Internet Explorer
           try {
               delete div.test;
           } catch( e ) {
               support.deleteExpando = false;
           }

           if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
               div.attachEvent( "onclick", function click() {
                   // Cloning a node shouldn't copy over any
                   // bound event handlers (IE does this)
                   support.noCloneEvent = false;
                   div.detachEvent( "onclick", click );
               });
               div.cloneNode( true ).fireEvent( "onclick" );
           }

           // Check if a radio maintains it's value
           // after being appended to the DOM
           input = document.createElement("input");
           input.value = "t";
           input.setAttribute("type", "radio");
           support.radioValue = input.value === "t";

           input.setAttribute("checked", "checked");
           div.appendChild( input );
           fragment = document.createDocumentFragment();
           fragment.appendChild( div.firstChild );

           // WebKit doesn't clone checked state correctly in fragments
           support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

           div.innerHTML = "";

           // Figure out if the W3C box model works as expected
           div.style.width = div.style.paddingLeft = "1px";

           // We use our own, invisible, body
           body = document.createElement( "body" );
           bodyStyle = {
               visibility: "hidden",
               width: 0,
               height: 0,
               border: 0,
               margin: 0,
               // Set background to avoid IE crashes when removing (#9028)
               background: "none"
           };
           for ( i in bodyStyle ) {
               body.style[ i ] = bodyStyle[ i ];
           }
           body.appendChild( div );
           documentElement.insertBefore( body, documentElement.firstChild );

           // Check if a disconnected checkbox will retain its checked
           // value of true after appended to the DOM (IE6/7)
           support.appendChecked = input.checked;

           support.boxModel = div.offsetWidth === 2;

           if ( "zoom" in div.style ) {
               // Check if natively block-level elements act like inline-block
               // elements when setting their display to 'inline' and giving
               // them layout
               // (IE < 8 does this)
               div.style.display = "inline";
               div.style.zoom = 1;
               support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );

               // Check if elements with layout shrink-wrap their children
               // (IE 6 does this)
               div.style.display = "";
               div.innerHTML = "<div style='width:4px;'></div>";
               support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );
           }

           div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
           tds = div.getElementsByTagName( "td" );

           // Check if table cells still have offsetWidth/Height when they are set
           // to display:none and there are still other visible table cells in a
           // table row; if so, offsetWidth/Height are not reliable for use when
           // determining if an element has been hidden directly using
           // display:none (it is still safe to use offsets if a parent element is
           // hidden; don safety goggles and see bug #4512 for more information).
           // (only IE 8 fails this test)
           isSupported = ( tds[ 0 ].offsetHeight === 0 );

           tds[ 0 ].style.display = "";
           tds[ 1 ].style.display = "none";

           // Check if empty table cells still have offsetWidth/Height
           // (IE < 8 fail this test)
           support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );
           div.innerHTML = "";

           // Check if div with explicit width and no margin-right incorrectly
           // gets computed margin-right based on width of container. For more
           // info see bug #3333
           // Fails in WebKit before Feb 2011 nightlies
           // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
           if ( document.defaultView && document.defaultView.getComputedStyle ) {
               marginDiv = document.createElement( "div" );
               marginDiv.style.width = "0";
               marginDiv.style.marginRight = "0";
               div.appendChild( marginDiv );
               support.reliableMarginRight =
                       ( parseInt( ( document.defaultView.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
           }

           // Remove the body element we added
           body.innerHTML = "";
           documentElement.removeChild( body );

           // Technique from Juriy Zaytsev
           // http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/
           // We only care about the case where non-standard event systems
           // are used, namely in IE. Short-circuiting here helps us to
           // avoid an eval call (in setAttribute) which can cause CSP
           // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
           if ( div.attachEvent ) {
               for( i in {
                   submit: 1,
                   change: 1,
                   focusin: 1
               } ) {
                   eventName = "on" + i;
                   isSupported = ( eventName in div );
                   if ( !isSupported ) {
                       div.setAttribute( eventName, "return;" );
                       isSupported = ( typeof div[ eventName ] === "function" );
                   }
                   support[ i + "Bubbles" ] = isSupported;
               }
           }

           return support;
       })();

// Keep track of boxModel
       jQuery.boxModel = jQuery.support.boxModel;




       var rbrace = /^(?:\{.*\}|\[.*\])$/,
               rmultiDash = /([a-z])([A-Z])/g;

       jQuery.extend({
           cache: {},

           // Please use with caution
           uuid: 0,

           // Unique for each copy of jQuery on the page
           // Non-digits removed to match rinlinejQuery
           expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

           // The following elements throw uncatchable exceptions if you
           // attempt to add expando properties to them.
           noData: {
               "embed": true,
               // Ban all objects except for Flash (which handle expandos)
               "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
               "applet": true
           },

           hasData: function( elem ) {
               elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];

               return !!elem && !isEmptyDataObject( elem );
           },

           data: function( elem, name, data, pvt /* Internal Use Only */ ) {
               if ( !jQuery.acceptData( elem ) ) {
                   return;
               }

               var internalKey = jQuery.expando, getByName = typeof name === "string", thisCache,

               // We have to handle DOM nodes and JS objects differently because IE6-7
               // can't GC object references properly across the DOM-JS boundary
                       isNode = elem.nodeType,

               // Only DOM nodes need the global jQuery cache; JS object data is
               // attached directly to the object so GC can occur automatically
                       cache = isNode ? jQuery.cache : elem,

               // Only defining an ID for JS objects if its cache already exists allows
               // the code to shortcut on the same path as a DOM node with no cache
                       id = isNode ? elem[ jQuery.expando ] : elem[ jQuery.expando ] && jQuery.expando;

               // Avoid doing any more work than we need to when trying to get data on an
               // object that has no data at all
               if ( (!id || (pvt && id && !cache[ id ][ internalKey ])) && getByName && data === undefined ) {
                   return;
               }

               if ( !id ) {
                   // Only DOM nodes need a new unique ID for each element since their data
                   // ends up in the global cache
                   if ( isNode ) {
                       elem[ jQuery.expando ] = id = ++jQuery.uuid;
                   } else {
                       id = jQuery.expando;
                   }
               }

               if ( !cache[ id ] ) {
                   cache[ id ] = {};

                   // TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
                   // metadata on plain JS objects when the object is serialized using
                   // JSON.stringify
                   if ( !isNode ) {
                       cache[ id ].toJSON = jQuery.noop;
                   }
               }

               // An object can be passed to jQuery.data instead of a key/value pair; this gets
               // shallow copied over onto the existing cache
               if ( typeof name === "object" || typeof name === "function" ) {
                   if ( pvt ) {
                       cache[ id ][ internalKey ] = jQuery.extend(cache[ id ][ internalKey ], name);
                   } else {
                       cache[ id ] = jQuery.extend(cache[ id ], name);
                   }
               }

               thisCache = cache[ id ];

               // Internal jQuery data is stored in a separate object inside the object's data
               // cache in order to avoid key collisions between internal data and user-defined
               // data
               if ( pvt ) {
                   if ( !thisCache[ internalKey ] ) {
                       thisCache[ internalKey ] = {};
                   }

                   thisCache = thisCache[ internalKey ];
               }

               if ( data !== undefined ) {
                   thisCache[ jQuery.camelCase( name ) ] = data;
               }

               // TODO: This is a hack for 1.5 ONLY. It will be removed in 1.6. Users should
               // not attempt to inspect the internal events object using jQuery.data, as this
               // internal data object is undocumented and subject to change.
               if ( name === "events" && !thisCache[name] ) {
                   return thisCache[ internalKey ] && thisCache[ internalKey ].events;
               }

               return getByName ? thisCache[ jQuery.camelCase( name ) ] : thisCache;
           },

           removeData: function( elem, name, pvt /* Internal Use Only */ ) {
               if ( !jQuery.acceptData( elem ) ) {
                   return;
               }

               var internalKey = jQuery.expando, isNode = elem.nodeType,

               // See jQuery.data for more information
                       cache = isNode ? jQuery.cache : elem,

               // See jQuery.data for more information
                       id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

               // If there is already no cache entry for this object, there is no
               // purpose in continuing
               if ( !cache[ id ] ) {
                   return;
               }

               if ( name ) {
                   var thisCache = pvt ? cache[ id ][ internalKey ] : cache[ id ];

                   if ( thisCache ) {
                       delete thisCache[ name ];

                       // If there is no data left in the cache, we want to continue
                       // and let the cache object itself get destroyed
                       if ( !isEmptyDataObject(thisCache) ) {
                           return;
                       }
                   }
               }

               // See jQuery.data for more information
               if ( pvt ) {
                   delete cache[ id ][ internalKey ];

                   // Don't destroy the parent cache unless the internal data object
                   // had been the only thing left in it
                   if ( !isEmptyDataObject(cache[ id ]) ) {
                       return;
                   }
               }

               var internalCache = cache[ id ][ internalKey ];

               // Browsers that fail expando deletion also refuse to delete expandos on
               // the window, but it will allow it on all other JS objects; other browsers
               // don't care
               if ( jQuery.support.deleteExpando || cache != window ) {
                   delete cache[ id ];
               } else {
                   cache[ id ] = null;
               }

               // We destroyed the entire user cache at once because it's faster than
               // iterating through each key, but we need to continue to persist internal
               // data if it existed
               if ( internalCache ) {
                   cache[ id ] = {};
                   // TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
                   // metadata on plain JS objects when the object is serialized using
                   // JSON.stringify
                   if ( !isNode ) {
                       cache[ id ].toJSON = jQuery.noop;
                   }

                   cache[ id ][ internalKey ] = internalCache;

                   // Otherwise, we need to eliminate the expando on the node to avoid
                   // false lookups in the cache for entries that no longer exist
               } else if ( isNode ) {
                   // IE does not allow us to delete expando properties from nodes,
                   // nor does it have a removeAttribute function on Document nodes;
                   // we must handle all of these cases
                   if ( jQuery.support.deleteExpando ) {
                       delete elem[ jQuery.expando ];
                   } else if ( elem.removeAttribute ) {
                       elem.removeAttribute( jQuery.expando );
                   } else {
                       elem[ jQuery.expando ] = null;
                   }
               }
           },

           // For internal use only.
           _data: function( elem, name, data ) {
               return jQuery.data( elem, name, data, true );
           },

           // A method for determining if a DOM node can handle the data expando
           acceptData: function( elem ) {
               if ( elem.nodeName ) {
                   var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

                   if ( match ) {
                       return !(match === true || elem.getAttribute("classid") !== match);
                   }
               }

               return true;
           }
       });

       jQuery.fn.extend({
           data: function( key, value ) {
               var data = null;

               if ( typeof key === "undefined" ) {
                   if ( this.length ) {
                       data = jQuery.data( this[0] );

                       if ( this[0].nodeType === 1 ) {
                           var attr = this[0].attributes, name;
                           for ( var i = 0, l = attr.length; i < l; i++ ) {
                               name = attr[i].name;

                               if ( name.indexOf( "data-" ) === 0 ) {
                                   name = jQuery.camelCase( name.substring(5) );

                                   dataAttr( this[0], name, data[ name ] );
                               }
                           }
                       }
                   }

                   return data;

               } else if ( typeof key === "object" ) {
                   return this.each(function() {
                       jQuery.data( this, key );
                   });
               }

               var parts = key.split(".");
               parts[1] = parts[1] ? "." + parts[1] : "";

               if ( value === undefined ) {
                   data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

                   // Try to fetch any internally stored data first
                   if ( data === undefined && this.length ) {
                       data = jQuery.data( this[0], key );
                       data = dataAttr( this[0], key, data );
                   }

                   return data === undefined && parts[1] ?
                           this.data( parts[0] ) :
                           data;

               } else {
                   return this.each(function() {
                       var $this = jQuery( this ),
                               args = [ parts[0], value ];

                       $this.triggerHandler( "setData" + parts[1] + "!", args );
                       jQuery.data( this, key, value );
                       $this.triggerHandler( "changeData" + parts[1] + "!", args );
                   });
               }
           },

           removeData: function( key ) {
               return this.each(function() {
                   jQuery.removeData( this, key );
               });
           }
       });

       function dataAttr( elem, key, data ) {
           // If nothing was found internally, try to fetch any
           // data from the HTML5 data-* attribute
           if ( data === undefined && elem.nodeType === 1 ) {
               var name = "data-" + key.replace( rmultiDash, "$1-$2" ).toLowerCase();

               data = elem.getAttribute( name );

               if ( typeof data === "string" ) {
                   try {
                       data = data === "true" ? true :
                               data === "false" ? false :
                                       data === "null" ? null :
                                               !jQuery.isNaN( data ) ? parseFloat( data ) :
                                                       rbrace.test( data ) ? jQuery.parseJSON( data ) :
                                                               data;
                   } catch( e ) {}

                   // Make sure we set the data so it isn't changed later
                   jQuery.data( elem, key, data );

               } else {
                   data = undefined;
               }
           }

           return data;
       }

// TODO: This is a hack for 1.5 ONLY to allow objects with a single toJSON
// property to be considered empty objects; this property always exists in
// order to make sure JSON.stringify does not expose internal metadata
       function isEmptyDataObject( obj ) {
           for ( var name in obj ) {
               if ( name !== "toJSON" ) {
                   return false;
               }
           }

           return true;
       }




       function handleQueueMarkDefer( elem, type, src ) {
           var deferDataKey = type + "defer",
                   queueDataKey = type + "queue",
                   markDataKey = type + "mark",
                   defer = jQuery.data( elem, deferDataKey, undefined, true );
           if ( defer &&
                   ( src === "queue" || !jQuery.data( elem, queueDataKey, undefined, true ) ) &&
                   ( src === "mark" || !jQuery.data( elem, markDataKey, undefined, true ) ) ) {
               // Give room for hard-coded callbacks to fire first
               // and eventually mark/queue something else on the element
               setTimeout( function() {
                   if ( !jQuery.data( elem, queueDataKey, undefined, true ) &&
                           !jQuery.data( elem, markDataKey, undefined, true ) ) {
                       jQuery.removeData( elem, deferDataKey, true );
                       defer.resolve();
                   }
               }, 0 );
           }
       }

       jQuery.extend({

           _mark: function( elem, type ) {
               if ( elem ) {
                   type = (type || "fx") + "mark";
                   jQuery.data( elem, type, (jQuery.data(elem,type,undefined,true) || 0) + 1, true );
               }
           },

           _unmark: function( force, elem, type ) {
               if ( force !== true ) {
                   type = elem;
                   elem = force;
                   force = false;
               }
               if ( elem ) {
                   type = type || "fx";
                   var key = type + "mark",
                           count = force ? 0 : ( (jQuery.data( elem, key, undefined, true) || 1 ) - 1 );
                   if ( count ) {
                       jQuery.data( elem, key, count, true );
                   } else {
                       jQuery.removeData( elem, key, true );
                       handleQueueMarkDefer( elem, type, "mark" );
                   }
               }
           },

           queue: function( elem, type, data ) {
               if ( elem ) {
                   type = (type || "fx") + "queue";
                   var q = jQuery.data( elem, type, undefined, true );
                   // Speed up dequeue by getting out quickly if this is just a lookup
                   if ( data ) {
                       if ( !q || jQuery.isArray(data) ) {
                           q = jQuery.data( elem, type, jQuery.makeArray(data), true );
                       } else {
                           q.push( data );
                       }
                   }
                   return q || [];
               }
           },

           dequeue: function( elem, type ) {
               type = type || "fx";

               var queue = jQuery.queue( elem, type ),
                       fn = queue.shift(),
                       defer;

               // If the fx queue is dequeued, always remove the progress sentinel
               if ( fn === "inprogress" ) {
                   fn = queue.shift();
               }

               if ( fn ) {
                   // Add a progress sentinel to prevent the fx queue from being
                   // automatically dequeued
                   if ( type === "fx" ) {
                       queue.unshift("inprogress");
                   }

                   fn.call(elem, function() {
                       jQuery.dequeue(elem, type);
                   });
               }

               if ( !queue.length ) {
                   jQuery.removeData( elem, type + "queue", true );
                   handleQueueMarkDefer( elem, type, "queue" );
               }
           }
       });

       jQuery.fn.extend({
           queue: function( type, data ) {
               if ( typeof type !== "string" ) {
                   data = type;
                   type = "fx";
               }

               if ( data === undefined ) {
                   return jQuery.queue( this[0], type );
               }
               return this.each(function() {
                   var queue = jQuery.queue( this, type, data );

                   if ( type === "fx" && queue[0] !== "inprogress" ) {
                       jQuery.dequeue( this, type );
                   }
               });
           },
           dequeue: function( type ) {
               return this.each(function() {
                   jQuery.dequeue( this, type );
               });
           },
           // Based off of the plugin by Clint Helfers, with permission.
           // http://blindsignals.com/index.php/2009/07/jquery-delay/
           delay: function( time, type ) {
               time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
               type = type || "fx";

               return this.queue( type, function() {
                   var elem = this;
                   setTimeout(function() {
                       jQuery.dequeue( elem, type );
                   }, time );
               });
           },
           clearQueue: function( type ) {
               return this.queue( type || "fx", [] );
           },
           // Get a promise resolved when queues of a certain type
           // are emptied (fx is the type by default)
           promise: function( type, object ) {
               if ( typeof type !== "string" ) {
                   object = type;
                   type = undefined;
               }
               type = type || "fx";
               var defer = jQuery.Deferred(),
                       elements = this,
                       i = elements.length,
                       count = 1,
                       deferDataKey = type + "defer",
                       queueDataKey = type + "queue",
                       markDataKey = type + "mark",
                       tmp;
               function resolve() {
                   if ( !( --count ) ) {
                       defer.resolveWith( elements, [ elements ] );
                   }
               }
               while( i-- ) {
                   if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
                           ( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
                                   jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
                                   jQuery.data( elements[ i ], deferDataKey, jQuery._Deferred(), true ) )) {
                       count++;
                       tmp.done( resolve );
                   }
               }
               resolve();
               return defer.promise();
           }
       });




       var rclass = /[\n\t\r]/g,
               rspace = /\s+/,
               rreturn = /\r/g,
               rtype = /^(?:button|input)$/i,
               rfocusable = /^(?:button|input|object|select|textarea)$/i,
               rclickable = /^a(?:rea)?$/i,
               rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
               rinvalidChar = /\:/,
               formHook, boolHook;

       jQuery.fn.extend({
           attr: function( name, value ) {
               return jQuery.access( this, name, value, true, jQuery.attr );
           },

           removeAttr: function( name ) {
               return this.each(function() {
                   jQuery.removeAttr( this, name );
               });
           },

           prop: function( name, value ) {
               return jQuery.access( this, name, value, true, jQuery.prop );
           },

           removeProp: function( name ) {
               name = jQuery.propFix[ name ] || name;
               return this.each(function() {
                   // try/catch handles cases where IE balks (such as removing a property on window)
                   try {
                       this[ name ] = undefined;
                       delete this[ name ];
                   } catch( e ) {}
               });
           },

           addClass: function( value ) {
               if ( jQuery.isFunction( value ) ) {
                   return this.each(function(i) {
                       var self = jQuery(this);
                       self.addClass( value.call(this, i, self.attr("class") || "") );
                   });
               }

               if ( value && typeof value === "string" ) {
                   var classNames = (value || "").split( rspace );

                   for ( var i = 0, l = this.length; i < l; i++ ) {
                       var elem = this[i];

                       if ( elem.nodeType === 1 ) {
                           if ( !elem.className ) {
                               elem.className = value;

                           } else {
                               var className = " " + elem.className + " ",
                                       setClass = elem.className;

                               for ( var c = 0, cl = classNames.length; c < cl; c++ ) {
                                   if ( className.indexOf( " " + classNames[c] + " " ) < 0 ) {
                                       setClass += " " + classNames[c];
                                   }
                               }
                               elem.className = jQuery.trim( setClass );
                           }
                       }
                   }
               }

               return this;
           },

           removeClass: function( value ) {
               if ( jQuery.isFunction(value) ) {
                   return this.each(function(i) {
                       var self = jQuery(this);
                       self.removeClass( value.call(this, i, self.attr("class")) );
                   });
               }

               if ( (value && typeof value === "string") || value === undefined ) {
                   var classNames = (value || "").split( rspace );

                   for ( var i = 0, l = this.length; i < l; i++ ) {
                       var elem = this[i];

                       if ( elem.nodeType === 1 && elem.className ) {
                           if ( value ) {
                               var className = (" " + elem.className + " ").replace(rclass, " ");
                               for ( var c = 0, cl = classNames.length; c < cl; c++ ) {
                                   className = className.replace(" " + classNames[c] + " ", " ");
                               }
                               elem.className = jQuery.trim( className );

                           } else {
                               elem.className = "";
                           }
                       }
                   }
               }

               return this;
           },

           toggleClass: function( value, stateVal ) {
               var type = typeof value,
                       isBool = typeof stateVal === "boolean";

               if ( jQuery.isFunction( value ) ) {
                   return this.each(function(i) {
                       var self = jQuery(this);
                       self.toggleClass( value.call(this, i, self.attr("class"), stateVal), stateVal );
                   });
               }

               return this.each(function() {
                   if ( type === "string" ) {
                       // toggle individual class names
                       var className,
                               i = 0,
                               self = jQuery( this ),
                               state = stateVal,
                               classNames = value.split( rspace );

                       while ( (className = classNames[ i++ ]) ) {
                           // check each className given, space seperated list
                           state = isBool ? state : !self.hasClass( className );
                           self[ state ? "addClass" : "removeClass" ]( className );
                       }

                   } else if ( type === "undefined" || type === "boolean" ) {
                       if ( this.className ) {
                           // store className if set
                           jQuery._data( this, "__className__", this.className );
                       }

                       // toggle whole className
                       this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
                   }
               });
           },

           hasClass: function( selector ) {
               var className = " " + selector + " ";
               for ( var i = 0, l = this.length; i < l; i++ ) {
                   if ( (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
                       return true;
                   }
               }

               return false;
           },

           val: function( value ) {
               var hooks, ret,
                       elem = this[0];

               if ( !arguments.length ) {
                   if ( elem ) {
                       hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];

                       if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
                           return ret;
                       }

                       return (elem.value || "").replace(rreturn, "");
                   }

                   return undefined;
               }

               var isFunction = jQuery.isFunction( value );

               return this.each(function( i ) {
                   var self = jQuery(this), val;

                   if ( this.nodeType !== 1 ) {
                       return;
                   }

                   if ( isFunction ) {
                       val = value.call( this, i, self.val() );
                   } else {
                       val = value;
                   }

                   // Treat null/undefined as ""; convert numbers to string
                   if ( val == null ) {
                       val = "";
                   } else if ( typeof val === "number" ) {
                       val += "";
                   } else if ( jQuery.isArray( val ) ) {
                       val = jQuery.map(val, function ( value ) {
                           return value == null ? "" : value + "";
                       });
                   }

                   hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];

                   // If set returns undefined, fall back to normal setting
                   if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
                       this.value = val;
                   }
               });
           }
       });

       jQuery.extend({
           valHooks: {
               option: {
                   get: function( elem ) {
                       // attributes.value is undefined in Blackberry 4.7 but
                       // uses .value. See #6932
                       var val = elem.attributes.value;
                       return !val || val.specified ? elem.value : elem.text;
                   }
               },
               select: {
                   get: function( elem ) {
                       var value,
                               index = elem.selectedIndex,
                               values = [],
                               options = elem.options,
                               one = elem.type === "select-one";

                       // Nothing was selected
                       if ( index < 0 ) {
                           return null;
                       }

                       // Loop through all the selected options
                       for ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) {
                           var option = options[ i ];

                           // Don't return options that are disabled or in a disabled optgroup
                           if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
                                   (!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

                               // Get the specific value for the option
                               value = jQuery( option ).val();

                               // We don't need an array for one selects
                               if ( one ) {
                                   return value;
                               }

                               // Multi-Selects return an array
                               values.push( value );
                           }
                       }

                       // Fixes Bug #2551 -- select.val() broken in IE after form.reset()
                       if ( one && !values.length && options.length ) {
                           return jQuery( options[ index ] ).val();
                       }

                       return values;
                   },

                   set: function( elem, value ) {
                       var values = jQuery.makeArray( value );

                       jQuery(elem).find("option").each(function() {
                           this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
                       });

                       if ( !values.length ) {
                           elem.selectedIndex = -1;
                       }
                       return values;
                   }
               }
           },

           attrFn: {
               val: true,
               css: true,
               html: true,
               text: true,
               data: true,
               width: true,
               height: true,
               offset: true
           },

           attrFix: {
               // Always normalize to ensure hook usage
               tabindex: "tabIndex"
           },

           attr: function( elem, name, value, pass ) {
               var nType = elem.nodeType;

               // don't get/set attributes on text, comment and attribute nodes
               if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                   return undefined;
               }

               if ( pass && name in jQuery.attrFn ) {
                   return jQuery( elem )[ name ]( value );
               }

               // Fallback to prop when attributes are not supported
               if ( !("getAttribute" in elem) ) {
                   return jQuery.prop( elem, name, value );
               }

               var ret, hooks,
                       notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

               // Normalize the name if needed
               name = notxml && jQuery.attrFix[ name ] || name;

               hooks = jQuery.attrHooks[ name ];

               if ( !hooks ) {
                   // Use boolHook for boolean attributes
                   if ( rboolean.test( name ) &&
                           (typeof value === "boolean" || value === undefined || value.toLowerCase() === name.toLowerCase()) ) {

                       hooks = boolHook;

                       // Use formHook for forms and if the name contains certain characters
                   } else if ( formHook && (jQuery.nodeName( elem, "form" ) || rinvalidChar.test( name )) ) {
                       hooks = formHook;
                   }
               }

               if ( value !== undefined ) {

                   if ( value === null ) {
                       jQuery.removeAttr( elem, name );
                       return undefined;

                   } else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
                       return ret;

                   } else {
                       elem.setAttribute( name, "" + value );
                       return value;
                   }

               } else if ( hooks && "get" in hooks && notxml ) {
                   return hooks.get( elem, name );

               } else {

                   ret = elem.getAttribute( name );

                   // Non-existent attributes return null, we normalize to undefined
                   return ret === null ?
                           undefined :
                           ret;
               }
           },

           removeAttr: function( elem, name ) {
               var propName;
               if ( elem.nodeType === 1 ) {
                   name = jQuery.attrFix[ name ] || name;

                   if ( jQuery.support.getSetAttribute ) {
                       // Use removeAttribute in browsers that support it
                       elem.removeAttribute( name );
                   } else {
                       jQuery.attr( elem, name, "" );
                       elem.removeAttributeNode( elem.getAttributeNode( name ) );
                   }

                   // Set corresponding property to false for boolean attributes
                   if ( rboolean.test( name ) && (propName = jQuery.propFix[ name ] || name) in elem ) {
                       elem[ propName ] = false;
                   }
               }
           },

           attrHooks: {
               type: {
                   set: function( elem, value ) {
                       // We can't allow the type property to be changed (since it causes problems in IE)
                       if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
                           jQuery.error( "type property can't be changed" );
                       } else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
                           // Setting the type on a radio button after the value resets the value in IE6-9
                           // Reset value to it's default in case type is set after value
                           // This is for element creation
                           var val = elem.value;
                           elem.setAttribute( "type", value );
                           if ( val ) {
                               elem.value = val;
                           }
                           return value;
                       }
                   }
               },
               tabIndex: {
                   get: function( elem ) {
                       // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                       // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                       var attributeNode = elem.getAttributeNode("tabIndex");

                       return attributeNode && attributeNode.specified ?
                               parseInt( attributeNode.value, 10 ) :
                               rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
                                       0 :
                                       undefined;
                   }
               }
           },

           propFix: {
               tabindex: "tabIndex",
               readonly: "readOnly",
               "for": "htmlFor",
               "class": "className",
               maxlength: "maxLength",
               cellspacing: "cellSpacing",
               cellpadding: "cellPadding",
               rowspan: "rowSpan",
               colspan: "colSpan",
               usemap: "useMap",
               frameborder: "frameBorder",
               contenteditable: "contentEditable"
           },

           prop: function( elem, name, value ) {
               var nType = elem.nodeType;

               // don't get/set properties on text, comment and attribute nodes
               if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
                   return undefined;
               }

               var ret, hooks,
                       notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

               // Try to normalize/fix the name
               name = notxml && jQuery.propFix[ name ] || name;

               hooks = jQuery.propHooks[ name ];

               if ( value !== undefined ) {
                   if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
                       return ret;

                   } else {
                       return (elem[ name ] = value);
                   }

               } else {
                   if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== undefined ) {
                       return ret;

                   } else {
                       return elem[ name ];
                   }
               }
           },

           propHooks: {}
       });

// Hook for boolean attributes
       boolHook = {
           get: function( elem, name ) {
               // Align boolean attributes with corresponding properties
               return elem[ jQuery.propFix[ name ] || name ] ?
                       name.toLowerCase() :
                       undefined;
           },
           set: function( elem, value, name ) {
               var propName;
               if ( value === false ) {
                   // Remove boolean attributes when set to false
                   jQuery.removeAttr( elem, name );
               } else {
                   // value is true since we know at this point it's type boolean and not false
                   // Set boolean attributes to the same name and set the DOM property
                   propName = jQuery.propFix[ name ] || name;
                   if ( propName in elem ) {
                       // Only set the IDL specifically if it already exists on the element
                       elem[ propName ] = value;
                   }

                   elem.setAttribute( name, name.toLowerCase() );
               }
               return name;
           }
       };

// Use the value property for back compat
// Use the formHook for button elements in IE6/7 (#1954)
       jQuery.attrHooks.value = {
           get: function( elem, name ) {
               if ( formHook && jQuery.nodeName( elem, "button" ) ) {
                   return formHook.get( elem, name );
               }
               return elem.value;
           },
           set: function( elem, value, name ) {
               if ( formHook && jQuery.nodeName( elem, "button" ) ) {
                   return formHook.set( elem, value, name );
               }
               // Does not return so that setAttribute is also used
               elem.value = value;
           }
       };

// IE6/7 do not support getting/setting some attributes with get/setAttribute
       if ( !jQuery.support.getSetAttribute ) {

           // propFix is more comprehensive and contains all fixes
           jQuery.attrFix = jQuery.propFix;

           // Use this for any attribute on a form in IE6/7
           formHook = jQuery.attrHooks.name = jQuery.valHooks.button = {
               get: function( elem, name ) {
                   var ret;
                   ret = elem.getAttributeNode( name );
                   // Return undefined if nodeValue is empty string
                   return ret && ret.nodeValue !== "" ?
                           ret.nodeValue :
                           undefined;
               },
               set: function( elem, value, name ) {
                   // Check form objects in IE (multiple bugs related)
                   // Only use nodeValue if the attribute node exists on the form
                   var ret = elem.getAttributeNode( name );
                   if ( ret ) {
                       ret.nodeValue = value;
                       return value;
                   }
               }
           };

           // Set width and height to auto instead of 0 on empty string( Bug #8150 )
           // This is for removals
           jQuery.each([ "width", "height" ], function( i, name ) {
               jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
                   set: function( elem, value ) {
                       if ( value === "" ) {
                           elem.setAttribute( name, "auto" );
                           return value;
                       }
                   }
               });
           });
       }


// Some attributes require a special call on IE
       if ( !jQuery.support.hrefNormalized ) {
           jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
               jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
                   get: function( elem ) {
                       var ret = elem.getAttribute( name, 2 );
                       return ret === null ? undefined : ret;
                   }
               });
           });
       }

       if ( !jQuery.support.style ) {
           jQuery.attrHooks.style = {
               get: function( elem ) {
                   // Return undefined in the case of empty string
                   // Normalize to lowercase since IE uppercases css property names
                   return elem.style.cssText.toLowerCase() || undefined;
               },
               set: function( elem, value ) {
                   return (elem.style.cssText = "" + value);
               }
           };
       }

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
       if ( !jQuery.support.optSelected ) {
           jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
               get: function( elem ) {
                   var parent = elem.parentNode;

                   if ( parent ) {
                       parent.selectedIndex;

                       // Make sure that it also works with optgroups, see #5701
                       if ( parent.parentNode ) {
                           parent.parentNode.selectedIndex;
                       }
                   }
               }
           });
       }

// Radios and checkboxes getter/setter
       if ( !jQuery.support.checkOn ) {
           jQuery.each([ "radio", "checkbox" ], function() {
               jQuery.valHooks[ this ] = {
                   get: function( elem ) {
                       // Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
                       return elem.getAttribute("value") === null ? "on" : elem.value;
                   }
               };
           });
       }
       jQuery.each([ "radio", "checkbox" ], function() {
           jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
               set: function( elem, value ) {
                   if ( jQuery.isArray( value ) ) {
                       return (elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0);
                   }
               }
           });
       });




       var hasOwn = Object.prototype.hasOwnProperty,
               rnamespaces = /\.(.*)$/,
               rformElems = /^(?:textarea|input|select)$/i,
               rperiod = /\./g,
               rspaces = / /g,
               rescape = /[^\w\s.|`]/g,
               fcleanup = function( nm ) {
                   return nm.replace(rescape, "\\$&");
               };

       /*
        * A number of helper functions used for managing events.
        * Many of the ideas behind this code originated from
        * Dean Edwards' addEvent library.
        */
       jQuery.event = {

           // Bind an event to an element
           // Original by Dean Edwards
           add: function( elem, types, handler, data ) {
               if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                   return;
               }

               if ( handler === false ) {
                   handler = returnFalse;
               } else if ( !handler ) {
                   // Fixes bug #7229. Fix recommended by jdalton
                   return;
               }

               var handleObjIn, handleObj;

               if ( handler.handler ) {
                   handleObjIn = handler;
                   handler = handleObjIn.handler;
               }

               // Make sure that the function being executed has a unique ID
               if ( !handler.guid ) {
                   handler.guid = jQuery.guid++;
               }

               // Init the element's event structure
               var elemData = jQuery._data( elem );

               // If no elemData is found then we must be trying to bind to one of the
               // banned noData elements
               if ( !elemData ) {
                   return;
               }

               var events = elemData.events,
                       eventHandle = elemData.handle;

               if ( !events ) {
                   elemData.events = events = {};
               }

               if ( !eventHandle ) {
                   elemData.handle = eventHandle = function( e ) {
                       // Discard the second event of a jQuery.event.trigger() and
                       // when an event is called after a page has unloaded
                       return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
                               jQuery.event.handle.apply( eventHandle.elem, arguments ) :
                               undefined;
                   };
               }

               // Add elem as a property of the handle function
               // This is to prevent a memory leak with non-native events in IE.
               eventHandle.elem = elem;

               // Handle multiple events separated by a space
               // jQuery(...).bind("mouseover mouseout", fn);
               types = types.split(" ");

               var type, i = 0, namespaces;

               while ( (type = types[ i++ ]) ) {
                   handleObj = handleObjIn ?
                           jQuery.extend({}, handleObjIn) :
                   { handler: handler, data: data };

                   // Namespaced event handlers
                   if ( type.indexOf(".") > -1 ) {
                       namespaces = type.split(".");
                       type = namespaces.shift();
                       handleObj.namespace = namespaces.slice(0).sort().join(".");

                   } else {
                       namespaces = [];
                       handleObj.namespace = "";
                   }

                   handleObj.type = type;
                   if ( !handleObj.guid ) {
                       handleObj.guid = handler.guid;
                   }

                   // Get the current list of functions bound to this event
                   var handlers = events[ type ],
                           special = jQuery.event.special[ type ] || {};

                   // Init the event handler queue
                   if ( !handlers ) {
                       handlers = events[ type ] = [];

                       // Check for a special event handler
                       // Only use addEventListener/attachEvent if the special
                       // events handler returns false
                       if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
                           // Bind the global event handler to the element
                           if ( elem.addEventListener ) {
                               elem.addEventListener( type, eventHandle, false );

                           } else if ( elem.attachEvent ) {
                               elem.attachEvent( "on" + type, eventHandle );
                           }
                       }
                   }

                   if ( special.add ) {
                       special.add.call( elem, handleObj );

                       if ( !handleObj.handler.guid ) {
                           handleObj.handler.guid = handler.guid;
                       }
                   }

                   // Add the function to the element's handler list
                   handlers.push( handleObj );

                   // Keep track of which events have been used, for event optimization
                   jQuery.event.global[ type ] = true;
               }

               // Nullify elem to prevent memory leaks in IE
               elem = null;
           },

           global: {},

           // Detach an event or set of events from an element
           remove: function( elem, types, handler, pos ) {
               // don't do events on text and comment nodes
               if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                   return;
               }

               if ( handler === false ) {
                   handler = returnFalse;
               }

               var ret, type, fn, j, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType,
                       elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
                       events = elemData && elemData.events;

               if ( !elemData || !events ) {
                   return;
               }

               // types is actually an event object here
               if ( types && types.type ) {
                   handler = types.handler;
                   types = types.type;
               }

               // Unbind all events for the element
               if ( !types || typeof types === "string" && types.charAt(0) === "." ) {
                   types = types || "";

                   for ( type in events ) {
                       jQuery.event.remove( elem, type + types );
                   }

                   return;
               }

               // Handle multiple events separated by a space
               // jQuery(...).unbind("mouseover mouseout", fn);
               types = types.split(" ");

               while ( (type = types[ i++ ]) ) {
                   origType = type;
                   handleObj = null;
                   all = type.indexOf(".") < 0;
                   namespaces = [];

                   if ( !all ) {
                       // Namespaced event handlers
                       namespaces = type.split(".");
                       type = namespaces.shift();

                       namespace = new RegExp("(^|\\.)" +
                               jQuery.map( namespaces.slice(0).sort(), fcleanup ).join("\\.(?:.*\\.)?") + "(\\.|$)");
                   }

                   eventType = events[ type ];

                   if ( !eventType ) {
                       continue;
                   }

                   if ( !handler ) {
                       for ( j = 0; j < eventType.length; j++ ) {
                           handleObj = eventType[ j ];

                           if ( all || namespace.test( handleObj.namespace ) ) {
                               jQuery.event.remove( elem, origType, handleObj.handler, j );
                               eventType.splice( j--, 1 );
                           }
                       }

                       continue;
                   }

                   special = jQuery.event.special[ type ] || {};

                   for ( j = pos || 0; j < eventType.length; j++ ) {
                       handleObj = eventType[ j ];

                       if ( handler.guid === handleObj.guid ) {
                           // remove the given handler for the given type
                           if ( all || namespace.test( handleObj.namespace ) ) {
                               if ( pos == null ) {
                                   eventType.splice( j--, 1 );
                               }

                               if ( special.remove ) {
                                   special.remove.call( elem, handleObj );
                               }
                           }

                           if ( pos != null ) {
                               break;
                           }
                       }
                   }

                   // remove generic event handler if no more handlers exist
                   if ( eventType.length === 0 || pos != null && eventType.length === 1 ) {
                       if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
                           jQuery.removeEvent( elem, type, elemData.handle );
                       }

                       ret = null;
                       delete events[ type ];
                   }
               }

               // Remove the expando if it's no longer used
               if ( jQuery.isEmptyObject( events ) ) {
                   var handle = elemData.handle;
                   if ( handle ) {
                       handle.elem = null;
                   }

                   delete elemData.events;
                   delete elemData.handle;

                   if ( jQuery.isEmptyObject( elemData ) ) {
                       jQuery.removeData( elem, undefined, true );
                   }
               }
           },

           // Events that are safe to short-circuit if no handlers are attached.
           // Native DOM events should not be added, they may have inline handlers.
           customEvent: {
               "getData": true,
               "setData": true,
               "changeData": true
           },

           trigger: function( event, data, elem, onlyHandlers ) {
               // Event object or event type
               var type = event.type || event,
                       namespaces = [],
                       exclusive;

               if ( type.indexOf("!") >= 0 ) {
                   // Exclusive events trigger only for the exact event (no namespaces)
                   type = type.slice(0, -1);
                   exclusive = true;
               }

               if ( type.indexOf(".") >= 0 ) {
                   // Namespaced trigger; create a regexp to match event type in handle()
                   namespaces = type.split(".");
                   type = namespaces.shift();
                   namespaces.sort();
               }

               if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
                   // No jQuery handlers for this event type, and it can't have inline handlers
                   return;
               }

               // Caller can pass in an Event, Object, or just an event type string
               event = typeof event === "object" ?
                   // jQuery.Event object
                       event[ jQuery.expando ] ? event :
                           // Object literal
                               new jQuery.Event( type, event ) :
                   // Just the event type (string)
                       new jQuery.Event( type );

               event.type = type;
               event.exclusive = exclusive;
               event.namespace = namespaces.join(".");
               event.namespace_re = new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)");

               // triggerHandler() and global events don't bubble or run the default action
               if ( onlyHandlers || !elem ) {
                   event.preventDefault();
                   event.stopPropagation();
               }

               // Handle a global trigger
               if ( !elem ) {
                   // TODO: Stop taunting the data cache; remove global events and always attach to document
                   jQuery.each( jQuery.cache, function() {
                       // internalKey variable is just used to make it easier to find
                       // and potentially change this stuff later; currently it just
                       // points to jQuery.expando
                       var internalKey = jQuery.expando,
                               internalCache = this[ internalKey ];
                       if ( internalCache && internalCache.events && internalCache.events[ type ] ) {
                           jQuery.event.trigger( event, data, internalCache.handle.elem );
                       }
                   });
                   return;
               }

               // Don't do events on text and comment nodes
               if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
                   return;
               }

               // Clean up the event in case it is being reused
               event.result = undefined;
               event.target = elem;

               // Clone any incoming data and prepend the event, creating the handler arg list
               data = data ? jQuery.makeArray( data ) : [];
               data.unshift( event );

               var cur = elem,
               // IE doesn't like method names with a colon (#3533, #8272)
                       ontype = type.indexOf(":") < 0 ? "on" + type : "";

               // Fire event on the current element, then bubble up the DOM tree
               do {
                   var handle = jQuery._data( cur, "handle" );

                   event.currentTarget = cur;
                   if ( handle ) {
                       handle.apply( cur, data );
                   }

                   // Trigger an inline bound script
                   if ( ontype && jQuery.acceptData( cur ) && cur[ ontype ] && cur[ ontype ].apply( cur, data ) === false ) {
                       event.result = false;
                       event.preventDefault();
                   }

                   // Bubble up to document, then to window
                   cur = cur.parentNode || cur.ownerDocument || cur === event.target.ownerDocument && window;
               } while ( cur && !event.isPropagationStopped() );

               // If nobody prevented the default action, do it now
               if ( !event.isDefaultPrevented() ) {
                   var old,
                           special = jQuery.event.special[ type ] || {};

                   if ( (!special._default || special._default.call( elem.ownerDocument, event ) === false) &&
                           !(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

                       // Call a native DOM method on the target with the same name name as the event.
                       // Can't use an .isFunction)() check here because IE6/7 fails that test.
                       // IE<9 dies on focus to hidden element (#1486), may want to revisit a try/catch.
                       try {
                           if ( ontype && elem[ type ] ) {
                               // Don't re-trigger an onFOO event when we call its FOO() method
                               old = elem[ ontype ];

                               if ( old ) {
                                   elem[ ontype ] = null;
                               }

                               jQuery.event.triggered = type;
                               elem[ type ]();
                           }
                       } catch ( ieError ) {}

                       if ( old ) {
                           elem[ ontype ] = old;
                       }

                       jQuery.event.triggered = undefined;
                   }
               }

               return event.result;
           },

           handle: function( event ) {
               event = jQuery.event.fix( event || window.event );
               // Snapshot the handlers list since a called handler may add/remove events.
               var handlers = ((jQuery._data( this, "events" ) || {})[ event.type ] || []).slice(0),
                       run_all = !event.exclusive && !event.namespace,
                       args = Array.prototype.slice.call( arguments, 0 );

               // Use the fix-ed Event rather than the (read-only) native event
               args[0] = event;
               event.currentTarget = this;

               for ( var j = 0, l = handlers.length; j < l; j++ ) {
                   var handleObj = handlers[ j ];

                   // Triggered event must 1) be non-exclusive and have no namespace, or
                   // 2) have namespace(s) a subset or equal to those in the bound event.
                   if ( run_all || event.namespace_re.test( handleObj.namespace ) ) {
                       // Pass in a reference to the handler function itself
                       // So that we can later remove it
                       event.handler = handleObj.handler;
                       event.data = handleObj.data;
                       event.handleObj = handleObj;

                       var ret = handleObj.handler.apply( this, args );

                       if ( ret !== undefined ) {
                           event.result = ret;
                           if ( ret === false ) {
                               event.preventDefault();
                               event.stopPropagation();
                           }
                       }

                       if ( event.isImmediatePropagationStopped() ) {
                           break;
                       }
                   }
               }
               return event.result;
           },

           props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),

           fix: function( event ) {
               if ( event[ jQuery.expando ] ) {
                   return event;
               }

               // store a copy of the original event object
               // and "clone" to set read-only properties
               var originalEvent = event;
               event = jQuery.Event( originalEvent );

               for ( var i = this.props.length, prop; i; ) {
                   prop = this.props[ --i ];
                   event[ prop ] = originalEvent[ prop ];
               }

               // Fix target property, if necessary
               if ( !event.target ) {
                   // Fixes #1925 where srcElement might not be defined either
                   event.target = event.srcElement || document;
               }

               // check if target is a textnode (safari)
               if ( event.target.nodeType === 3 ) {
                   event.target = event.target.parentNode;
               }

               // Add relatedTarget, if necessary
               if ( !event.relatedTarget && event.fromElement ) {
                   event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
               }

               // Calculate pageX/Y if missing and clientX/Y available
               if ( event.pageX == null && event.clientX != null ) {
                   var eventDocument = event.target.ownerDocument || document,
                           doc = eventDocument.documentElement,
                           body = eventDocument.body;

                   event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                   event.pageY = event.clientY + (doc && doc.scrollTop  || body && body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop  || 0);
               }

               // Add which for key events
               if ( event.which == null && (event.charCode != null || event.keyCode != null) ) {
                   event.which = event.charCode != null ? event.charCode : event.keyCode;
               }

               // Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
               if ( !event.metaKey && event.ctrlKey ) {
                   event.metaKey = event.ctrlKey;
               }

               // Add which for click: 1 === left; 2 === middle; 3 === right
               // Note: button is not normalized, so don't use it
               if ( !event.which && event.button !== undefined ) {
                   event.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) ));
               }

               return event;
           },

           // Deprecated, use jQuery.guid instead
           guid: 1E8,

           // Deprecated, use jQuery.proxy instead
           proxy: jQuery.proxy,

           special: {
               ready: {
                   // Make sure the ready event is setup
                   setup: jQuery.bindReady,
                   teardown: jQuery.noop
               },

               live: {
                   add: function( handleObj ) {
                       jQuery.event.add( this,
                               liveConvert( handleObj.origType, handleObj.selector ),
                               jQuery.extend({}, handleObj, {handler: liveHandler, guid: handleObj.handler.guid}) );
                   },

                   remove: function( handleObj ) {
                       jQuery.event.remove( this, liveConvert( handleObj.origType, handleObj.selector ), handleObj );
                   }
               },

               beforeunload: {
                   setup: function( data, namespaces, eventHandle ) {
                       // We only want to do this special case on windows
                       if ( jQuery.isWindow( this ) ) {
                           this.onbeforeunload = eventHandle;
                       }
                   },

                   teardown: function( namespaces, eventHandle ) {
                       if ( this.onbeforeunload === eventHandle ) {
                           this.onbeforeunload = null;
                       }
                   }
               }
           }
       };

       jQuery.removeEvent = document.removeEventListener ?
               function( elem, type, handle ) {
                   if ( elem.removeEventListener ) {
                       elem.removeEventListener( type, handle, false );
                   }
               } :
               function( elem, type, handle ) {
                   if ( elem.detachEvent ) {
                       elem.detachEvent( "on" + type, handle );
                   }
               };

       jQuery.Event = function( src, props ) {
           // Allow instantiation without the 'new' keyword
           if ( !this.preventDefault ) {
               return new jQuery.Event( src, props );
           }

           // Event object
           if ( src && src.type ) {
               this.originalEvent = src;
               this.type = src.type;

               // Events bubbling up the document may have been marked as prevented
               // by a handler lower down the tree; reflect the correct value.
               this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false ||
                       src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;

               // Event type
           } else {
               this.type = src;
           }

           // Put explicitly provided properties onto the event object
           if ( props ) {
               jQuery.extend( this, props );
           }

           // timeStamp is buggy for some events on Firefox(#3843)
           // So we won't rely on the native value
           this.timeStamp = jQuery.now();

           // Mark it as fixed
           this[ jQuery.expando ] = true;
       };

       function returnFalse() {
           return false;
       }
       function returnTrue() {
           return true;
       }

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
       jQuery.Event.prototype = {
           preventDefault: function() {
               this.isDefaultPrevented = returnTrue;

               var e = this.originalEvent;
               if ( !e ) {
                   return;
               }

               // if preventDefault exists run it on the original event
               if ( e.preventDefault ) {
                   e.preventDefault();

                   // otherwise set the returnValue property of the original event to false (IE)
               } else {
                   e.returnValue = false;
               }
           },
           stopPropagation: function() {
               this.isPropagationStopped = returnTrue;

               var e = this.originalEvent;
               if ( !e ) {
                   return;
               }
               // if stopPropagation exists run it on the original event
               if ( e.stopPropagation ) {
                   e.stopPropagation();
               }
               // otherwise set the cancelBubble property of the original event to true (IE)
               e.cancelBubble = true;
           },
           stopImmediatePropagation: function() {
               this.isImmediatePropagationStopped = returnTrue;
               this.stopPropagation();
           },
           isDefaultPrevented: returnFalse,
           isPropagationStopped: returnFalse,
           isImmediatePropagationStopped: returnFalse
       };

// Checks if an event happened on an element within another element
// Used in jQuery.event.special.mouseenter and mouseleave handlers
       var withinElement = function( event ) {
                   // Check if mouse(over|out) are still within the same parent element
                   var parent = event.relatedTarget;

                   // set the correct event type
                   event.type = event.data;

                   // Firefox sometimes assigns relatedTarget a XUL element
                   // which we cannot access the parentNode property of
                   try {

                       // Chrome does something similar, the parentNode property
                       // can be accessed but is null.
                       if ( parent && parent !== document && !parent.parentNode ) {
                           return;
                       }

                       // Traverse up the tree
                       while ( parent && parent !== this ) {
                           parent = parent.parentNode;
                       }

                       if ( parent !== this ) {
                           // handle event if we actually just moused on to a non sub-element
                           jQuery.event.handle.apply( this, arguments );
                       }

                       // assuming we've left the element since we most likely mousedover a xul element
                   } catch(e) { }
               },

// In case of event delegation, we only need to rename the event.type,
// liveHandler will take care of the rest.
               delegate = function( event ) {
                   event.type = event.data;
                   jQuery.event.handle.apply( this, arguments );
               };

// Create mouseenter and mouseleave events
       jQuery.each({
           mouseenter: "mouseover",
           mouseleave: "mouseout"
       }, function( orig, fix ) {
           jQuery.event.special[ orig ] = {
               setup: function( data ) {
                   jQuery.event.add( this, fix, data && data.selector ? delegate : withinElement, orig );
               },
               teardown: function( data ) {
                   jQuery.event.remove( this, fix, data && data.selector ? delegate : withinElement );
               }
           };
       });

// submit delegation
       if ( !jQuery.support.submitBubbles ) {

           jQuery.event.special.submit = {
               setup: function( data, namespaces ) {
                   if ( !jQuery.nodeName( this, "form" ) ) {
                       jQuery.event.add(this, "click.specialSubmit", function( e ) {
                           var elem = e.target,
                                   type = elem.type;

                           if ( (type === "submit" || type === "image") && jQuery( elem ).closest("form").length ) {
                               trigger( "submit", this, arguments );
                           }
                       });

                       jQuery.event.add(this, "keypress.specialSubmit", function( e ) {
                           var elem = e.target,
                                   type = elem.type;

                           if ( (type === "text" || type === "password") && jQuery( elem ).closest("form").length && e.keyCode === 13 ) {
                               trigger( "submit", this, arguments );
                           }
                       });

                   } else {
                       return false;
                   }
               },

               teardown: function( namespaces ) {
                   jQuery.event.remove( this, ".specialSubmit" );
               }
           };

       }

// change delegation, happens here so we have bind.
       if ( !jQuery.support.changeBubbles ) {

           var changeFilters,

                   getVal = function( elem ) {
                       var type = elem.type, val = elem.value;

                       if ( type === "radio" || type === "checkbox" ) {
                           val = elem.checked;

                       } else if ( type === "select-multiple" ) {
                           val = elem.selectedIndex > -1 ?
                                   jQuery.map( elem.options, function( elem ) {
                                       return elem.selected;
                                   }).join("-") :
                                   "";

                       } else if ( jQuery.nodeName( elem, "select" ) ) {
                           val = elem.selectedIndex;
                       }

                       return val;
                   },

                   testChange = function testChange( e ) {
                       var elem = e.target, data, val;

                       if ( !rformElems.test( elem.nodeName ) || elem.readOnly ) {
                           return;
                       }

                       data = jQuery._data( elem, "_change_data" );
                       val = getVal(elem);

                       // the current data will be also retrieved by beforeactivate
                       if ( e.type !== "focusout" || elem.type !== "radio" ) {
                           jQuery._data( elem, "_change_data", val );
                       }

                       if ( data === undefined || val === data ) {
                           return;
                       }

                       if ( data != null || val ) {
                           e.type = "change";
                           e.liveFired = undefined;
                           jQuery.event.trigger( e, arguments[1], elem );
                       }
                   };

           jQuery.event.special.change = {
               filters: {
                   focusout: testChange,

                   beforedeactivate: testChange,

                   click: function( e ) {
                       var elem = e.target, type = jQuery.nodeName( elem, "input" ) ? elem.type : "";

                       if ( type === "radio" || type === "checkbox" || jQuery.nodeName( elem, "select" ) ) {
                           testChange.call( this, e );
                       }
                   },

                   // Change has to be called before submit
                   // Keydown will be called before keypress, which is used in submit-event delegation
                   keydown: function( e ) {
                       var elem = e.target, type = jQuery.nodeName( elem, "input" ) ? elem.type : "";

                       if ( (e.keyCode === 13 && !jQuery.nodeName( elem, "textarea" ) ) ||
                               (e.keyCode === 32 && (type === "checkbox" || type === "radio")) ||
                               type === "select-multiple" ) {
                           testChange.call( this, e );
                       }
                   },

                   // Beforeactivate happens also before the previous element is blurred
                   // with this event you can't trigger a change event, but you can store
                   // information
                   beforeactivate: function( e ) {
                       var elem = e.target;
                       jQuery._data( elem, "_change_data", getVal(elem) );
                   }
               },

               setup: function( data, namespaces ) {
                   if ( this.type === "file" ) {
                       return false;
                   }

                   for ( var type in changeFilters ) {
                       jQuery.event.add( this, type + ".specialChange", changeFilters[type] );
                   }

                   return rformElems.test( this.nodeName );
               },

               teardown: function( namespaces ) {
                   jQuery.event.remove( this, ".specialChange" );

                   return rformElems.test( this.nodeName );
               }
           };

           changeFilters = jQuery.event.special.change.filters;

           // Handle when the input is .focus()'d
           changeFilters.focus = changeFilters.beforeactivate;
       }

       function trigger( type, elem, args ) {
           // Piggyback on a donor event to simulate a different one.
           // Fake originalEvent to avoid donor's stopPropagation, but if the
           // simulated event prevents default then we do the same on the donor.
           // Don't pass args or remember liveFired; they apply to the donor event.
           var event = jQuery.extend( {}, args[ 0 ] );
           event.type = type;
           event.originalEvent = {};
           event.liveFired = undefined;
           jQuery.event.handle.call( elem, event );
           if ( event.isDefaultPrevented() ) {
               args[ 0 ].preventDefault();
           }
       }

// Create "bubbling" focus and blur events
       if ( !jQuery.support.focusinBubbles ) {
           jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

               // Attach a single capturing handler while someone wants focusin/focusout
               var attaches = 0;

               jQuery.event.special[ fix ] = {
                   setup: function() {
                       if ( attaches++ === 0 ) {
                           document.addEventListener( orig, handler, true );
                       }
                   },
                   teardown: function() {
                       if ( --attaches === 0 ) {
                           document.removeEventListener( orig, handler, true );
                       }
                   }
               };

               function handler( donor ) {
                   // Donor event is always a native one; fix it and switch its type.
                   // Let focusin/out handler cancel the donor focus/blur event.
                   var e = jQuery.event.fix( donor );
                   e.type = fix;
                   e.originalEvent = {};
                   jQuery.event.trigger( e, null, e.target );
                   if ( e.isDefaultPrevented() ) {
                       donor.preventDefault();
                   }
               }
           });
       }

       jQuery.each(["bind", "one"], function( i, name ) {
           jQuery.fn[ name ] = function( type, data, fn ) {
               var handler;

               // Handle object literals
               if ( typeof type === "object" ) {
                   for ( var key in type ) {
                       this[ name ](key, data, type[key], fn);
                   }
                   return this;
               }

               if ( arguments.length === 2 || data === false ) {
                   fn = data;
                   data = undefined;
               }

               if ( name === "one" ) {
                   handler = function( event ) {
                       jQuery( this ).unbind( event, handler );
                       return fn.apply( this, arguments );
                   };
                   handler.guid = fn.guid || jQuery.guid++;
               } else {
                   handler = fn;
               }

               if ( type === "unload" && name !== "one" ) {
                   this.one( type, data, fn );

               } else {
                   for ( var i = 0, l = this.length; i < l; i++ ) {
                       jQuery.event.add( this[i], type, handler, data );
                   }
               }

               return this;
           };
       });

       jQuery.fn.extend({
           unbind: function( type, fn ) {
               // Handle object literals
               if ( typeof type === "object" && !type.preventDefault ) {
                   for ( var key in type ) {
                       this.unbind(key, type[key]);
                   }

               } else {
                   for ( var i = 0, l = this.length; i < l; i++ ) {
                       jQuery.event.remove( this[i], type, fn );
                   }
               }

               return this;
           },

           delegate: function( selector, types, data, fn ) {
               return this.live( types, data, fn, selector );
           },

           undelegate: function( selector, types, fn ) {
               if ( arguments.length === 0 ) {
                   return this.unbind( "live" );

               } else {
                   return this.die( types, null, fn, selector );
               }
           },

           trigger: function( type, data ) {
               return this.each(function() {
                   jQuery.event.trigger( type, data, this );
               });
           },

           triggerHandler: function( type, data ) {
               if ( this[0] ) {
                   return jQuery.event.trigger( type, data, this[0], true );
               }
           },

           toggle: function( fn ) {
               // Save reference to arguments for access in closure
               var args = arguments,
                       guid = fn.guid || jQuery.guid++,
                       i = 0,
                       toggler = function( event ) {
                           // Figure out which function to execute
                           var lastToggle = ( jQuery.data( this, "lastToggle" + fn.guid ) || 0 ) % i;
                           jQuery.data( this, "lastToggle" + fn.guid, lastToggle + 1 );

                           // Make sure that clicks stop
                           event.preventDefault();

                           // and execute the function
                           return args[ lastToggle ].apply( this, arguments ) || false;
                       };

               // link all the functions, so any of them can unbind this click handler
               toggler.guid = guid;
               while ( i < args.length ) {
                   args[ i++ ].guid = guid;
               }

               return this.click( toggler );
           },

           hover: function( fnOver, fnOut ) {
               return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
           }
       });

       var liveMap = {
           focus: "focusin",
           blur: "focusout",
           mouseenter: "mouseover",
           mouseleave: "mouseout"
       };

       jQuery.each(["live", "die"], function( i, name ) {
           jQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) {
               var type, i = 0, match, namespaces, preType,
                       selector = origSelector || this.selector,
                       context = origSelector ? this : jQuery( this.context );

               if ( typeof types === "object" && !types.preventDefault ) {
                   for ( var key in types ) {
                       context[ name ]( key, data, types[key], selector );
                   }

                   return this;
               }

               if ( name === "die" && !types &&
                       origSelector && origSelector.charAt(0) === "." ) {

                   context.unbind( origSelector );

                   return this;
               }

               if ( data === false || jQuery.isFunction( data ) ) {
                   fn = data || returnFalse;
                   data = undefined;
               }

               types = (types || "").split(" ");

               while ( (type = types[ i++ ]) != null ) {
                   match = rnamespaces.exec( type );
                   namespaces = "";

                   if ( match )  {
                       namespaces = match[0];
                       type = type.replace( rnamespaces, "" );
                   }

                   if ( type === "hover" ) {
                       types.push( "mouseenter" + namespaces, "mouseleave" + namespaces );
                       continue;
                   }

                   preType = type;

                   if ( liveMap[ type ] ) {
                       types.push( liveMap[ type ] + namespaces );
                       type = type + namespaces;

                   } else {
                       type = (liveMap[ type ] || type) + namespaces;
                   }

                   if ( name === "live" ) {
                       // bind live handler
                       for ( var j = 0, l = context.length; j < l; j++ ) {
                           jQuery.event.add( context[j], "live." + liveConvert( type, selector ),
                                   { data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType } );
                       }

                   } else {
                       // unbind live handler
                       context.unbind( "live." + liveConvert( type, selector ), fn );
                   }
               }

               return this;
           };
       });

       function liveHandler( event ) {
           var stop, maxLevel, related, match, handleObj, elem, j, i, l, data, close, namespace, ret,
                   elems = [],
                   selectors = [],
                   events = jQuery._data( this, "events" );

           // Make sure we avoid non-left-click bubbling in Firefox (#3861) and disabled elements in IE (#6911)
           if ( event.liveFired === this || !events || !events.live || event.target.disabled || event.button && event.type === "click" ) {
               return;
           }

           if ( event.namespace ) {
               namespace = new RegExp("(^|\\.)" + event.namespace.split(".").join("\\.(?:.*\\.)?") + "(\\.|$)");
           }

           event.liveFired = this;

           var live = events.live.slice(0);

           for ( j = 0; j < live.length; j++ ) {
               handleObj = live[j];

               if ( handleObj.origType.replace( rnamespaces, "" ) === event.type ) {
                   selectors.push( handleObj.selector );

               } else {
                   live.splice( j--, 1 );
               }
           }

           match = jQuery( event.target ).closest( selectors, event.currentTarget );

           for ( i = 0, l = match.length; i < l; i++ ) {
               close = match[i];

               for ( j = 0; j < live.length; j++ ) {
                   handleObj = live[j];

                   if ( close.selector === handleObj.selector && (!namespace || namespace.test( handleObj.namespace )) && !close.elem.disabled ) {
                       elem = close.elem;
                       related = null;

                       // Those two events require additional checking
                       if ( handleObj.preType === "mouseenter" || handleObj.preType === "mouseleave" ) {
                           event.type = handleObj.preType;
                           related = jQuery( event.relatedTarget ).closest( handleObj.selector )[0];

                           // Make sure not to accidentally match a child element with the same selector
                           if ( related && jQuery.contains( elem, related ) ) {
                               related = elem;
                           }
                       }

                       if ( !related || related !== elem ) {
                           elems.push({ elem: elem, handleObj: handleObj, level: close.level });
                       }
                   }
               }
           }

           for ( i = 0, l = elems.length; i < l; i++ ) {
               match = elems[i];

               if ( maxLevel && match.level > maxLevel ) {
                   break;
               }

               event.currentTarget = match.elem;
               event.data = match.handleObj.data;
               event.handleObj = match.handleObj;

               ret = match.handleObj.origHandler.apply( match.elem, arguments );

               if ( ret === false || event.isPropagationStopped() ) {
                   maxLevel = match.level;

                   if ( ret === false ) {
                       stop = false;
                   }
                   if ( event.isImmediatePropagationStopped() ) {
                       break;
                   }
               }
           }

           return stop;
       }

       function liveConvert( type, selector ) {
           return (type && type !== "*" ? type + "." : "") + selector.replace(rperiod, "`").replace(rspaces, "&");
       }

       jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
               "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
               "change select submit keydown keypress keyup error").split(" "), function( i, name ) {

           // Handle event binding
           jQuery.fn[ name ] = function( data, fn ) {
               if ( fn == null ) {
                   fn = data;
                   data = null;
               }

               return arguments.length > 0 ?
                       this.bind( name, data, fn ) :
                       this.trigger( name );
           };

           if ( jQuery.attrFn ) {
               jQuery.attrFn[ name ] = true;
           }
       });



       /*!
        * Sizzle CSS Selector Engine
        *  Copyright 2011, The Dojo Foundation
        *  Released under the MIT, BSD, and GPL Licenses.
        *  More information: http://sizzlejs.com/
        */
       (function(){

           var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
                   done = 0,
                   toString = Object.prototype.toString,
                   hasDuplicate = false,
                   baseHasDuplicate = true,
                   rBackslash = /\\/g,
                   rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
           [0, 0].sort(function() {
               baseHasDuplicate = false;
               return 0;
           });

           var Sizzle = function( selector, context, results, seed ) {
               results = results || [];
               context = context || document;

               var origContext = context;

               if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
                   return [];
               }

               if ( !selector || typeof selector !== "string" ) {
                   return results;
               }

               var m, set, checkSet, extra, ret, cur, pop, i,
                       prune = true,
                       contextXML = Sizzle.isXML( context ),
                       parts = [],
                       soFar = selector;

               // Reset the position of the chunker regexp (start from head)
               do {
                   chunker.exec( "" );
                   m = chunker.exec( soFar );

                   if ( m ) {
                       soFar = m[3];

                       parts.push( m[1] );

                       if ( m[2] ) {
                           extra = m[3];
                           break;
                       }
                   }
               } while ( m );

               if ( parts.length > 1 && origPOS.exec( selector ) ) {

                   if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
                       set = posProcess( parts[0] + parts[1], context );

                   } else {
                       set = Expr.relative[ parts[0] ] ?
                               [ context ] :
                               Sizzle( parts.shift(), context );

                       while ( parts.length ) {
                           selector = parts.shift();

                           if ( Expr.relative[ selector ] ) {
                               selector += parts.shift();
                           }

                           set = posProcess( selector, set );
                       }
                   }

               } else {
                   // Take a shortcut and set the context if the root selector is an ID
                   // (but not if it'll be faster if the inner selector is an ID)
                   if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
                           Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

                       ret = Sizzle.find( parts.shift(), context, contextXML );
                       context = ret.expr ?
                               Sizzle.filter( ret.expr, ret.set )[0] :
                               ret.set[0];
                   }

                   if ( context ) {
                       ret = seed ?
                       { expr: parts.pop(), set: makeArray(seed) } :
                               Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

                       set = ret.expr ?
                               Sizzle.filter( ret.expr, ret.set ) :
                               ret.set;

                       if ( parts.length > 0 ) {
                           checkSet = makeArray( set );

                       } else {
                           prune = false;
                       }

                       while ( parts.length ) {
                           cur = parts.pop();
                           pop = cur;

                           if ( !Expr.relative[ cur ] ) {
                               cur = "";
                           } else {
                               pop = parts.pop();
                           }

                           if ( pop == null ) {
                               pop = context;
                           }

                           Expr.relative[ cur ]( checkSet, pop, contextXML );
                       }

                   } else {
                       checkSet = parts = [];
                   }
               }

               if ( !checkSet ) {
                   checkSet = set;
               }

               if ( !checkSet ) {
                   Sizzle.error( cur || selector );
               }

               if ( toString.call(checkSet) === "[object Array]" ) {
                   if ( !prune ) {
                       results.push.apply( results, checkSet );

                   } else if ( context && context.nodeType === 1 ) {
                       for ( i = 0; checkSet[i] != null; i++ ) {
                           if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
                               results.push( set[i] );
                           }
                       }

                   } else {
                       for ( i = 0; checkSet[i] != null; i++ ) {
                           if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
                               results.push( set[i] );
                           }
                       }
                   }

               } else {
                   makeArray( checkSet, results );
               }

               if ( extra ) {
                   Sizzle( extra, origContext, results, seed );
                   Sizzle.uniqueSort( results );
               }

               return results;
           };

           Sizzle.uniqueSort = function( results ) {
               if ( sortOrder ) {
                   hasDuplicate = baseHasDuplicate;
                   results.sort( sortOrder );

                   if ( hasDuplicate ) {
                       for ( var i = 1; i < results.length; i++ ) {
                           if ( results[i] === results[ i - 1 ] ) {
                               results.splice( i--, 1 );
                           }
                       }
                   }
               }

               return results;
           };

           Sizzle.matches = function( expr, set ) {
               return Sizzle( expr, null, null, set );
           };

           Sizzle.matchesSelector = function( node, expr ) {
               return Sizzle( expr, null, null, [node] ).length > 0;
           };

           Sizzle.find = function( expr, context, isXML ) {
               var set;

               if ( !expr ) {
                   return [];
               }

               for ( var i = 0, l = Expr.order.length; i < l; i++ ) {
                   var match,
                           type = Expr.order[i];

                   if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
                       var left = match[1];
                       match.splice( 1, 1 );

                       if ( left.substr( left.length - 1 ) !== "\\" ) {
                           match[1] = (match[1] || "").replace( rBackslash, "" );
                           set = Expr.find[ type ]( match, context, isXML );

                           if ( set != null ) {
                               expr = expr.replace( Expr.match[ type ], "" );
                               break;
                           }
                       }
                   }
               }

               if ( !set ) {
                   set = typeof context.getElementsByTagName !== "undefined" ?
                           context.getElementsByTagName( "*" ) :
                           [];
               }

               return { set: set, expr: expr };
           };

           Sizzle.filter = function( expr, set, inplace, not ) {
               var match, anyFound,
                       old = expr,
                       result = [],
                       curLoop = set,
                       isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

               while ( expr && set.length ) {
                   for ( var type in Expr.filter ) {
                       if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
                           var found, item,
                                   filter = Expr.filter[ type ],
                                   left = match[1];

                           anyFound = false;

                           match.splice(1,1);

                           if ( left.substr( left.length - 1 ) === "\\" ) {
                               continue;
                           }

                           if ( curLoop === result ) {
                               result = [];
                           }

                           if ( Expr.preFilter[ type ] ) {
                               match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

                               if ( !match ) {
                                   anyFound = found = true;

                               } else if ( match === true ) {
                                   continue;
                               }
                           }

                           if ( match ) {
                               for ( var i = 0; (item = curLoop[i]) != null; i++ ) {
                                   if ( item ) {
                                       found = filter( item, match, i, curLoop );
                                       var pass = not ^ !!found;

                                       if ( inplace && found != null ) {
                                           if ( pass ) {
                                               anyFound = true;

                                           } else {
                                               curLoop[i] = false;
                                           }

                                       } else if ( pass ) {
                                           result.push( item );
                                           anyFound = true;
                                       }
                                   }
                               }
                           }

                           if ( found !== undefined ) {
                               if ( !inplace ) {
                                   curLoop = result;
                               }

                               expr = expr.replace( Expr.match[ type ], "" );

                               if ( !anyFound ) {
                                   return [];
                               }

                               break;
                           }
                       }
                   }

                   // Improper expression
                   if ( expr === old ) {
                       if ( anyFound == null ) {
                           Sizzle.error( expr );

                       } else {
                           break;
                       }
                   }

                   old = expr;
               }

               return curLoop;
           };

           Sizzle.error = function( msg ) {
               throw "Syntax error, unrecognized expression: " + msg;
           };

           var Expr = Sizzle.selectors = {
               order: [ "ID", "NAME", "TAG" ],

               match: {
                   ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                   CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                   NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
                   ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
                   TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
                   CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
                   POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
                   PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
               },

               leftMatch: {},

               attrMap: {
                   "class": "className",
                   "for": "htmlFor"
               },

               attrHandle: {
                   href: function( elem ) {
                       return elem.getAttribute( "href" );
                   },
                   type: function( elem ) {
                       return elem.getAttribute( "type" );
                   }
               },

               relative: {
                   "+": function(checkSet, part){
                       var isPartStr = typeof part === "string",
                               isTag = isPartStr && !rNonWord.test( part ),
                               isPartStrNotTag = isPartStr && !isTag;

                       if ( isTag ) {
                           part = part.toLowerCase();
                       }

                       for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
                           if ( (elem = checkSet[i]) ) {
                               while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

                               checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
                                       elem || false :
                                       elem === part;
                           }
                       }

                       if ( isPartStrNotTag ) {
                           Sizzle.filter( part, checkSet, true );
                       }
                   },

                   ">": function( checkSet, part ) {
                       var elem,
                               isPartStr = typeof part === "string",
                               i = 0,
                               l = checkSet.length;

                       if ( isPartStr && !rNonWord.test( part ) ) {
                           part = part.toLowerCase();

                           for ( ; i < l; i++ ) {
                               elem = checkSet[i];

                               if ( elem ) {
                                   var parent = elem.parentNode;
                                   checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
                               }
                           }

                       } else {
                           for ( ; i < l; i++ ) {
                               elem = checkSet[i];

                               if ( elem ) {
                                   checkSet[i] = isPartStr ?
                                           elem.parentNode :
                                           elem.parentNode === part;
                               }
                           }

                           if ( isPartStr ) {
                               Sizzle.filter( part, checkSet, true );
                           }
                       }
                   },

                   "": function(checkSet, part, isXML){
                       var nodeCheck,
                               doneName = done++,
                               checkFn = dirCheck;

                       if ( typeof part === "string" && !rNonWord.test( part ) ) {
                           part = part.toLowerCase();
                           nodeCheck = part;
                           checkFn = dirNodeCheck;
                       }

                       checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
                   },

                   "~": function( checkSet, part, isXML ) {
                       var nodeCheck,
                               doneName = done++,
                               checkFn = dirCheck;

                       if ( typeof part === "string" && !rNonWord.test( part ) ) {
                           part = part.toLowerCase();
                           nodeCheck = part;
                           checkFn = dirNodeCheck;
                       }

                       checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
                   }
               },

               find: {
                   ID: function( match, context, isXML ) {
                       if ( typeof context.getElementById !== "undefined" && !isXML ) {
                           var m = context.getElementById(match[1]);
                           // Check parentNode to catch when Blackberry 4.6 returns
                           // nodes that are no longer in the document #6963
                           return m && m.parentNode ? [m] : [];
                       }
                   },

                   NAME: function( match, context ) {
                       if ( typeof context.getElementsByName !== "undefined" ) {
                           var ret = [],
                                   results = context.getElementsByName( match[1] );

                           for ( var i = 0, l = results.length; i < l; i++ ) {
                               if ( results[i].getAttribute("name") === match[1] ) {
                                   ret.push( results[i] );
                               }
                           }

                           return ret.length === 0 ? null : ret;
                       }
                   },

                   TAG: function( match, context ) {
                       if ( typeof context.getElementsByTagName !== "undefined" ) {
                           return context.getElementsByTagName( match[1] );
                       }
                   }
               },
               preFilter: {
                   CLASS: function( match, curLoop, inplace, result, not, isXML ) {
                       match = " " + match[1].replace( rBackslash, "" ) + " ";

                       if ( isXML ) {
                           return match;
                       }

                       for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
                           if ( elem ) {
                               if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
                                   if ( !inplace ) {
                                       result.push( elem );
                                   }

                               } else if ( inplace ) {
                                   curLoop[i] = false;
                               }
                           }
                       }

                       return false;
                   },

                   ID: function( match ) {
                       return match[1].replace( rBackslash, "" );
                   },

                   TAG: function( match, curLoop ) {
                       return match[1].replace( rBackslash, "" ).toLowerCase();
                   },

                   CHILD: function( match ) {
                       if ( match[1] === "nth" ) {
                           if ( !match[2] ) {
                               Sizzle.error( match[0] );
                           }

                           match[2] = match[2].replace(/^\+|\s*/g, '');

                           // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
                           var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
                                   match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
                                           !/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

                           // calculate the numbers (first)n+(last) including if they are negative
                           match[2] = (test[1] + (test[2] || 1)) - 0;
                           match[3] = test[3] - 0;
                       }
                       else if ( match[2] ) {
                           Sizzle.error( match[0] );
                       }

                       // TODO: Move to normal caching system
                       match[0] = done++;

                       return match;
                   },

                   ATTR: function( match, curLoop, inplace, result, not, isXML ) {
                       var name = match[1] = match[1].replace( rBackslash, "" );

                       if ( !isXML && Expr.attrMap[name] ) {
                           match[1] = Expr.attrMap[name];
                       }

                       // Handle if an un-quoted value was used
                       match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

                       if ( match[2] === "~=" ) {
                           match[4] = " " + match[4] + " ";
                       }

                       return match;
                   },

                   PSEUDO: function( match, curLoop, inplace, result, not ) {
                       if ( match[1] === "not" ) {
                           // If we're dealing with a complex expression, or a simple one
                           if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
                               match[3] = Sizzle(match[3], null, null, curLoop);

                           } else {
                               var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

                               if ( !inplace ) {
                                   result.push.apply( result, ret );
                               }

                               return false;
                           }

                       } else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
                           return true;
                       }

                       return match;
                   },

                   POS: function( match ) {
                       match.unshift( true );

                       return match;
                   }
               },

               filters: {
                   enabled: function( elem ) {
                       return elem.disabled === false && elem.type !== "hidden";
                   },

                   disabled: function( elem ) {
                       return elem.disabled === true;
                   },

                   checked: function( elem ) {
                       return elem.checked === true;
                   },

                   selected: function( elem ) {
                       // Accessing this property makes selected-by-default
                       // options in Safari work properly
                       if ( elem.parentNode ) {
                           elem.parentNode.selectedIndex;
                       }

                       return elem.selected === true;
                   },

                   parent: function( elem ) {
                       return !!elem.firstChild;
                   },

                   empty: function( elem ) {
                       return !elem.firstChild;
                   },

                   has: function( elem, i, match ) {
                       return !!Sizzle( match[3], elem ).length;
                   },

                   header: function( elem ) {
                       return (/h\d/i).test( elem.nodeName );
                   },

                   text: function( elem ) {
                       var attr = elem.getAttribute( "type" ), type = elem.type;
                       // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
                       // use getAttribute instead to test this case
                       return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
                   },

                   radio: function( elem ) {
                       return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
                   },

                   checkbox: function( elem ) {
                       return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
                   },

                   file: function( elem ) {
                       return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
                   },

                   password: function( elem ) {
                       return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
                   },

                   submit: function( elem ) {
                       var name = elem.nodeName.toLowerCase();
                       return (name === "input" || name === "button") && "submit" === elem.type;
                   },

                   image: function( elem ) {
                       return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
                   },

                   reset: function( elem ) {
                       var name = elem.nodeName.toLowerCase();
                       return (name === "input" || name === "button") && "reset" === elem.type;
                   },

                   button: function( elem ) {
                       var name = elem.nodeName.toLowerCase();
                       return name === "input" && "button" === elem.type || name === "button";
                   },

                   input: function( elem ) {
                       return (/input|select|textarea|button/i).test( elem.nodeName );
                   },

                   focus: function( elem ) {
                       return elem === elem.ownerDocument.activeElement;
                   }
               },
               setFilters: {
                   first: function( elem, i ) {
                       return i === 0;
                   },

                   last: function( elem, i, match, array ) {
                       return i === array.length - 1;
                   },

                   even: function( elem, i ) {
                       return i % 2 === 0;
                   },

                   odd: function( elem, i ) {
                       return i % 2 === 1;
                   },

                   lt: function( elem, i, match ) {
                       return i < match[3] - 0;
                   },

                   gt: function( elem, i, match ) {
                       return i > match[3] - 0;
                   },

                   nth: function( elem, i, match ) {
                       return match[3] - 0 === i;
                   },

                   eq: function( elem, i, match ) {
                       return match[3] - 0 === i;
                   }
               },
               filter: {
                   PSEUDO: function( elem, match, i, array ) {
                       var name = match[1],
                               filter = Expr.filters[ name ];

                       if ( filter ) {
                           return filter( elem, i, match, array );

                       } else if ( name === "contains" ) {
                           return (elem.textContent || elem.innerText || Sizzle.getText([ elem ]) || "").indexOf(match[3]) >= 0;

                       } else if ( name === "not" ) {
                           var not = match[3];

                           for ( var j = 0, l = not.length; j < l; j++ ) {
                               if ( not[j] === elem ) {
                                   return false;
                               }
                           }

                           return true;

                       } else {
                           Sizzle.error( name );
                       }
                   },

                   CHILD: function( elem, match ) {
                       var type = match[1],
                               node = elem;

                       switch ( type ) {
                           case "only":
                           case "first":
                               while ( (node = node.previousSibling) )	 {
                                   if ( node.nodeType === 1 ) {
                                       return false;
                                   }
                               }

                               if ( type === "first" ) {
                                   return true;
                               }

                               node = elem;

                           case "last":
                               while ( (node = node.nextSibling) )	 {
                                   if ( node.nodeType === 1 ) {
                                       return false;
                                   }
                               }

                               return true;

                           case "nth":
                               var first = match[2],
                                       last = match[3];

                               if ( first === 1 && last === 0 ) {
                                   return true;
                               }

                               var doneName = match[0],
                                       parent = elem.parentNode;

                               if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) {
                                   var count = 0;

                                   for ( node = parent.firstChild; node; node = node.nextSibling ) {
                                       if ( node.nodeType === 1 ) {
                                           node.nodeIndex = ++count;
                                       }
                                   }

                                   parent.sizcache = doneName;
                               }

                               var diff = elem.nodeIndex - last;

                               if ( first === 0 ) {
                                   return diff === 0;

                               } else {
                                   return ( diff % first === 0 && diff / first >= 0 );
                               }
                       }
                   },

                   ID: function( elem, match ) {
                       return elem.nodeType === 1 && elem.getAttribute("id") === match;
                   },

                   TAG: function( elem, match ) {
                       return (match === "*" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
                   },

                   CLASS: function( elem, match ) {
                       return (" " + (elem.className || elem.getAttribute("class")) + " ")
                               .indexOf( match ) > -1;
                   },

                   ATTR: function( elem, match ) {
                       var name = match[1],
                               result = Expr.attrHandle[ name ] ?
                                       Expr.attrHandle[ name ]( elem ) :
                                       elem[ name ] != null ?
                                               elem[ name ] :
                                               elem.getAttribute( name ),
                               value = result + "",
                               type = match[2],
                               check = match[4];

                       return result == null ?
                               type === "!=" :
                               type === "=" ?
                                       value === check :
                                       type === "*=" ?
                                               value.indexOf(check) >= 0 :
                                               type === "~=" ?
                                                       (" " + value + " ").indexOf(check) >= 0 :
                                                       !check ?
                                                               value && result !== false :
                                                               type === "!=" ?
                                                                       value !== check :
                                                                       type === "^=" ?
                                                                               value.indexOf(check) === 0 :
                                                                               type === "$=" ?
                                                                                       value.substr(value.length - check.length) === check :
                                                                                       type === "|=" ?
                                                                                               value === check || value.substr(0, check.length + 1) === check + "-" :
                                                                                               false;
                   },

                   POS: function( elem, match, i, array ) {
                       var name = match[2],
                               filter = Expr.setFilters[ name ];

                       if ( filter ) {
                           return filter( elem, i, match, array );
                       }
                   }
               }
           };

           var origPOS = Expr.match.POS,
                   fescape = function(all, num){
                       return "\\" + (num - 0 + 1);
                   };

           for ( var type in Expr.match ) {
               Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
               Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
           }

           var makeArray = function( array, results ) {
               array = Array.prototype.slice.call( array, 0 );

               if ( results ) {
                   results.push.apply( results, array );
                   return results;
               }

               return array;
           };

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
           try {
               Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
           } catch( e ) {
               makeArray = function( array, results ) {
                   var i = 0,
                           ret = results || [];

                   if ( toString.call(array) === "[object Array]" ) {
                       Array.prototype.push.apply( ret, array );

                   } else {
                       if ( typeof array.length === "number" ) {
                           for ( var l = array.length; i < l; i++ ) {
                               ret.push( array[i] );
                           }

                       } else {
                           for ( ; array[i]; i++ ) {
                               ret.push( array[i] );
                           }
                       }
                   }

                   return ret;
               };
           }

           var sortOrder, siblingCheck;

           if ( document.documentElement.compareDocumentPosition ) {
               sortOrder = function( a, b ) {
                   if ( a === b ) {
                       hasDuplicate = true;
                       return 0;
                   }

                   if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
                       return a.compareDocumentPosition ? -1 : 1;
                   }

                   return a.compareDocumentPosition(b) & 4 ? -1 : 1;
               };

           } else {
               sortOrder = function( a, b ) {
                   // The nodes are identical, we can exit early
                   if ( a === b ) {
                       hasDuplicate = true;
                       return 0;

                       // Fallback to using sourceIndex (in IE) if it's available on both nodes
                   } else if ( a.sourceIndex && b.sourceIndex ) {
                       return a.sourceIndex - b.sourceIndex;
                   }

                   var al, bl,
                           ap = [],
                           bp = [],
                           aup = a.parentNode,
                           bup = b.parentNode,
                           cur = aup;

                   // If the nodes are siblings (or identical) we can do a quick check
                   if ( aup === bup ) {
                       return siblingCheck( a, b );

                       // If no parents were found then the nodes are disconnected
                   } else if ( !aup ) {
                       return -1;

                   } else if ( !bup ) {
                       return 1;
                   }

                   // Otherwise they're somewhere else in the tree so we need
                   // to build up a full list of the parentNodes for comparison
                   while ( cur ) {
                       ap.unshift( cur );
                       cur = cur.parentNode;
                   }

                   cur = bup;

                   while ( cur ) {
                       bp.unshift( cur );
                       cur = cur.parentNode;
                   }

                   al = ap.length;
                   bl = bp.length;

                   // Start walking down the tree looking for a discrepancy
                   for ( var i = 0; i < al && i < bl; i++ ) {
                       if ( ap[i] !== bp[i] ) {
                           return siblingCheck( ap[i], bp[i] );
                       }
                   }

                   // We ended someplace up the tree so do a sibling check
                   return i === al ?
                           siblingCheck( a, bp[i], -1 ) :
                           siblingCheck( ap[i], b, 1 );
               };

               siblingCheck = function( a, b, ret ) {
                   if ( a === b ) {
                       return ret;
                   }

                   var cur = a.nextSibling;

                   while ( cur ) {
                       if ( cur === b ) {
                           return -1;
                       }

                       cur = cur.nextSibling;
                   }

                   return 1;
               };
           }

// Utility function for retreiving the text value of an array of DOM nodes
           Sizzle.getText = function( elems ) {
               var ret = "", elem;

               for ( var i = 0; elems[i]; i++ ) {
                   elem = elems[i];

                   // Get the text from text nodes and CDATA nodes
                   if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
                       ret += elem.nodeValue;

                       // Traverse everything else, except comment nodes
                   } else if ( elem.nodeType !== 8 ) {
                       ret += Sizzle.getText( elem.childNodes );
                   }
               }

               return ret;
           };

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
           (function(){
               // We're going to inject a fake input element with a specified name
               var form = document.createElement("div"),
                       id = "script" + (new Date()).getTime(),
                       root = document.documentElement;

               form.innerHTML = "<a name='" + id + "'/>";

               // Inject it into the root element, check its status, and remove it quickly
               root.insertBefore( form, root.firstChild );

               // The workaround has to do additional checks after a getElementById
               // Which slows things down for other browsers (hence the branching)
               if ( document.getElementById( id ) ) {
                   Expr.find.ID = function( match, context, isXML ) {
                       if ( typeof context.getElementById !== "undefined" && !isXML ) {
                           var m = context.getElementById(match[1]);

                           return m ?
                                   m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
                                           [m] :
                                           undefined :
                                   [];
                       }
                   };

                   Expr.filter.ID = function( elem, match ) {
                       var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

                       return elem.nodeType === 1 && node && node.nodeValue === match;
                   };
               }

               root.removeChild( form );

               // release memory in IE
               root = form = null;
           })();

           (function(){
               // Check to see if the browser returns only elements
               // when doing getElementsByTagName("*")

               // Create a fake element
               var div = document.createElement("div");
               div.appendChild( document.createComment("") );

               // Make sure no comments are found
               if ( div.getElementsByTagName("*").length > 0 ) {
                   Expr.find.TAG = function( match, context ) {
                       var results = context.getElementsByTagName( match[1] );

                       // Filter out possible comments
                       if ( match[1] === "*" ) {
                           var tmp = [];

                           for ( var i = 0; results[i]; i++ ) {
                               if ( results[i].nodeType === 1 ) {
                                   tmp.push( results[i] );
                               }
                           }

                           results = tmp;
                       }

                       return results;
                   };
               }

               // Check to see if an attribute returns normalized href attributes
               div.innerHTML = "<a href='#'></a>";

               if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
                       div.firstChild.getAttribute("href") !== "#" ) {

                   Expr.attrHandle.href = function( elem ) {
                       return elem.getAttribute( "href", 2 );
                   };
               }

               // release memory in IE
               div = null;
           })();

           if ( document.querySelectorAll ) {
               (function(){
                   var oldSizzle = Sizzle,
                           div = document.createElement("div"),
                           id = "__sizzle__";

                   div.innerHTML = "<p class='TEST'></p>";

                   // Safari can't handle uppercase or unicode characters when
                   // in quirks mode.
                   if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
                       return;
                   }

                   Sizzle = function( query, context, extra, seed ) {
                       context = context || document;

                       // Only use querySelectorAll on non-XML documents
                       // (ID selectors don't work in non-HTML documents)
                       if ( !seed && !Sizzle.isXML(context) ) {
                           // See if we find a selector to speed up
                           var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );

                           if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
                               // Speed-up: Sizzle("TAG")
                               if ( match[1] ) {
                                   return makeArray( context.getElementsByTagName( query ), extra );

                                   // Speed-up: Sizzle(".CLASS")
                               } else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
                                   return makeArray( context.getElementsByClassName( match[2] ), extra );
                               }
                           }

                           if ( context.nodeType === 9 ) {
                               // Speed-up: Sizzle("body")
                               // The body element only exists once, optimize finding it
                               if ( query === "body" && context.body ) {
                                   return makeArray( [ context.body ], extra );

                                   // Speed-up: Sizzle("#ID")
                               } else if ( match && match[3] ) {
                                   var elem = context.getElementById( match[3] );

                                   // Check parentNode to catch when Blackberry 4.6 returns
                                   // nodes that are no longer in the document #6963
                                   if ( elem && elem.parentNode ) {
                                       // Handle the case where IE and Opera return items
                                       // by name instead of ID
                                       if ( elem.id === match[3] ) {
                                           return makeArray( [ elem ], extra );
                                       }

                                   } else {
                                       return makeArray( [], extra );
                                   }
                               }

                               try {
                                   return makeArray( context.querySelectorAll(query), extra );
                               } catch(qsaError) {}

                               // qSA works strangely on Element-rooted queries
                               // We can work around this by specifying an extra ID on the root
                               // and working up from there (Thanks to Andrew Dupont for the technique)
                               // IE 8 doesn't work on object elements
                           } else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
                               var oldContext = context,
                                       old = context.getAttribute( "id" ),
                                       nid = old || id,
                                       hasParent = context.parentNode,
                                       relativeHierarchySelector = /^\s*[+~]/.test( query );

                               if ( !old ) {
                                   context.setAttribute( "id", nid );
                               } else {
                                   nid = nid.replace( /'/g, "\\$&" );
                               }
                               if ( relativeHierarchySelector && hasParent ) {
                                   context = context.parentNode;
                               }

                               try {
                                   if ( !relativeHierarchySelector || hasParent ) {
                                       return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
                                   }

                               } catch(pseudoError) {
                               } finally {
                                   if ( !old ) {
                                       oldContext.removeAttribute( "id" );
                                   }
                               }
                           }
                       }

                       return oldSizzle(query, context, extra, seed);
                   };

                   for ( var prop in oldSizzle ) {
                       Sizzle[ prop ] = oldSizzle[ prop ];
                   }

                   // release memory in IE
                   div = null;
               })();
           }

           (function(){
               var html = document.documentElement,
                       matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

               if ( matches ) {
                   // Check to see if it's possible to do matchesSelector
                   // on a disconnected node (IE 9 fails this)
                   var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
                           pseudoWorks = false;

                   try {
                       // This should fail with an exception
                       // Gecko does not error, returns false instead
                       matches.call( document.documentElement, "[test!='']:sizzle" );

                   } catch( pseudoError ) {
                       pseudoWorks = true;
                   }

                   Sizzle.matchesSelector = function( node, expr ) {
                       // Make sure that attribute selectors are quoted
                       expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

                       if ( !Sizzle.isXML( node ) ) {
                           try {
                               if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
                                   var ret = matches.call( node, expr );

                                   // IE 9's matchesSelector returns false on disconnected nodes
                                   if ( ret || !disconnectedMatch ||
                                       // As well, disconnected nodes are said to be in a document
                                       // fragment in IE 9, so check for that
                                           node.document && node.document.nodeType !== 11 ) {
                                       return ret;
                                   }
                               }
                           } catch(e) {}
                       }

                       return Sizzle(expr, null, null, [node]).length > 0;
                   };
               }
           })();

           (function(){
               var div = document.createElement("div");

               div.innerHTML = "<div class='test e'></div><div class='test'></div>";

               // Opera can't find a second classname (in 9.6)
               // Also, make sure that getElementsByClassName actually exists
               if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
                   return;
               }

               // Safari caches class attributes, doesn't catch changes (in 3.2)
               div.lastChild.className = "e";

               if ( div.getElementsByClassName("e").length === 1 ) {
                   return;
               }

               Expr.order.splice(1, 0, "CLASS");
               Expr.find.CLASS = function( match, context, isXML ) {
                   if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
                       return context.getElementsByClassName(match[1]);
                   }
               };

               // release memory in IE
               div = null;
           })();

           function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
               for ( var i = 0, l = checkSet.length; i < l; i++ ) {
                   var elem = checkSet[i];

                   if ( elem ) {
                       var match = false;

                       elem = elem[dir];

                       while ( elem ) {
                           if ( elem.sizcache === doneName ) {
                               match = checkSet[elem.sizset];
                               break;
                           }

                           if ( elem.nodeType === 1 && !isXML ){
                               elem.sizcache = doneName;
                               elem.sizset = i;
                           }

                           if ( elem.nodeName.toLowerCase() === cur ) {
                               match = elem;
                               break;
                           }

                           elem = elem[dir];
                       }

                       checkSet[i] = match;
                   }
               }
           }

           function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
               for ( var i = 0, l = checkSet.length; i < l; i++ ) {
                   var elem = checkSet[i];

                   if ( elem ) {
                       var match = false;

                       elem = elem[dir];

                       while ( elem ) {
                           if ( elem.sizcache === doneName ) {
                               match = checkSet[elem.sizset];
                               break;
                           }

                           if ( elem.nodeType === 1 ) {
                               if ( !isXML ) {
                                   elem.sizcache = doneName;
                                   elem.sizset = i;
                               }

                               if ( typeof cur !== "string" ) {
                                   if ( elem === cur ) {
                                       match = true;
                                       break;
                                   }

                               } else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
                                   match = elem;
                                   break;
                               }
                           }

                           elem = elem[dir];
                       }

                       checkSet[i] = match;
                   }
               }
           }

           if ( document.documentElement.contains ) {
               Sizzle.contains = function( a, b ) {
                   return a !== b && (a.contains ? a.contains(b) : true);
               };

           } else if ( document.documentElement.compareDocumentPosition ) {
               Sizzle.contains = function( a, b ) {
                   return !!(a.compareDocumentPosition(b) & 16);
               };

           } else {
               Sizzle.contains = function() {
                   return false;
               };
           }

           Sizzle.isXML = function( elem ) {
               // documentElement is verified for cases where it doesn't yet exist
               // (such as loading iframes in IE - #4833) 
               var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

               return documentElement ? documentElement.nodeName !== "HTML" : false;
           };

           var posProcess = function( selector, context ) {
               var match,
                       tmpSet = [],
                       later = "",
                       root = context.nodeType ? [context] : context;

               // Position selectors must be done after the filter
               // And so must :not(positional) so we move all PSEUDOs to the end
               while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
                   later += match[0];
                   selector = selector.replace( Expr.match.PSEUDO, "" );
               }

               selector = Expr.relative[selector] ? selector + "*" : selector;

               for ( var i = 0, l = root.length; i < l; i++ ) {
                   Sizzle( selector, root[i], tmpSet );
               }

               return Sizzle.filter( later, tmpSet );
           };

// EXPOSE
           jQuery.find = Sizzle;
           jQuery.expr = Sizzle.selectors;
           jQuery.expr[":"] = jQuery.expr.filters;
           jQuery.unique = Sizzle.uniqueSort;
           jQuery.text = Sizzle.getText;
           jQuery.isXMLDoc = Sizzle.isXML;
           jQuery.contains = Sizzle.contains;


       })();


       var runtil = /Until$/,
               rparentsprev = /^(?:parents|prevUntil|prevAll)/,
       // Note: This RegExp should be improved, or likely pulled from Sizzle
               rmultiselector = /,/,
               isSimple = /^.[^:#\[\.,]*$/,
               slice = Array.prototype.slice,
               POS = jQuery.expr.match.POS,
       // methods guaranteed to produce a unique set when starting from a unique set
               guaranteedUnique = {
                   children: true,
                   contents: true,
                   next: true,
                   prev: true
               };

       jQuery.fn.extend({
           find: function( selector ) {
               var self = this,
                       i, l;

               if ( typeof selector !== "string" ) {
                   return jQuery( selector ).filter(function() {
                       for ( i = 0, l = self.length; i < l; i++ ) {
                           if ( jQuery.contains( self[ i ], this ) ) {
                               return true;
                           }
                       }
                   });
               }

               var ret = this.pushStack( "", "find", selector ),
                       length, n, r;

               for ( i = 0, l = this.length; i < l; i++ ) {
                   length = ret.length;
                   jQuery.find( selector, this[i], ret );

                   if ( i > 0 ) {
                       // Make sure that the results are unique
                       for ( n = length; n < ret.length; n++ ) {
                           for ( r = 0; r < length; r++ ) {
                               if ( ret[r] === ret[n] ) {
                                   ret.splice(n--, 1);
                                   break;
                               }
                           }
                       }
                   }
               }

               return ret;
           },

           has: function( target ) {
               var targets = jQuery( target );
               return this.filter(function() {
                   for ( var i = 0, l = targets.length; i < l; i++ ) {
                       if ( jQuery.contains( this, targets[i] ) ) {
                           return true;
                       }
                   }
               });
           },

           not: function( selector ) {
               return this.pushStack( winnow(this, selector, false), "not", selector);
           },

           filter: function( selector ) {
               return this.pushStack( winnow(this, selector, true), "filter", selector );
           },

           is: function( selector ) {
               return !!selector && ( typeof selector === "string" ?
                       jQuery.filter( selector, this ).length > 0 :
                       this.filter( selector ).length > 0 );
           },

           closest: function( selectors, context ) {
               var ret = [], i, l, cur = this[0];

               // Array
               if ( jQuery.isArray( selectors ) ) {
                   var match, selector,
                           matches = {},
                           level = 1;

                   if ( cur && selectors.length ) {
                       for ( i = 0, l = selectors.length; i < l; i++ ) {
                           selector = selectors[i];

                           if ( !matches[ selector ] ) {
                               matches[ selector ] = POS.test( selector ) ?
                                       jQuery( selector, context || this.context ) :
                                       selector;
                           }
                       }

                       while ( cur && cur.ownerDocument && cur !== context ) {
                           for ( selector in matches ) {
                               match = matches[ selector ];

                               if ( match.jquery ? match.index( cur ) > -1 : jQuery( cur ).is( match ) ) {
                                   ret.push({ selector: selector, elem: cur, level: level });
                               }
                           }

                           cur = cur.parentNode;
                           level++;
                       }
                   }

                   return ret;
               }

               // String
               var pos = POS.test( selectors ) || typeof selectors !== "string" ?
                       jQuery( selectors, context || this.context ) :
                       0;

               for ( i = 0, l = this.length; i < l; i++ ) {
                   cur = this[i];

                   while ( cur ) {
                       if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
                           ret.push( cur );
                           break;

                       } else {
                           cur = cur.parentNode;
                           if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
                               break;
                           }
                       }
                   }
               }

               ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

               return this.pushStack( ret, "closest", selectors );
           },

           // Determine the position of an element within
           // the matched set of elements
           index: function( elem ) {
               if ( !elem || typeof elem === "string" ) {
                   return jQuery.inArray( this[0],
                           // If it receives a string, the selector is used
                           // If it receives nothing, the siblings are used
                           elem ? jQuery( elem ) : this.parent().children() );
               }
               // Locate the position of the desired element
               return jQuery.inArray(
                       // If it receives a jQuery object, the first element is used
                       elem.jquery ? elem[0] : elem, this );
           },

           add: function( selector, context ) {
               var set = typeof selector === "string" ?
                               jQuery( selector, context ) :
                               jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
                       all = jQuery.merge( this.get(), set );

               return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
                       all :
                       jQuery.unique( all ) );
           },

           andSelf: function() {
               return this.add( this.prevObject );
           }
       });

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
       function isDisconnected( node ) {
           return !node || !node.parentNode || node.parentNode.nodeType === 11;
       }

       jQuery.each({
           parent: function( elem ) {
               var parent = elem.parentNode;
               return parent && parent.nodeType !== 11 ? parent : null;
           },
           parents: function( elem ) {
               return jQuery.dir( elem, "parentNode" );
           },
           parentsUntil: function( elem, i, until ) {
               return jQuery.dir( elem, "parentNode", until );
           },
           next: function( elem ) {
               return jQuery.nth( elem, 2, "nextSibling" );
           },
           prev: function( elem ) {
               return jQuery.nth( elem, 2, "previousSibling" );
           },
           nextAll: function( elem ) {
               return jQuery.dir( elem, "nextSibling" );
           },
           prevAll: function( elem ) {
               return jQuery.dir( elem, "previousSibling" );
           },
           nextUntil: function( elem, i, until ) {
               return jQuery.dir( elem, "nextSibling", until );
           },
           prevUntil: function( elem, i, until ) {
               return jQuery.dir( elem, "previousSibling", until );
           },
           siblings: function( elem ) {
               return jQuery.sibling( elem.parentNode.firstChild, elem );
           },
           children: function( elem ) {
               return jQuery.sibling( elem.firstChild );
           },
           contents: function( elem ) {
               return jQuery.nodeName( elem, "iframe" ) ?
                       elem.contentDocument || elem.contentWindow.document :
                       jQuery.makeArray( elem.childNodes );
           }
       }, function( name, fn ) {
           jQuery.fn[ name ] = function( until, selector ) {
               var ret = jQuery.map( this, fn, until ),
               // The variable 'args' was introduced in
               // https://github.com/jquery/jquery/commit/52a0238
               // to work around a bug in Chrome 10 (Dev) and should be removed when the bug is fixed.
               // http://code.google.com/p/v8/issues/detail?id=1050
                       args = slice.call(arguments);

               if ( !runtil.test( name ) ) {
                   selector = until;
               }

               if ( selector && typeof selector === "string" ) {
                   ret = jQuery.filter( selector, ret );
               }

               ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

               if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
                   ret = ret.reverse();
               }

               return this.pushStack( ret, name, args.join(",") );
           };
       });

       jQuery.extend({
           filter: function( expr, elems, not ) {
               if ( not ) {
                   expr = ":not(" + expr + ")";
               }

               return elems.length === 1 ?
                       jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
                       jQuery.find.matches(expr, elems);
           },

           dir: function( elem, dir, until ) {
               var matched = [],
                       cur = elem[ dir ];

               while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
                   if ( cur.nodeType === 1 ) {
                       matched.push( cur );
                   }
                   cur = cur[dir];
               }
               return matched;
           },

           nth: function( cur, result, dir, elem ) {
               result = result || 1;
               var num = 0;

               for ( ; cur; cur = cur[dir] ) {
                   if ( cur.nodeType === 1 && ++num === result ) {
                       break;
                   }
               }

               return cur;
           },

           sibling: function( n, elem ) {
               var r = [];

               for ( ; n; n = n.nextSibling ) {
                   if ( n.nodeType === 1 && n !== elem ) {
                       r.push( n );
                   }
               }

               return r;
           }
       });

// Implement the identical functionality for filter and not
       function winnow( elements, qualifier, keep ) {

           // Can't pass null or undefined to indexOf in Firefox 4
           // Set to 0 to skip string check
           qualifier = qualifier || 0;

           if ( jQuery.isFunction( qualifier ) ) {
               return jQuery.grep(elements, function( elem, i ) {
                   var retVal = !!qualifier.call( elem, i, elem );
                   return retVal === keep;
               });

           } else if ( qualifier.nodeType ) {
               return jQuery.grep(elements, function( elem, i ) {
                   return (elem === qualifier) === keep;
               });

           } else if ( typeof qualifier === "string" ) {
               var filtered = jQuery.grep(elements, function( elem ) {
                   return elem.nodeType === 1;
               });

               if ( isSimple.test( qualifier ) ) {
                   return jQuery.filter(qualifier, filtered, !keep);
               } else {
                   qualifier = jQuery.filter( qualifier, filtered );
               }
           }

           return jQuery.grep(elements, function( elem, i ) {
               return (jQuery.inArray( elem, qualifier ) >= 0) === keep;
           });
       }




       var rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
               rleadingWhitespace = /^\s+/,
               rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
               rtagName = /<([\w:]+)/,
               rtbody = /<tbody/i,
               rhtml = /<|&#?\w+;/,
               rnocache = /<(?:script|object|embed|option|style)/i,
       // checked="checked" or checked
               rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
               rscriptType = /\/(java|ecma)script/i,
               rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
               wrapMap = {
                   option: [ 1, "<select multiple='multiple'>", "</select>" ],
                   legend: [ 1, "<fieldset>", "</fieldset>" ],
                   thead: [ 1, "<table>", "</table>" ],
                   tr: [ 2, "<table><tbody>", "</tbody></table>" ],
                   td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
                   col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
                   area: [ 1, "<map>", "</map>" ],
                   _default: [ 0, "", "" ]
               };

       wrapMap.optgroup = wrapMap.option;
       wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
       wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
       if ( !jQuery.support.htmlSerialize ) {
           wrapMap._default = [ 1, "div<div>", "</div>" ];
       }

       jQuery.fn.extend({
           text: function( text ) {
               if ( jQuery.isFunction(text) ) {
                   return this.each(function(i) {
                       var self = jQuery( this );

                       self.text( text.call(this, i, self.text()) );
                   });
               }

               if ( typeof text !== "object" && text !== undefined ) {
                   return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
               }

               return jQuery.text( this );
           },

           wrapAll: function( html ) {
               if ( jQuery.isFunction( html ) ) {
                   return this.each(function(i) {
                       jQuery(this).wrapAll( html.call(this, i) );
                   });
               }

               if ( this[0] ) {
                   // The elements to wrap the target around
                   var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

                   if ( this[0].parentNode ) {
                       wrap.insertBefore( this[0] );
                   }

                   wrap.map(function() {
                       var elem = this;

                       while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
                           elem = elem.firstChild;
                       }

                       return elem;
                   }).append( this );
               }

               return this;
           },

           wrapInner: function( html ) {
               if ( jQuery.isFunction( html ) ) {
                   return this.each(function(i) {
                       jQuery(this).wrapInner( html.call(this, i) );
                   });
               }

               return this.each(function() {
                   var self = jQuery( this ),
                           contents = self.contents();

                   if ( contents.length ) {
                       contents.wrapAll( html );

                   } else {
                       self.append( html );
                   }
               });
           },

           wrap: function( html ) {
               return this.each(function() {
                   jQuery( this ).wrapAll( html );
               });
           },

           unwrap: function() {
               return this.parent().each(function() {
                   if ( !jQuery.nodeName( this, "body" ) ) {
                       jQuery( this ).replaceWith( this.childNodes );
                   }
               }).end();
           },

           append: function() {
               return this.domManip(arguments, true, function( elem ) {
                   if ( this.nodeType === 1 ) {
                       this.appendChild( elem );
                   }
               });
           },

           prepend: function() {
               return this.domManip(arguments, true, function( elem ) {
                   if ( this.nodeType === 1 ) {
                       this.insertBefore( elem, this.firstChild );
                   }
               });
           },

           before: function() {
               if ( this[0] && this[0].parentNode ) {
                   return this.domManip(arguments, false, function( elem ) {
                       this.parentNode.insertBefore( elem, this );
                   });
               } else if ( arguments.length ) {
                   var set = jQuery(arguments[0]);
                   set.push.apply( set, this.toArray() );
                   return this.pushStack( set, "before", arguments );
               }
           },

           after: function() {
               if ( this[0] && this[0].parentNode ) {
                   return this.domManip(arguments, false, function( elem ) {
                       this.parentNode.insertBefore( elem, this.nextSibling );
                   });
               } else if ( arguments.length ) {
                   var set = this.pushStack( this, "after", arguments );
                   set.push.apply( set, jQuery(arguments[0]).toArray() );
                   return set;
               }
           },

           // keepData is for internal use only--do not document
           remove: function( selector, keepData ) {
               for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
                   if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
                       if ( !keepData && elem.nodeType === 1 ) {
                           jQuery.cleanData( elem.getElementsByTagName("*") );
                           jQuery.cleanData( [ elem ] );
                       }

                       if ( elem.parentNode ) {
                           elem.parentNode.removeChild( elem );
                       }
                   }
               }

               return this;
           },

           empty: function() {
               for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
                   // Remove element nodes and prevent memory leaks
                   if ( elem.nodeType === 1 ) {
                       jQuery.cleanData( elem.getElementsByTagName("*") );
                   }

                   // Remove any remaining nodes
                   while ( elem.firstChild ) {
                       elem.removeChild( elem.firstChild );
                   }
               }

               return this;
           },

           clone: function( dataAndEvents, deepDataAndEvents ) {
               dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
               deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

               return this.map( function () {
                   return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
               });
           },

           html: function( value ) {
               if ( value === undefined ) {
                   return this[0] && this[0].nodeType === 1 ?
                           this[0].innerHTML.replace(rinlinejQuery, "") :
                           null;

                   // See if we can take a shortcut and just use innerHTML
               } else if ( typeof value === "string" && !rnocache.test( value ) &&
                       (jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
                       !wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {

                   value = value.replace(rxhtmlTag, "<$1></$2>");

                   try {
                       for ( var i = 0, l = this.length; i < l; i++ ) {
                           // Remove element nodes and prevent memory leaks
                           if ( this[i].nodeType === 1 ) {
                               jQuery.cleanData( this[i].getElementsByTagName("*") );
                               this[i].innerHTML = value;
                           }
                       }

                       // If using innerHTML throws an exception, use the fallback method
                   } catch(e) {
                       this.empty().append( value );
                   }

               } else if ( jQuery.isFunction( value ) ) {
                   this.each(function(i){
                       var self = jQuery( this );

                       self.html( value.call(this, i, self.html()) );
                   });

               } else {
                   this.empty().append( value );
               }

               return this;
           },

           replaceWith: function( value ) {
               if ( this[0] && this[0].parentNode ) {
                   // Make sure that the elements are removed from the DOM before they are inserted
                   // this can help fix replacing a parent with child elements
                   if ( jQuery.isFunction( value ) ) {
                       return this.each(function(i) {
                           var self = jQuery(this), old = self.html();
                           self.replaceWith( value.call( this, i, old ) );
                       });
                   }

                   if ( typeof value !== "string" ) {
                       value = jQuery( value ).detach();
                   }

                   return this.each(function() {
                       var next = this.nextSibling,
                               parent = this.parentNode;

                       jQuery( this ).remove();

                       if ( next ) {
                           jQuery(next).before( value );
                       } else {
                           jQuery(parent).append( value );
                       }
                   });
               } else {
                   return this.length ?
                           this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
                           this;
               }
           },

           detach: function( selector ) {
               return this.remove( selector, true );
           },

           domManip: function( args, table, callback ) {
               var results, first, fragment, parent,
                       value = args[0],
                       scripts = [];

               // We can't cloneNode fragments that contain checked, in WebKit
               if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
                   return this.each(function() {
                       jQuery(this).domManip( args, table, callback, true );
                   });
               }

               if ( jQuery.isFunction(value) ) {
                   return this.each(function(i) {
                       var self = jQuery(this);
                       args[0] = value.call(this, i, table ? self.html() : undefined);
                       self.domManip( args, table, callback );
                   });
               }

               if ( this[0] ) {
                   parent = value && value.parentNode;

                   // If we're in a fragment, just use that instead of building a new one
                   if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
                       results = { fragment: parent };

                   } else {
                       results = jQuery.buildFragment( args, this, scripts );
                   }

                   fragment = results.fragment;

                   if ( fragment.childNodes.length === 1 ) {
                       first = fragment = fragment.firstChild;
                   } else {
                       first = fragment.firstChild;
                   }

                   if ( first ) {
                       table = table && jQuery.nodeName( first, "tr" );

                       for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
                           callback.call(
                                   table ?
                                           root(this[i], first) :
                                           this[i],
                                   // Make sure that we do not leak memory by inadvertently discarding
                                   // the original fragment (which might have attached data) instead of
                                   // using it; in addition, use the original fragment object for the last
                                   // item instead of first because it can end up being emptied incorrectly
                                   // in certain situations (Bug #8070).
                                   // Fragments from the fragment cache must always be cloned and never used
                                   // in place.
                                   results.cacheable || (l > 1 && i < lastIndex) ?
                                           jQuery.clone( fragment, true, true ) :
                                           fragment
                           );
                       }
                   }

                   if ( scripts.length ) {
                       jQuery.each( scripts, evalScript );
                   }
               }

               return this;
           }
       });

       function root( elem, cur ) {
           return jQuery.nodeName(elem, "table") ?
                   (elem.getElementsByTagName("tbody")[0] ||
                           elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
                   elem;
       }

       function cloneCopyEvent( src, dest ) {

           if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
               return;
           }

           var internalKey = jQuery.expando,
                   oldData = jQuery.data( src ),
                   curData = jQuery.data( dest, oldData );

           // Switch to use the internal data object, if it exists, for the next
           // stage of data copying
           if ( (oldData = oldData[ internalKey ]) ) {
               var events = oldData.events;
               curData = curData[ internalKey ] = jQuery.extend({}, oldData);

               if ( events ) {
                   delete curData.handle;
                   curData.events = {};

                   for ( var type in events ) {
                       for ( var i = 0, l = events[ type ].length; i < l; i++ ) {
                           jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
                       }
                   }
               }
           }
       }

       function cloneFixAttributes( src, dest ) {
           var nodeName;

           // We do not need to do anything for non-Elements
           if ( dest.nodeType !== 1 ) {
               return;
           }

           // clearAttributes removes the attributes, which we don't want,
           // but also removes the attachEvent events, which we *do* want
           if ( dest.clearAttributes ) {
               dest.clearAttributes();
           }

           // mergeAttributes, in contrast, only merges back on the
           // original attributes, not the events
           if ( dest.mergeAttributes ) {
               dest.mergeAttributes( src );
           }

           nodeName = dest.nodeName.toLowerCase();

           // IE6-8 fail to clone children inside object elements that use
           // the proprietary classid attribute value (rather than the type
           // attribute) to identify the type of content to display
           if ( nodeName === "object" ) {
               dest.outerHTML = src.outerHTML;

           } else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
               // IE6-8 fails to persist the checked state of a cloned checkbox
               // or radio button. Worse, IE6-7 fail to give the cloned element
               // a checked appearance if the defaultChecked value isn't also set
               if ( src.checked ) {
                   dest.defaultChecked = dest.checked = src.checked;
               }

               // IE6-7 get confused and end up setting the value of a cloned
               // checkbox/radio button to an empty string instead of "on"
               if ( dest.value !== src.value ) {
                   dest.value = src.value;
               }

               // IE6-8 fails to return the selected option to the default selected
               // state when cloning options
           } else if ( nodeName === "option" ) {
               dest.selected = src.defaultSelected;

               // IE6-8 fails to set the defaultValue to the correct value when
               // cloning other types of input fields
           } else if ( nodeName === "input" || nodeName === "textarea" ) {
               dest.defaultValue = src.defaultValue;
           }

           // Event data gets referenced instead of copied if the expando
           // gets copied too
           dest.removeAttribute( jQuery.expando );
       }

       jQuery.buildFragment = function( args, nodes, scripts ) {
           var fragment, cacheable, cacheresults,
                   doc = (nodes && nodes[0] ? nodes[0].ownerDocument || nodes[0] : document);

           // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
           // Cloning options loses the selected state, so don't cache them
           // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
           // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
           if ( args.length === 1 && typeof args[0] === "string" && args[0].length < 512 && doc === document &&
                   args[0].charAt(0) === "<" && !rnocache.test( args[0] ) && (jQuery.support.checkClone || !rchecked.test( args[0] )) ) {

               cacheable = true;

               cacheresults = jQuery.fragments[ args[0] ];
               if ( cacheresults && cacheresults !== 1 ) {
                   fragment = cacheresults;
               }
           }

           if ( !fragment ) {
               fragment = doc.createDocumentFragment();
               jQuery.clean( args, doc, fragment, scripts );
           }

           if ( cacheable ) {
               jQuery.fragments[ args[0] ] = cacheresults ? fragment : 1;
           }

           return { fragment: fragment, cacheable: cacheable };
       };

       jQuery.fragments = {};

       jQuery.each({
           appendTo: "append",
           prependTo: "prepend",
           insertBefore: "before",
           insertAfter: "after",
           replaceAll: "replaceWith"
       }, function( name, original ) {
           jQuery.fn[ name ] = function( selector ) {
               var ret = [],
                       insert = jQuery( selector ),
                       parent = this.length === 1 && this[0].parentNode;

               if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
                   insert[ original ]( this[0] );
                   return this;

               } else {
                   for ( var i = 0, l = insert.length; i < l; i++ ) {
                       var elems = (i > 0 ? this.clone(true) : this).get();
                       jQuery( insert[i] )[ original ]( elems );
                       ret = ret.concat( elems );
                   }

                   return this.pushStack( ret, name, insert.selector );
               }
           };
       });

       function getAll( elem ) {
           if ( "getElementsByTagName" in elem ) {
               return elem.getElementsByTagName( "*" );

           } else if ( "querySelectorAll" in elem ) {
               return elem.querySelectorAll( "*" );

           } else {
               return [];
           }
       }

// Used in clean, fixes the defaultChecked property
       function fixDefaultChecked( elem ) {
           if ( elem.type === "checkbox" || elem.type === "radio" ) {
               elem.defaultChecked = elem.checked;
           }
       }
// Finds all inputs and passes them to fixDefaultChecked
       function findInputs( elem ) {
           if ( jQuery.nodeName( elem, "input" ) ) {
               fixDefaultChecked( elem );
           } else if ( elem.getElementsByTagName ) {
               jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
           }
       }

       jQuery.extend({
           clone: function( elem, dataAndEvents, deepDataAndEvents ) {
               var clone = elem.cloneNode(true),
                       srcElements,
                       destElements,
                       i;

               if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
                       (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
                   // IE copies events bound via attachEvent when using cloneNode.
                   // Calling detachEvent on the clone will also remove the events
                   // from the original. In order to get around this, we use some
                   // proprietary methods to clear the events. Thanks to MooTools
                   // guys for this hotness.

                   cloneFixAttributes( elem, clone );

                   // Using Sizzle here is crazy slow, so we use getElementsByTagName
                   // instead
                   srcElements = getAll( elem );
                   destElements = getAll( clone );

                   // Weird iteration because IE will replace the length property
                   // with an element if you are cloning the body and one of the
                   // elements on the page has a name or id of "length"
                   for ( i = 0; srcElements[i]; ++i ) {
                       cloneFixAttributes( srcElements[i], destElements[i] );
                   }
               }

               // Copy the events from the original to the clone
               if ( dataAndEvents ) {
                   cloneCopyEvent( elem, clone );

                   if ( deepDataAndEvents ) {
                       srcElements = getAll( elem );
                       destElements = getAll( clone );

                       for ( i = 0; srcElements[i]; ++i ) {
                           cloneCopyEvent( srcElements[i], destElements[i] );
                       }
                   }
               }

               // Return the cloned set
               return clone;
           },

           clean: function( elems, context, fragment, scripts ) {
               var checkScriptType;

               context = context || document;

               // !context.createElement fails in IE with an error but returns typeof 'object'
               if ( typeof context.createElement === "undefined" ) {
                   context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
               }

               var ret = [], j;

               for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
                   if ( typeof elem === "number" ) {
                       elem += "";
                   }

                   if ( !elem ) {
                       continue;
                   }

                   // Convert html string into DOM nodes
                   if ( typeof elem === "string" ) {
                       if ( !rhtml.test( elem ) ) {
                           elem = context.createTextNode( elem );
                       } else {
                           // Fix "XHTML"-style tags in all browsers
                           elem = elem.replace(rxhtmlTag, "<$1></$2>");

                           // Trim whitespace, otherwise indexOf won't work as expected
                           var tag = (rtagName.exec( elem ) || ["", ""])[1].toLowerCase(),
                                   wrap = wrapMap[ tag ] || wrapMap._default,
                                   depth = wrap[0],
                                   div = context.createElement("div");

                           // Go to html and back, then peel off extra wrappers
                           div.innerHTML = wrap[1] + elem + wrap[2];

                           // Move to the right depth
                           while ( depth-- ) {
                               div = div.lastChild;
                           }

                           // Remove IE's autoinserted <tbody> from table fragments
                           if ( !jQuery.support.tbody ) {

                               // String was a <table>, *may* have spurious <tbody>
                               var hasBody = rtbody.test(elem),
                                       tbody = tag === "table" && !hasBody ?
                                               div.firstChild && div.firstChild.childNodes :

                                           // String was a bare <thead> or <tfoot>
                                               wrap[1] === "<table>" && !hasBody ?
                                                       div.childNodes :
                                                       [];

                               for ( j = tbody.length - 1; j >= 0 ; --j ) {
                                   if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
                                       tbody[ j ].parentNode.removeChild( tbody[ j ] );
                                   }
                               }
                           }

                           // IE completely kills leading whitespace when innerHTML is used
                           if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
                               div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
                           }

                           elem = div.childNodes;
                       }
                   }

                   // Resets defaultChecked for any radios and checkboxes
                   // about to be appended to the DOM in IE 6/7 (#8060)
                   var len;
                   if ( !jQuery.support.appendChecked ) {
                       if ( elem[0] && typeof (len = elem.length) === "number" ) {
                           for ( j = 0; j < len; j++ ) {
                               findInputs( elem[j] );
                           }
                       } else {
                           findInputs( elem );
                       }
                   }

                   if ( elem.nodeType ) {
                       ret.push( elem );
                   } else {
                       ret = jQuery.merge( ret, elem );
                   }
               }

               if ( fragment ) {
                   checkScriptType = function( elem ) {
                       return !elem.type || rscriptType.test( elem.type );
                   };
                   for ( i = 0; ret[i]; i++ ) {
                       if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
                           scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );

                       } else {
                           if ( ret[i].nodeType === 1 ) {
                               var jsTags = jQuery.grep( ret[i].getElementsByTagName( "script" ), checkScriptType );

                               ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
                           }
                           fragment.appendChild( ret[i] );
                       }
                   }
               }

               return ret;
           },

           cleanData: function( elems ) {
               var data, id, cache = jQuery.cache, internalKey = jQuery.expando, special = jQuery.event.special,
                       deleteExpando = jQuery.support.deleteExpando;

               for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
                   if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
                       continue;
                   }

                   id = elem[ jQuery.expando ];

                   if ( id ) {
                       data = cache[ id ] && cache[ id ][ internalKey ];

                       if ( data && data.events ) {
                           for ( var type in data.events ) {
                               if ( special[ type ] ) {
                                   jQuery.event.remove( elem, type );

                                   // This is a shortcut to avoid jQuery.event.remove's overhead
                               } else {
                                   jQuery.removeEvent( elem, type, data.handle );
                               }
                           }

                           // Null the DOM reference to avoid IE6/7/8 leak (#7054)
                           if ( data.handle ) {
                               data.handle.elem = null;
                           }
                       }

                       if ( deleteExpando ) {
                           delete elem[ jQuery.expando ];

                       } else if ( elem.removeAttribute ) {
                           elem.removeAttribute( jQuery.expando );
                       }

                       delete cache[ id ];
                   }
               }
           }
       });

       function evalScript( i, elem ) {
           if ( elem.src ) {
               jQuery.ajax({
                   url: elem.src,
                   async: false,
                   dataType: "script"
               });
           } else {
               jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
           }

           if ( elem.parentNode ) {
               elem.parentNode.removeChild( elem );
           }
       }




       var ralpha = /alpha\([^)]*\)/i,
               ropacity = /opacity=([^)]*)/,
               rdashAlpha = /-([a-z])/ig,
       // fixed for IE9, see #8346
               rupper = /([A-Z]|^ms)/g,
               rnumpx = /^-?\d+(?:px)?$/i,
               rnum = /^-?\d/,
               rrelNum = /^[+\-]=/,
               rrelNumFilter = /[^+\-\.\de]+/g,

               cssShow = { position: "absolute", visibility: "hidden", display: "block" },
               cssWidth = [ "Left", "Right" ],
               cssHeight = [ "Top", "Bottom" ],
               curCSS,

               getComputedStyle,
               currentStyle,

               fcamelCase = function( all, letter ) {
                   return letter.toUpperCase();
               };

       jQuery.fn.css = function( name, value ) {
           // Setting 'undefined' is a no-op
           if ( arguments.length === 2 && value === undefined ) {
               return this;
           }

           return jQuery.access( this, name, value, true, function( elem, name, value ) {
               return value !== undefined ?
                       jQuery.style( elem, name, value ) :
                       jQuery.css( elem, name );
           });
       };

       jQuery.extend({
           // Add in style property hooks for overriding the default
           // behavior of getting and setting a style property
           cssHooks: {
               opacity: {
                   get: function( elem, computed ) {
                       if ( computed ) {
                           // We should always get a number back from opacity
                           var ret = curCSS( elem, "opacity", "opacity" );
                           return ret === "" ? "1" : ret;

                       } else {
                           return elem.style.opacity;
                       }
                   }
               }
           },

           // Exclude the following css properties to add px
           cssNumber: {
               "zIndex": true,
               "fontWeight": true,
               "opacity": true,
               "zoom": true,
               "lineHeight": true,
               "widows": true,
               "orphans": true
           },

           // Add in properties whose names you wish to fix before
           // setting or getting the value
           cssProps: {
               // normalize float css property
               "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
           },

           // Get and set the style property on a DOM Node
           style: function( elem, name, value, extra ) {
               // Don't set styles on text and comment nodes
               if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
                   return;
               }

               // Make sure that we're working with the right name
               var ret, type, origName = jQuery.camelCase( name ),
                       style = elem.style, hooks = jQuery.cssHooks[ origName ];

               name = jQuery.cssProps[ origName ] || origName;

               // Check if we're setting a value
               if ( value !== undefined ) {
                   type = typeof value;

                   // Make sure that NaN and null values aren't set. See: #7116
                   if ( type === "number" && isNaN( value ) || value == null ) {
                       return;
                   }

                   // convert relative number strings (+= or -=) to relative numbers. #7345
                   if ( type === "string" && rrelNum.test( value ) ) {
                       value = +value.replace( rrelNumFilter, "" ) + parseFloat( jQuery.css( elem, name ) );
                   }

                   // If a number was passed in, add 'px' to the (except for certain CSS properties)
                   if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
                       value += "px";
                   }

                   // If a hook was provided, use that value, otherwise just set the specified value
                   if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
                       // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
                       // Fixes bug #5509
                       try {
                           style[ name ] = value;
                       } catch(e) {}
                   }

               } else {
                   // If a hook was provided get the non-computed value from there
                   if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
                       return ret;
                   }

                   // Otherwise just get the value from the style object
                   return style[ name ];
               }
           },

           css: function( elem, name, extra ) {
               var ret, hooks;

               // Make sure that we're working with the right name
               name = jQuery.camelCase( name );
               hooks = jQuery.cssHooks[ name ];
               name = jQuery.cssProps[ name ] || name;

               // cssFloat needs a special treatment
               if ( name === "cssFloat" ) {
                   name = "float";
               }

               // If a hook was provided get the computed value from there
               if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
                   return ret;

                   // Otherwise, if a way to get the computed value exists, use that
               } else if ( curCSS ) {
                   return curCSS( elem, name );
               }
           },

           // A method for quickly swapping in/out CSS properties to get correct calculations
           swap: function( elem, options, callback ) {
               var old = {};

               // Remember the old values, and insert the new ones
               for ( var name in options ) {
                   old[ name ] = elem.style[ name ];
                   elem.style[ name ] = options[ name ];
               }

               callback.call( elem );

               // Revert the old values
               for ( name in options ) {
                   elem.style[ name ] = old[ name ];
               }
           },

           camelCase: function( string ) {
               return string.replace( rdashAlpha, fcamelCase );
           }
       });

// DEPRECATED, Use jQuery.css() instead
       jQuery.curCSS = jQuery.css;

       jQuery.each(["height", "width"], function( i, name ) {
           jQuery.cssHooks[ name ] = {
               get: function( elem, computed, extra ) {
                   var val;

                   if ( computed ) {
                       if ( elem.offsetWidth !== 0 ) {
                           val = getWH( elem, name, extra );

                       } else {
                           jQuery.swap( elem, cssShow, function() {
                               val = getWH( elem, name, extra );
                           });
                       }

                       if ( val <= 0 ) {
                           val = curCSS( elem, name, name );

                           if ( val === "0px" && currentStyle ) {
                               val = currentStyle( elem, name, name );
                           }

                           if ( val != null ) {
                               // Should return "auto" instead of 0, use 0 for
                               // temporary backwards-compat
                               return val === "" || val === "auto" ? "0px" : val;
                           }
                       }

                       if ( val < 0 || val == null ) {
                           val = elem.style[ name ];

                           // Should return "auto" instead of 0, use 0 for
                           // temporary backwards-compat
                           return val === "" || val === "auto" ? "0px" : val;
                       }

                       return typeof val === "string" ? val : val + "px";
                   }
               },

               set: function( elem, value ) {
                   if ( rnumpx.test( value ) ) {
                       // ignore negative width and height values #1599
                       value = parseFloat(value);

                       if ( value >= 0 ) {
                           return value + "px";
                       }

                   } else {
                       return value;
                   }
               }
           };
       });

       if ( !jQuery.support.opacity ) {
           jQuery.cssHooks.opacity = {
               get: function( elem, computed ) {
                   // IE uses filters for opacity
                   return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
                           ( parseFloat( RegExp.$1 ) / 100 ) + "" :
                           computed ? "1" : "";
               },

               set: function( elem, value ) {
                   var style = elem.style,
                           currentStyle = elem.currentStyle;

                   // IE has trouble with opacity if it does not have layout
                   // Force it by setting the zoom level
                   style.zoom = 1;

                   // Set the alpha filter to set the opacity
                   var opacity = jQuery.isNaN( value ) ?
                                   "" :
                                   "alpha(opacity=" + value * 100 + ")",
                           filter = currentStyle && currentStyle.filter || style.filter || "";

                   style.filter = ralpha.test( filter ) ?
                           filter.replace( ralpha, opacity ) :
                           filter + " " + opacity;
               }
           };
       }

       jQuery(function() {
           // This hook cannot be added until DOM ready because the support test
           // for it is not run until after DOM ready
           if ( !jQuery.support.reliableMarginRight ) {
               jQuery.cssHooks.marginRight = {
                   get: function( elem, computed ) {
                       // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                       // Work around by temporarily setting element display to inline-block
                       var ret;
                       jQuery.swap( elem, { "display": "inline-block" }, function() {
                           if ( computed ) {
                               ret = curCSS( elem, "margin-right", "marginRight" );
                           } else {
                               ret = elem.style.marginRight;
                           }
                       });
                       return ret;
                   }
               };
           }
       });

       if ( document.defaultView && document.defaultView.getComputedStyle ) {
           getComputedStyle = function( elem, name ) {
               var ret, defaultView, computedStyle;

               name = name.replace( rupper, "-$1" ).toLowerCase();

               if ( !(defaultView = elem.ownerDocument.defaultView) ) {
                   return undefined;
               }

               if ( (computedStyle = defaultView.getComputedStyle( elem, null )) ) {
                   ret = computedStyle.getPropertyValue( name );
                   if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
                       ret = jQuery.style( elem, name );
                   }
               }

               return ret;
           };
       }

       if ( document.documentElement.currentStyle ) {
           currentStyle = function( elem, name ) {
               var left,
                       ret = elem.currentStyle && elem.currentStyle[ name ],
                       rsLeft = elem.runtimeStyle && elem.runtimeStyle[ name ],
                       style = elem.style;

               // From the awesome hack by Dean Edwards
               // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

               // If we're not dealing with a regular pixel number
               // but a number that has a weird ending, we need to convert it to pixels
               if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {
                   // Remember the original values
                   left = style.left;

                   // Put in the new values to get a computed value out
                   if ( rsLeft ) {
                       elem.runtimeStyle.left = elem.currentStyle.left;
                   }
                   style.left = name === "fontSize" ? "1em" : (ret || 0);
                   ret = style.pixelLeft + "px";

                   // Revert the changed values
                   style.left = left;
                   if ( rsLeft ) {
                       elem.runtimeStyle.left = rsLeft;
                   }
               }

               return ret === "" ? "auto" : ret;
           };
       }

       curCSS = getComputedStyle || currentStyle;

       function getWH( elem, name, extra ) {
           var which = name === "width" ? cssWidth : cssHeight,
                   val = name === "width" ? elem.offsetWidth : elem.offsetHeight;

           if ( extra === "border" ) {
               return val;
           }

           jQuery.each( which, function() {
               if ( !extra ) {
                   val -= parseFloat(jQuery.css( elem, "padding" + this )) || 0;
               }

               if ( extra === "margin" ) {
                   val += parseFloat(jQuery.css( elem, "margin" + this )) || 0;

               } else {
                   val -= parseFloat(jQuery.css( elem, "border" + this + "Width" )) || 0;
               }
           });

           return val;
       }

       if ( jQuery.expr && jQuery.expr.filters ) {
           jQuery.expr.filters.hidden = function( elem ) {
               var width = elem.offsetWidth,
                       height = elem.offsetHeight;

               return (width === 0 && height === 0) || (!jQuery.support.reliableHiddenOffsets && (elem.style.display || jQuery.css( elem, "display" )) === "none");
           };

           jQuery.expr.filters.visible = function( elem ) {
               return !jQuery.expr.filters.hidden( elem );
           };
       }




       var r20 = /%20/g,
               rbracket = /\[\]$/,
               rCRLF = /\r?\n/g,
               rhash = /#.*$/,
               rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
               rinput = /^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
       // #7653, #8125, #8152: local protocol detection
               rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|widget):$/,
               rnoContent = /^(?:GET|HEAD)$/,
               rprotocol = /^\/\//,
               rquery = /\?/,
               rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
               rselectTextarea = /^(?:select|textarea)/i,
               rspacesAjax = /\s+/,
               rts = /([?&])_=[^&]*/,
               rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

       // Keep a copy of the old load method
               _load = jQuery.fn.load,

       /* Prefilters
        * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
        * 2) These are called:
        *    - BEFORE asking for a transport
        *    - AFTER param serialization (s.data is a string if s.processData is true)
        * 3) key is the dataType
        * 4) the catchall symbol "*" can be used
        * 5) execution will start with transport dataType and THEN continue down to "*" if needed
        */
               prefilters = {},

       /* Transports bindings
        * 1) key is the dataType
        * 2) the catchall symbol "*" can be used
        * 3) selection will start with transport dataType and THEN go to "*" if needed
        */
               transports = {},

       // Document location
               ajaxLocation,

       // Document location segments
               ajaxLocParts;

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
       try {
           ajaxLocation = location.href;
       } catch( e ) {
           // Use the href attribute of an A element
           // since IE will modify it given document.location
           ajaxLocation = document.createElement( "a" );
           ajaxLocation.href = "";
           ajaxLocation = ajaxLocation.href;
       }

// Segment location into parts
       ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
       function addToPrefiltersOrTransports( structure ) {

           // dataTypeExpression is optional and defaults to "*"
           return function( dataTypeExpression, func ) {

               if ( typeof dataTypeExpression !== "string" ) {
                   func = dataTypeExpression;
                   dataTypeExpression = "*";
               }

               if ( jQuery.isFunction( func ) ) {
                   var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
                           i = 0,
                           length = dataTypes.length,
                           dataType,
                           list,
                           placeBefore;

                   // For each dataType in the dataTypeExpression
                   for(; i < length; i++ ) {
                       dataType = dataTypes[ i ];
                       // We control if we're asked to add before
                       // any existing element
                       placeBefore = /^\+/.test( dataType );
                       if ( placeBefore ) {
                           dataType = dataType.substr( 1 ) || "*";
                       }
                       list = structure[ dataType ] = structure[ dataType ] || [];
                       // then we add to the structure accordingly
                       list[ placeBefore ? "unshift" : "push" ]( func );
                   }
               }
           };
       }

// Base inspection function for prefilters and transports
       function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
                                               dataType /* internal */, inspected /* internal */ ) {

           dataType = dataType || options.dataTypes[ 0 ];
           inspected = inspected || {};

           inspected[ dataType ] = true;

           var list = structure[ dataType ],
                   i = 0,
                   length = list ? list.length : 0,
                   executeOnly = ( structure === prefilters ),
                   selection;

           for(; i < length && ( executeOnly || !selection ); i++ ) {
               selection = list[ i ]( options, originalOptions, jqXHR );
               // If we got redirected to another dataType
               // we try there if executing only and not done already
               if ( typeof selection === "string" ) {
                   if ( !executeOnly || inspected[ selection ] ) {
                       selection = undefined;
                   } else {
                       options.dataTypes.unshift( selection );
                       selection = inspectPrefiltersOrTransports(
                               structure, options, originalOptions, jqXHR, selection, inspected );
                   }
               }
           }
           // If we're only executing or nothing was selected
           // we try the catchall dataType if not done already
           if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
               selection = inspectPrefiltersOrTransports(
                       structure, options, originalOptions, jqXHR, "*", inspected );
           }
           // unnecessary when only executing (prefilters)
           // but it'll be ignored by the caller in that case
           return selection;
       }

       jQuery.fn.extend({
           load: function( url, params, callback ) {
               if ( typeof url !== "string" && _load ) {
                   return _load.apply( this, arguments );

                   // Don't do a request if no elements are being requested
               } else if ( !this.length ) {
                   return this;
               }

               var off = url.indexOf( " " );
               if ( off >= 0 ) {
                   var selector = url.slice( off, url.length );
                   url = url.slice( 0, off );
               }

               // Default to a GET request
               var type = "GET";

               // If the second parameter was provided
               if ( params ) {
                   // If it's a function
                   if ( jQuery.isFunction( params ) ) {
                       // We assume that it's the callback
                       callback = params;
                       params = undefined;

                       // Otherwise, build a param string
                   } else if ( typeof params === "object" ) {
                       params = jQuery.param( params, jQuery.ajaxSettings.traditional );
                       type = "POST";
                   }
               }

               var self = this;

               // Request the remote document
               jQuery.ajax({
                   url: url,
                   type: type,
                   dataType: "html",
                   data: params,
                   // Complete callback (responseText is used internally)
                   complete: function( jqXHR, status, responseText ) {
                       // Store the response as specified by the jqXHR object
                       responseText = jqXHR.responseText;
                       // If successful, inject the HTML into all the matched elements
                       if ( jqXHR.isResolved() ) {
                           // #4825: Get the actual response in case
                           // a dataFilter is present in ajaxSettings
                           jqXHR.done(function( r ) {
                               responseText = r;
                           });
                           // See if a selector was specified
                           self.html( selector ?
                               // Create a dummy div to hold the results
                                   jQuery("<div>")
                                       // inject the contents of the document in, removing the scripts
                                       // to avoid any 'Permission Denied' errors in IE
                                           .append(responseText.replace(rscript, ""))

                                       // Locate the specified elements
                                           .find(selector) :

                               // If not, just inject the full result
                                   responseText );
                       }

                       if ( callback ) {
                           self.each( callback, [ responseText, status, jqXHR ] );
                       }
                   }
               });

               return this;
           },

           serialize: function() {
               return jQuery.param( this.serializeArray() );
           },

           serializeArray: function() {
               return this.map(function(){
                   return this.elements ? jQuery.makeArray( this.elements ) : this;
               })
                       .filter(function(){
                           return this.name && !this.disabled &&
                                   ( this.checked || rselectTextarea.test( this.nodeName ) ||
                                           rinput.test( this.type ) );
                       })
                       .map(function( i, elem ){
                           var val = jQuery( this ).val();

                           return val == null ?
                                   null :
                                   jQuery.isArray( val ) ?
                                           jQuery.map( val, function( val, i ){
                                               return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                                           }) :
                                   { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                       }).get();
           }
       });

// Attach a bunch of functions for handling common AJAX events
       jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
           jQuery.fn[ o ] = function( f ){
               return this.bind( o, f );
           };
       });

       jQuery.each( [ "get", "post" ], function( i, method ) {
           jQuery[ method ] = function( url, data, callback, type ) {
               // shift arguments if data argument was omitted
               if ( jQuery.isFunction( data ) ) {
                   type = type || callback;
                   callback = data;
                   data = undefined;
               }

               return jQuery.ajax({
                   type: method,
                   url: url,
                   data: data,
                   success: callback,
                   dataType: type
               });
           };
       });

       jQuery.extend({

           getScript: function( url, callback ) {
               return jQuery.get( url, undefined, callback, "script" );
           },

           getJSON: function( url, data, callback ) {
               return jQuery.get( url, data, callback, "json" );
           },

           // Creates a full fledged settings object into target
           // with both ajaxSettings and settings fields.
           // If target is omitted, writes into ajaxSettings.
           ajaxSetup: function ( target, settings ) {
               if ( !settings ) {
                   // Only one parameter, we extend ajaxSettings
                   settings = target;
                   target = jQuery.extend( true, jQuery.ajaxSettings, settings );
               } else {
                   // target was provided, we extend into it
                   jQuery.extend( true, target, jQuery.ajaxSettings, settings );
               }
               // Flatten fields we don't want deep extended
               for( var field in { context: 1, url: 1 } ) {
                   if ( field in settings ) {
                       target[ field ] = settings[ field ];
                   } else if( field in jQuery.ajaxSettings ) {
                       target[ field ] = jQuery.ajaxSettings[ field ];
                   }
               }
               return target;
           },

           ajaxSettings: {
               url: ajaxLocation,
               isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
               global: true,
               type: "GET",
               contentType: "application/x-www-form-urlencoded",
               processData: true,
               async: true,
               /*
                timeout: 0,
                data: null,
                dataType: null,
                username: null,
                password: null,
                cache: null,
                traditional: false,
                headers: {},
                */

               accepts: {
                   xml: "application/xml, text/xml",
                   html: "text/html",
                   text: "text/plain",
                   json: "application/json, text/javascript",
                   "*": "*/*"
               },

               contents: {
                   xml: /xml/,
                   html: /html/,
                   json: /json/
               },

               responseFields: {
                   xml: "responseXML",
                   text: "responseText"
               },

               // List of data converters
               // 1) key format is "source_type destination_type" (a single space in-between)
               // 2) the catchall symbol "*" can be used for source_type
               converters: {

                   // Convert anything to text
                   "* text": window.String,

                   // Text to html (true = no transformation)
                   "text html": true,

                   // Evaluate text as a json expression
                   "text json": jQuery.parseJSON,

                   // Parse text as xml
                   "text xml": jQuery.parseXML
               }
           },

           ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
           ajaxTransport: addToPrefiltersOrTransports( transports ),

           // Main method
           ajax: function( url, options ) {

               // If url is an object, simulate pre-1.5 signature
               if ( typeof url === "object" ) {
                   options = url;
                   url = undefined;
               }

               // Force options to be an object
               options = options || {};

               var // Create the final options object
                       s = jQuery.ajaxSetup( {}, options ),
               // Callbacks context
                       callbackContext = s.context || s,
               // Context for global events
               // It's the callbackContext if one was provided in the options
               // and if it's a DOM node or a jQuery collection
                       globalEventContext = callbackContext !== s &&
                               ( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
                               jQuery( callbackContext ) : jQuery.event,
               // Deferreds
                       deferred = jQuery.Deferred(),
                       completeDeferred = jQuery._Deferred(),
               // Status-dependent callbacks
                       statusCode = s.statusCode || {},
               // ifModified key
                       ifModifiedKey,
               // Headers (they are sent all at once)
                       requestHeaders = {},
                       requestHeadersNames = {},
               // Response headers
                       responseHeadersString,
                       responseHeaders,
               // transport
                       transport,
               // timeout handle
                       timeoutTimer,
               // Cross-domain detection vars
                       parts,
               // The jqXHR state
                       state = 0,
               // To know if global events are to be dispatched
                       fireGlobals,
               // Loop variable
                       i,
               // Fake xhr
                       jqXHR = {

                           readyState: 0,

                           // Caches the header
                           setRequestHeader: function( name, value ) {
                               if ( !state ) {
                                   var lname = name.toLowerCase();
                                   name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                                   requestHeaders[ name ] = value;
                               }
                               return this;
                           },

                           // Raw string
                           getAllResponseHeaders: function() {
                               return state === 2 ? responseHeadersString : null;
                           },

                           // Builds headers hashtable if needed
                           getResponseHeader: function( key ) {
                               var match;
                               if ( state === 2 ) {
                                   if ( !responseHeaders ) {
                                       responseHeaders = {};
                                       while( ( match = rheaders.exec( responseHeadersString ) ) ) {
                                           responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                                       }
                                   }
                                   match = responseHeaders[ key.toLowerCase() ];
                               }
                               return match === undefined ? null : match;
                           },

                           // Overrides response content-type header
                           overrideMimeType: function( type ) {
                               if ( !state ) {
                                   s.mimeType = type;
                               }
                               return this;
                           },

                           // Cancel the request
                           abort: function( statusText ) {
                               statusText = statusText || "abort";
                               if ( transport ) {
                                   transport.abort( statusText );
                               }
                               done( 0, statusText );
                               return this;
                           }
                       };

               // Callback for when everything is done
               // It is defined here because jslint complains if it is declared
               // at the end of the function (which would be more logical and readable)
               function done( status, statusText, responses, headers ) {

                   // Called once
                   if ( state === 2 ) {
                       return;
                   }

                   // State is "done" now
                   state = 2;

                   // Clear timeout if it exists
                   if ( timeoutTimer ) {
                       clearTimeout( timeoutTimer );
                   }

                   // Dereference transport for early garbage collection
                   // (no matter how long the jqXHR object will be used)
                   transport = undefined;

                   // Cache response headers
                   responseHeadersString = headers || "";

                   // Set readyState
                   jqXHR.readyState = status ? 4 : 0;

                   var isSuccess,
                           success,
                           error,
                           response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
                           lastModified,
                           etag;

                   // If successful, handle type chaining
                   if ( status >= 200 && status < 300 || status === 304 ) {

                       // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                       if ( s.ifModified ) {

                           if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
                               jQuery.lastModified[ ifModifiedKey ] = lastModified;
                           }
                           if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
                               jQuery.etag[ ifModifiedKey ] = etag;
                           }
                       }

                       // If not modified
                       if ( status === 304 ) {

                           statusText = "notmodified";
                           isSuccess = true;

                           // If we have data
                       } else {

                           try {
                               success = ajaxConvert( s, response );
                               statusText = "success";
                               isSuccess = true;
                           } catch(e) {
                               // We have a parsererror
                               statusText = "parsererror";
                               error = e;
                           }
                       }
                   } else {
                       // We extract error from statusText
                       // then normalize statusText and status for non-aborts
                       error = statusText;
                       if( !statusText || status ) {
                           statusText = "error";
                           if ( status < 0 ) {
                               status = 0;
                           }
                       }
                   }

                   // Set data for the fake xhr object
                   jqXHR.status = status;
                   jqXHR.statusText = statusText;

                   // Success/Error
                   if ( isSuccess ) {
                       deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
                   } else {
                       deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
                   }

                   // Status-dependent callbacks
                   jqXHR.statusCode( statusCode );
                   statusCode = undefined;

                   if ( fireGlobals ) {
                       globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
                               [ jqXHR, s, isSuccess ? success : error ] );
                   }

                   // Complete
                   completeDeferred.resolveWith( callbackContext, [ jqXHR, statusText ] );

                   if ( fireGlobals ) {
                       globalEventContext.trigger( "ajaxComplete", [ jqXHR, s] );
                       // Handle the global AJAX counter
                       if ( !( --jQuery.active ) ) {
                           jQuery.event.trigger( "ajaxStop" );
                       }
                   }
               }

               // Attach deferreds
               deferred.promise( jqXHR );
               jqXHR.success = jqXHR.done;
               jqXHR.error = jqXHR.fail;
               jqXHR.complete = completeDeferred.done;

               // Status-dependent callbacks
               jqXHR.statusCode = function( map ) {
                   if ( map ) {
                       var tmp;
                       if ( state < 2 ) {
                           for( tmp in map ) {
                               statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
                           }
                       } else {
                           tmp = map[ jqXHR.status ];
                           jqXHR.then( tmp, tmp );
                       }
                   }
                   return this;
               };

               // Remove hash character (#7531: and string promotion)
               // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
               // We also use the url parameter if available
               s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

               // Extract dataTypes list
               s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

               // Determine if a cross-domain request is in order
               if ( s.crossDomain == null ) {
                   parts = rurl.exec( s.url.toLowerCase() );
                   s.crossDomain = !!( parts &&
                           ( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
                                   ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
                                           ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
                           );
               }

               // Convert data if not already a string
               if ( s.data && s.processData && typeof s.data !== "string" ) {
                   s.data = jQuery.param( s.data, s.traditional );
               }

               // Apply prefilters
               inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

               // If request was aborted inside a prefiler, stop there
               if ( state === 2 ) {
                   return false;
               }

               // We can fire global events as of now if asked to
               fireGlobals = s.global;

               // Uppercase the type
               s.type = s.type.toUpperCase();

               // Determine if request has content
               s.hasContent = !rnoContent.test( s.type );

               // Watch for a new set of requests
               if ( fireGlobals && jQuery.active++ === 0 ) {
                   jQuery.event.trigger( "ajaxStart" );
               }

               // More options handling for requests with no content
               if ( !s.hasContent ) {

                   // If data is available, append data to url
                   if ( s.data ) {
                       s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
                   }

                   // Get ifModifiedKey before adding the anti-cache parameter
                   ifModifiedKey = s.url;

                   // Add anti-cache in url if needed
                   if ( s.cache === false ) {

                       var ts = jQuery.now(),
                       // try replacing _= if it is there
                               ret = s.url.replace( rts, "$1_=" + ts );

                       // if nothing was replaced, add timestamp to the end
                       s.url = ret + ( (ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
                   }
               }

               // Set the correct header, if data is being sent
               if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
                   jqXHR.setRequestHeader( "Content-Type", s.contentType );
               }

               // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
               if ( s.ifModified ) {
                   ifModifiedKey = ifModifiedKey || s.url;
                   if ( jQuery.lastModified[ ifModifiedKey ] ) {
                       jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
                   }
                   if ( jQuery.etag[ ifModifiedKey ] ) {
                       jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
                   }
               }

               // Set the Accepts header for the server, depending on the dataType
               jqXHR.setRequestHeader(
                       "Accept",
                       s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
                               s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", */*; q=0.01" : "" ) :
                               s.accepts[ "*" ]
               );

               // Check for headers option
               for ( i in s.headers ) {
                   jqXHR.setRequestHeader( i, s.headers[ i ] );
               }

               // Allow custom headers/mimetypes and early abort
               if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
                   // Abort if not done already
                   jqXHR.abort();
                   return false;

               }

               // Install callbacks on deferreds
               for ( i in { success: 1, error: 1, complete: 1 } ) {
                   jqXHR[ i ]( s[ i ] );
               }

               // Get transport
               transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

               // If no transport, we auto-abort
               if ( !transport ) {
                   done( -1, "No Transport" );
               } else {
                   jqXHR.readyState = 1;
                   // Send global event
                   if ( fireGlobals ) {
                       globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
                   }
                   // Timeout
                   if ( s.async && s.timeout > 0 ) {
                       timeoutTimer = setTimeout( function(){
                           jqXHR.abort( "timeout" );
                       }, s.timeout );
                   }

                   try {
                       state = 1;
                       transport.send( requestHeaders, done );
                   } catch (e) {
                       // Propagate exception as error if not done
                       if ( status < 2 ) {
                           done( -1, e );
                           // Simply rethrow otherwise
                       } else {
                           jQuery.error( e );
                       }
                   }
               }

               return jqXHR;
           },

           // Serialize an array of form elements or a set of
           // key/values into a query string
           param: function( a, traditional ) {
               var s = [],
                       add = function( key, value ) {
                           // If value is a function, invoke it and return its value
                           value = jQuery.isFunction( value ) ? value() : value;
                           s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
                       };

               // Set traditional to true for jQuery <= 1.3.2 behavior.
               if ( traditional === undefined ) {
                   traditional = jQuery.ajaxSettings.traditional;
               }

               // If an array was passed in, assume that it is an array of form elements.
               if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
                   // Serialize the form elements
                   jQuery.each( a, function() {
                       add( this.name, this.value );
                   });

               } else {
                   // If traditional, encode the "old" way (the way 1.3.2 or older
                   // did it), otherwise encode params recursively.
                   for ( var prefix in a ) {
                       buildParams( prefix, a[ prefix ], traditional, add );
                   }
               }

               // Return the resulting serialization
               return s.join( "&" ).replace( r20, "+" );
           }
       });

       function buildParams( prefix, obj, traditional, add ) {
           if ( jQuery.isArray( obj ) ) {
               // Serialize array item.
               jQuery.each( obj, function( i, v ) {
                   if ( traditional || rbracket.test( prefix ) ) {
                       // Treat each array item as a scalar.
                       add( prefix, v );

                   } else {
                       // If array item is non-scalar (array or object), encode its
                       // numeric index to resolve deserialization ambiguity issues.
                       // Note that rack (as of 1.0.0) can't currently deserialize
                       // nested arrays properly, and attempting to do so may cause
                       // a server error. Possible fixes are to modify rack's
                       // deserialization algorithm or to provide an option or flag
                       // to force array serialization to be shallow.
                       buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
                   }
               });

           } else if ( !traditional && obj != null && typeof obj === "object" ) {
               // Serialize object item.
               for ( var name in obj ) {
                   buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
               }

           } else {
               // Serialize scalar item.
               add( prefix, obj );
           }
       }

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
       jQuery.extend({

           // Counter for holding the number of active queries
           active: 0,

           // Last-Modified header cache for next request
           lastModified: {},
           etag: {}

       });

       /* Handles responses to an ajax request:
        * - sets all responseXXX fields accordingly
        * - finds the right dataType (mediates between content-type and expected dataType)
        * - returns the corresponding response
        */
       function ajaxHandleResponses( s, jqXHR, responses ) {

           var contents = s.contents,
                   dataTypes = s.dataTypes,
                   responseFields = s.responseFields,
                   ct,
                   type,
                   finalDataType,
                   firstDataType;

           // Fill responseXXX fields
           for( type in responseFields ) {
               if ( type in responses ) {
                   jqXHR[ responseFields[type] ] = responses[ type ];
               }
           }

           // Remove auto dataType and get content-type in the process
           while( dataTypes[ 0 ] === "*" ) {
               dataTypes.shift();
               if ( ct === undefined ) {
                   ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
               }
           }

           // Check if we're dealing with a known content-type
           if ( ct ) {
               for ( type in contents ) {
                   if ( contents[ type ] && contents[ type ].test( ct ) ) {
                       dataTypes.unshift( type );
                       break;
                   }
               }
           }

           // Check to see if we have a response for the expected dataType
           if ( dataTypes[ 0 ] in responses ) {
               finalDataType = dataTypes[ 0 ];
           } else {
               // Try convertible dataTypes
               for ( type in responses ) {
                   if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
                       finalDataType = type;
                       break;
                   }
                   if ( !firstDataType ) {
                       firstDataType = type;
                   }
               }
               // Or just use first one
               finalDataType = finalDataType || firstDataType;
           }

           // If we found a dataType
           // We add the dataType to the list if needed
           // and return the corresponding response
           if ( finalDataType ) {
               if ( finalDataType !== dataTypes[ 0 ] ) {
                   dataTypes.unshift( finalDataType );
               }
               return responses[ finalDataType ];
           }
       }

// Chain conversions given the request and the original response
       function ajaxConvert( s, response ) {

           // Apply the dataFilter if provided
           if ( s.dataFilter ) {
               response = s.dataFilter( response, s.dataType );
           }

           var dataTypes = s.dataTypes,
                   converters = {},
                   i,
                   key,
                   length = dataTypes.length,
                   tmp,
           // Current and previous dataTypes
                   current = dataTypes[ 0 ],
                   prev,
           // Conversion expression
                   conversion,
           // Conversion function
                   conv,
           // Conversion functions (transitive conversion)
                   conv1,
                   conv2;

           // For each dataType in the chain
           for( i = 1; i < length; i++ ) {

               // Create converters map
               // with lowercased keys
               if ( i === 1 ) {
                   for( key in s.converters ) {
                       if( typeof key === "string" ) {
                           converters[ key.toLowerCase() ] = s.converters[ key ];
                       }
                   }
               }

               // Get the dataTypes
               prev = current;
               current = dataTypes[ i ];

               // If current is auto dataType, update it to prev
               if( current === "*" ) {
                   current = prev;
                   // If no auto and dataTypes are actually different
               } else if ( prev !== "*" && prev !== current ) {

                   // Get the converter
                   conversion = prev + " " + current;
                   conv = converters[ conversion ] || converters[ "* " + current ];

                   // If there is no direct converter, search transitively
                   if ( !conv ) {
                       conv2 = undefined;
                       for( conv1 in converters ) {
                           tmp = conv1.split( " " );
                           if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
                               conv2 = converters[ tmp[1] + " " + current ];
                               if ( conv2 ) {
                                   conv1 = converters[ conv1 ];
                                   if ( conv1 === true ) {
                                       conv = conv2;
                                   } else if ( conv2 === true ) {
                                       conv = conv1;
                                   }
                                   break;
                               }
                           }
                       }
                   }
                   // If we found no converter, dispatch an error
                   if ( !( conv || conv2 ) ) {
                       jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
                   }
                   // If found converter is not an equivalence
                   if ( conv !== true ) {
                       // Convert with 1 or 2 converters accordingly
                       response = conv ? conv( response ) : conv2( conv1(response) );
                   }
               }
           }
           return response;
       }




       var jsc = jQuery.now(),
               jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
       jQuery.ajaxSetup({
           jsonp: "callback",
           jsonpCallback: function() {
               return jQuery.expando + "_" + ( jsc++ );
           }
       });

// Detect, normalize options and install callbacks for jsonp requests
       jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

           var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
                   ( typeof s.data === "string" );

           if ( s.dataTypes[ 0 ] === "jsonp" ||
                   s.jsonp !== false && ( jsre.test( s.url ) ||
                           inspectData && jsre.test( s.data ) ) ) {

               var responseContainer,
                       jsonpCallback = s.jsonpCallback =
                               jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
                       previous = window[ jsonpCallback ],
                       url = s.url,
                       data = s.data,
                       replace = "$1" + jsonpCallback + "$2";

               if ( s.jsonp !== false ) {
                   url = url.replace( jsre, replace );
                   if ( s.url === url ) {
                       if ( inspectData ) {
                           data = data.replace( jsre, replace );
                       }
                       if ( s.data === data ) {
                           // Add callback manually
                           url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
                       }
                   }
               }

               s.url = url;
               s.data = data;

               // Install callback
               window[ jsonpCallback ] = function( response ) {
                   responseContainer = [ response ];
               };

               // Clean-up function
               jqXHR.always(function() {
                   // Set callback back to previous value
                   window[ jsonpCallback ] = previous;
                   // Call if it was a function and we have a response
                   if ( responseContainer && jQuery.isFunction( previous ) ) {
                       window[ jsonpCallback ]( responseContainer[ 0 ] );
                   }
               });

               // Use data converter to retrieve json after script execution
               s.converters["script json"] = function() {
                   if ( !responseContainer ) {
                       jQuery.error( jsonpCallback + " was not called" );
                   }
                   return responseContainer[ 0 ];
               };

               // force json dataType
               s.dataTypes[ 0 ] = "json";

               // Delegate to script
               return "script";
           }
       });




// Install script dataType
       jQuery.ajaxSetup({
           accepts: {
               script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
           },
           contents: {
               script: /javascript|ecmascript/
           },
           converters: {
               "text script": function( text ) {
                   jQuery.globalEval( text );
                   return text;
               }
           }
       });

// Handle cache's special case and global
       jQuery.ajaxPrefilter( "script", function( s ) {
           if ( s.cache === undefined ) {
               s.cache = false;
           }
           if ( s.crossDomain ) {
               s.type = "GET";
               s.global = false;
           }
       });

// Bind script tag hack transport
       jQuery.ajaxTransport( "script", function(s) {

           // This transport only deals with cross domain requests
           if ( s.crossDomain ) {

               var script,
                       head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

               return {

                   send: function( _, callback ) {

                       script = document.createElement( "script" );

                       script.async = "async";

                       if ( s.scriptCharset ) {
                           script.charset = s.scriptCharset;
                       }

                       script.src = s.url;

                       // Attach handlers for all browsers
                       script.onload = script.onreadystatechange = function( _, isAbort ) {

                           if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

                               // Handle memory leak in IE
                               script.onload = script.onreadystatechange = null;

                               // Remove the script
                               if ( head && script.parentNode ) {
                                   head.removeChild( script );
                               }

                               // Dereference the script
                               script = undefined;

                               // Callback if not abort
                               if ( !isAbort ) {
                                   callback( 200, "success" );
                               }
                           }
                       };
                       // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
                       // This arises when a base node is used (#2709 and #4378).
                       head.insertBefore( script, head.firstChild );
                   },

                   abort: function() {
                       if ( script ) {
                           script.onload( 0, 1 );
                       }
                   }
               };
           }
       });




       var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
               xhrOnUnloadAbort = window.ActiveXObject ? function() {
                   // Abort all pending requests
                   for ( var key in xhrCallbacks ) {
                       xhrCallbacks[ key ]( 0, 1 );
                   }
               } : false,
               xhrId = 0,
               xhrCallbacks;

// Functions to create xhrs
       function createStandardXHR() {
           try {
               return new window.XMLHttpRequest();
           } catch( e ) {}
       }

       function createActiveXHR() {
           try {
               return new window.ActiveXObject( "Microsoft.XMLHTTP" );
           } catch( e ) {}
       }

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
       jQuery.ajaxSettings.xhr = window.ActiveXObject ?
           /* Microsoft failed to properly
            * implement the XMLHttpRequest in IE7 (can't request local files),
            * so we use the ActiveXObject when it is available
            * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
            * we need a fallback.
            */
               function() {
                   return !this.isLocal && createStandardXHR() || createActiveXHR();
               } :
           // For all other browsers, use the standard XMLHttpRequest object
               createStandardXHR;

// Determine support properties
       (function( xhr ) {
           jQuery.extend( jQuery.support, {
               ajax: !!xhr,
               cors: !!xhr && ( "withCredentials" in xhr )
           });
       })( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
       if ( jQuery.support.ajax ) {

           jQuery.ajaxTransport(function( s ) {
               // Cross domain only allowed if supported through XMLHttpRequest
               if ( !s.crossDomain || jQuery.support.cors ) {

                   var callback;

                   return {
                       send: function( headers, complete ) {

                           // Get a new xhr
                           var xhr = s.xhr(),
                                   handle,
                                   i;

                           // Open the socket
                           // Passing null username, generates a login popup on Opera (#2865)
                           if ( s.username ) {
                               xhr.open( s.type, s.url, s.async, s.username, s.password );
                           } else {
                               xhr.open( s.type, s.url, s.async );
                           }

                           // Apply custom fields if provided
                           if ( s.xhrFields ) {
                               for ( i in s.xhrFields ) {
                                   xhr[ i ] = s.xhrFields[ i ];
                               }
                           }

                           // Override mime type if needed
                           if ( s.mimeType && xhr.overrideMimeType ) {
                               xhr.overrideMimeType( s.mimeType );
                           }

                           // X-Requested-With header
                           // For cross-domain requests, seeing as conditions for a preflight are
                           // akin to a jigsaw puzzle, we simply never set it to be sure.
                           // (it can always be set on a per-request basis or even using ajaxSetup)
                           // For same-domain requests, won't change header if already provided.
                           if ( !s.crossDomain && !headers["X-Requested-With"] ) {
                               headers[ "X-Requested-With" ] = "XMLHttpRequest";
                           }

                           // Need an extra try/catch for cross domain requests in Firefox 3
                           try {
                               for ( i in headers ) {
                                   xhr.setRequestHeader( i, headers[ i ] );
                               }
                           } catch( _ ) {}

                           // Do send the request
                           // This may raise an exception which is actually
                           // handled in jQuery.ajax (so no try/catch here)
                           xhr.send( ( s.hasContent && s.data ) || null );

                           // Listener
                           callback = function( _, isAbort ) {

                               var status,
                                       statusText,
                                       responseHeaders,
                                       responses,
                                       xml;

                               // Firefox throws exceptions when accessing properties
                               // of an xhr when a network error occured
                               // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
                               try {

                                   // Was never called and is aborted or complete
                                   if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

                                       // Only called once
                                       callback = undefined;

                                       // Do not keep as active anymore
                                       if ( handle ) {
                                           xhr.onreadystatechange = jQuery.noop;
                                           if ( xhrOnUnloadAbort ) {
                                               delete xhrCallbacks[ handle ];
                                           }
                                       }

                                       // If it's an abort
                                       if ( isAbort ) {
                                           // Abort it manually if needed
                                           if ( xhr.readyState !== 4 ) {
                                               xhr.abort();
                                           }
                                       } else {
                                           status = xhr.status;
                                           responseHeaders = xhr.getAllResponseHeaders();
                                           responses = {};
                                           xml = xhr.responseXML;

                                           // Construct response list
                                           if ( xml && xml.documentElement /* #4958 */ ) {
                                               responses.xml = xml;
                                           }
                                           responses.text = xhr.responseText;

                                           // Firefox throws an exception when accessing
                                           // statusText for faulty cross-domain requests
                                           try {
                                               statusText = xhr.statusText;
                                           } catch( e ) {
                                               // We normalize with Webkit giving an empty statusText
                                               statusText = "";
                                           }

                                           // Filter status for non standard behaviors

                                           // If the request is local and we have data: assume a success
                                           // (success with no data won't get notified, that's the best we
                                           // can do given current implementations)
                                           if ( !status && s.isLocal && !s.crossDomain ) {
                                               status = responses.text ? 200 : 404;
                                               // IE - #1450: sometimes returns 1223 when it should be 204
                                           } else if ( status === 1223 ) {
                                               status = 204;
                                           }
                                       }
                                   }
                               } catch( firefoxAccessException ) {
                                   if ( !isAbort ) {
                                       complete( -1, firefoxAccessException );
                                   }
                               }

                               // Call complete if needed
                               if ( responses ) {
                                   complete( status, statusText, responses, responseHeaders );
                               }
                           };

                           // if we're in sync mode or it's in cache
                           // and has been retrieved directly (IE6 & IE7)
                           // we need to manually fire the callback
                           if ( !s.async || xhr.readyState === 4 ) {
                               callback();
                           } else {
                               handle = ++xhrId;
                               if ( xhrOnUnloadAbort ) {
                                   // Create the active xhrs callbacks list if needed
                                   // and attach the unload handler
                                   if ( !xhrCallbacks ) {
                                       xhrCallbacks = {};
                                       jQuery( window ).unload( xhrOnUnloadAbort );
                                   }
                                   // Add to list of active xhrs callbacks
                                   xhrCallbacks[ handle ] = callback;
                               }
                               xhr.onreadystatechange = callback;
                           }
                       },

                       abort: function() {
                           if ( callback ) {
                               callback(0,1);
                           }
                       }
                   };
               }
           });
       }




       var elemdisplay = {},
               iframe, iframeDoc,
               rfxtypes = /^(?:toggle|show|hide)$/,
               rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
               timerId,
               fxAttrs = [
                   // height animations
                   [ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
                   // width animations
                   [ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
                   // opacity animations
                   [ "opacity" ]
               ],
               fxNow,
               requestAnimationFrame = window.webkitRequestAnimationFrame ||
                       window.mozRequestAnimationFrame ||
                       window.oRequestAnimationFrame;

       jQuery.fn.extend({
           show: function( speed, easing, callback ) {
               var elem, display;

               if ( speed || speed === 0 ) {
                   return this.animate( genFx("show", 3), speed, easing, callback);

               } else {
                   for ( var i = 0, j = this.length; i < j; i++ ) {
                       elem = this[i];

                       if ( elem.style ) {
                           display = elem.style.display;

                           // Reset the inline display of this element to learn if it is
                           // being hidden by cascaded rules or not
                           if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
                               display = elem.style.display = "";
                           }

                           // Set elements which have been overridden with display: none
                           // in a stylesheet to whatever the default browser style is
                           // for such an element
                           if ( display === "" && jQuery.css( elem, "display" ) === "none" ) {
                               jQuery._data(elem, "olddisplay", defaultDisplay(elem.nodeName));
                           }
                       }
                   }

                   // Set the display of most of the elements in a second loop
                   // to avoid the constant reflow
                   for ( i = 0; i < j; i++ ) {
                       elem = this[i];

                       if ( elem.style ) {
                           display = elem.style.display;

                           if ( display === "" || display === "none" ) {
                               elem.style.display = jQuery._data(elem, "olddisplay") || "";
                           }
                       }
                   }

                   return this;
               }
           },

           hide: function( speed, easing, callback ) {
               if ( speed || speed === 0 ) {
                   return this.animate( genFx("hide", 3), speed, easing, callback);

               } else {
                   for ( var i = 0, j = this.length; i < j; i++ ) {
                       if ( this[i].style ) {
                           var display = jQuery.css( this[i], "display" );

                           if ( display !== "none" && !jQuery._data( this[i], "olddisplay" ) ) {
                               jQuery._data( this[i], "olddisplay", display );
                           }
                       }
                   }

                   // Set the display of the elements in a second loop
                   // to avoid the constant reflow
                   for ( i = 0; i < j; i++ ) {
                       if ( this[i].style ) {
                           this[i].style.display = "none";
                       }
                   }

                   return this;
               }
           },

           // Save the old toggle function
           _toggle: jQuery.fn.toggle,

           toggle: function( fn, fn2, callback ) {
               var bool = typeof fn === "boolean";

               if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
                   this._toggle.apply( this, arguments );

               } else if ( fn == null || bool ) {
                   this.each(function() {
                       var state = bool ? fn : jQuery(this).is(":hidden");
                       jQuery(this)[ state ? "show" : "hide" ]();
                   });

               } else {
                   this.animate(genFx("toggle", 3), fn, fn2, callback);
               }

               return this;
           },

           fadeTo: function( speed, to, easing, callback ) {
               return this.filter(":hidden").css("opacity", 0).show().end()
                       .animate({opacity: to}, speed, easing, callback);
           },

           animate: function( prop, speed, easing, callback ) {
               var optall = jQuery.speed(speed, easing, callback);

               if ( jQuery.isEmptyObject( prop ) ) {
                   return this.each( optall.complete, [ false ] );
               }

               // Do not change referenced properties as per-property easing will be lost
               prop = jQuery.extend( {}, prop );

               return this[ optall.queue === false ? "each" : "queue" ](function() {
                   // XXX 'this' does not always have a nodeName when running the
                   // test suite

                   if ( optall.queue === false ) {
                       jQuery._mark( this );
                   }

                   var opt = jQuery.extend( {}, optall ),
                           isElement = this.nodeType === 1,
                           hidden = isElement && jQuery(this).is(":hidden"),
                           name, val, p,
                           display, e,
                           parts, start, end, unit;

                   // will store per property easing and be used to determine when an animation is complete
                   opt.animatedProperties = {};

                   for ( p in prop ) {

                       // property name normalization
                       name = jQuery.camelCase( p );
                       if ( p !== name ) {
                           prop[ name ] = prop[ p ];
                           delete prop[ p ];
                       }

                       val = prop[ name ];

                       // easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
                       if ( jQuery.isArray( val ) ) {
                           opt.animatedProperties[ name ] = val[ 1 ];
                           val = prop[ name ] = val[ 0 ];
                       } else {
                           opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
                       }

                       if ( val === "hide" && hidden || val === "show" && !hidden ) {
                           return opt.complete.call( this );
                       }

                       if ( isElement && ( name === "height" || name === "width" ) ) {
                           // Make sure that nothing sneaks out
                           // Record all 3 overflow attributes because IE does not
                           // change the overflow attribute when overflowX and
                           // overflowY are set to the same value
                           opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

                           // Set display property to inline-block for height/width
                           // animations on inline elements that are having width/height
                           // animated
                           if ( jQuery.css( this, "display" ) === "inline" &&
                                   jQuery.css( this, "float" ) === "none" ) {
                               if ( !jQuery.support.inlineBlockNeedsLayout ) {
                                   this.style.display = "inline-block";

                               } else {
                                   display = defaultDisplay( this.nodeName );

                                   // inline-level elements accept inline-block;
                                   // block-level elements need to be inline with layout
                                   if ( display === "inline" ) {
                                       this.style.display = "inline-block";

                                   } else {
                                       this.style.display = "inline";
                                       this.style.zoom = 1;
                                   }
                               }
                           }
                       }
                   }

                   if ( opt.overflow != null ) {
                       this.style.overflow = "hidden";
                   }

                   for ( p in prop ) {
                       e = new jQuery.fx( this, opt, p );
                       val = prop[ p ];

                       if ( rfxtypes.test(val) ) {
                           e[ val === "toggle" ? hidden ? "show" : "hide" : val ]();

                       } else {
                           parts = rfxnum.exec( val );
                           start = e.cur();

                           if ( parts ) {
                               end = parseFloat( parts[2] );
                               unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

                               // We need to compute starting value
                               if ( unit !== "px" ) {
                                   jQuery.style( this, p, (end || 1) + unit);
                                   start = ((end || 1) / e.cur()) * start;
                                   jQuery.style( this, p, start + unit);
                               }

                               // If a +=/-= token was provided, we're doing a relative animation
                               if ( parts[1] ) {
                                   end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
                               }

                               e.custom( start, end, unit );

                           } else {
                               e.custom( start, val, "" );
                           }
                       }
                   }

                   // For JS strict compliance
                   return true;
               });
           },

           stop: function( clearQueue, gotoEnd ) {
               if ( clearQueue ) {
                   this.queue([]);
               }

               this.each(function() {
                   var timers = jQuery.timers,
                           i = timers.length;
                   // clear marker counters if we know they won't be
                   if ( !gotoEnd ) {
                       jQuery._unmark( true, this );
                   }
                   while ( i-- ) {
                       if ( timers[i].elem === this ) {
                           if (gotoEnd) {
                               // force the next step to be the last
                               timers[i](true);
                           }

                           timers.splice(i, 1);
                       }
                   }
               });

               // start the next in the queue if the last step wasn't forced
               if ( !gotoEnd ) {
                   this.dequeue();
               }

               return this;
           }

       });

// Animations created synchronously will run synchronously
       function createFxNow() {
           setTimeout( clearFxNow, 0 );
           return ( fxNow = jQuery.now() );
       }

       function clearFxNow() {
           fxNow = undefined;
       }

// Generate parameters to create a standard animation
       function genFx( type, num ) {
           var obj = {};

           jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice(0,num)), function() {
               obj[ this ] = type;
           });

           return obj;
       }

// Generate shortcuts for custom animations
       jQuery.each({
           slideDown: genFx("show", 1),
           slideUp: genFx("hide", 1),
           slideToggle: genFx("toggle", 1),
           fadeIn: { opacity: "show" },
           fadeOut: { opacity: "hide" },
           fadeToggle: { opacity: "toggle" }
       }, function( name, props ) {
           jQuery.fn[ name ] = function( speed, easing, callback ) {
               return this.animate( props, speed, easing, callback );
           };
       });

       jQuery.extend({
           speed: function( speed, easing, fn ) {
               var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
                   complete: fn || !fn && easing ||
                           jQuery.isFunction( speed ) && speed,
                   duration: speed,
                   easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
               };

               opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
                       opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

               // Queueing
               opt.old = opt.complete;
               opt.complete = function( noUnmark ) {
                   if ( opt.queue !== false ) {
                       jQuery.dequeue( this );
                   } else if ( noUnmark !== false ) {
                       jQuery._unmark( this );
                   }

                   if ( jQuery.isFunction( opt.old ) ) {
                       opt.old.call( this );
                   }
               };

               return opt;
           },

           easing: {
               linear: function( p, n, firstNum, diff ) {
                   return firstNum + diff * p;
               },
               swing: function( p, n, firstNum, diff ) {
                   return ((-Math.cos(p*Math.PI)/2) + 0.5) * diff + firstNum;
               }
           },

           timers: [],

           fx: function( elem, options, prop ) {
               this.options = options;
               this.elem = elem;
               this.prop = prop;

               options.orig = options.orig || {};
           }

       });

       jQuery.fx.prototype = {
           // Simple function for setting a style value
           update: function() {
               if ( this.options.step ) {
                   this.options.step.call( this.elem, this.now, this );
               }

               (jQuery.fx.step[this.prop] || jQuery.fx.step._default)( this );
           },

           // Get the current size
           cur: function() {
               if ( this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null) ) {
                   return this.elem[ this.prop ];
               }

               var parsed,
                       r = jQuery.css( this.elem, this.prop );
               // Empty strings, null, undefined and "auto" are converted to 0,
               // complex values such as "rotate(1rad)" are returned as is,
               // simple values such as "10px" are parsed to Float.
               return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
           },

           // Start an animation from one number to another
           custom: function( from, to, unit ) {
               var self = this,
                       fx = jQuery.fx,
                       raf;

               this.startTime = fxNow || createFxNow();
               this.start = from;
               this.end = to;
               this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );
               this.now = this.start;
               this.pos = this.state = 0;

               function t( gotoEnd ) {
                   return self.step(gotoEnd);
               }

               t.elem = this.elem;

               if ( t() && jQuery.timers.push(t) && !timerId ) {
                   // Use requestAnimationFrame instead of setInterval if available
                   if ( requestAnimationFrame ) {
                       timerId = 1;
                       raf = function() {
                           // When timerId gets set to null at any point, this stops
                           if ( timerId ) {
                               requestAnimationFrame( raf );
                               fx.tick();
                           }
                       };
                       requestAnimationFrame( raf );
                   } else {
                       timerId = setInterval( fx.tick, fx.interval );
                   }
               }
           },

           // Simple 'show' function
           show: function() {
               // Remember where we started, so that we can go back to it later
               this.options.orig[this.prop] = jQuery.style( this.elem, this.prop );
               this.options.show = true;

               // Begin the animation
               // Make sure that we start at a small width/height to avoid any
               // flash of content
               this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur());

               // Start by showing the element
               jQuery( this.elem ).show();
           },

           // Simple 'hide' function
           hide: function() {
               // Remember where we started, so that we can go back to it later
               this.options.orig[this.prop] = jQuery.style( this.elem, this.prop );
               this.options.hide = true;

               // Begin the animation
               this.custom(this.cur(), 0);
           },

           // Each step of an animation
           step: function( gotoEnd ) {
               var t = fxNow || createFxNow(),
                       done = true,
                       elem = this.elem,
                       options = this.options,
                       i, n;

               if ( gotoEnd || t >= options.duration + this.startTime ) {
                   this.now = this.end;
                   this.pos = this.state = 1;
                   this.update();

                   options.animatedProperties[ this.prop ] = true;

                   for ( i in options.animatedProperties ) {
                       if ( options.animatedProperties[i] !== true ) {
                           done = false;
                       }
                   }

                   if ( done ) {
                       // Reset the overflow
                       if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

                           jQuery.each( [ "", "X", "Y" ], function (index, value) {
                               elem.style[ "overflow" + value ] = options.overflow[index];
                           });
                       }

                       // Hide the element if the "hide" operation was done
                       if ( options.hide ) {
                           jQuery(elem).hide();
                       }

                       // Reset the properties, if the item has been hidden or shown
                       if ( options.hide || options.show ) {
                           for ( var p in options.animatedProperties ) {
                               jQuery.style( elem, p, options.orig[p] );
                           }
                       }

                       // Execute the complete function
                       options.complete.call( elem );
                   }

                   return false;

               } else {
                   // classical easing cannot be used with an Infinity duration
                   if ( options.duration == Infinity ) {
                       this.now = t;
                   } else {
                       n = t - this.startTime;
                       this.state = n / options.duration;

                       // Perform the easing function, defaults to swing
                       this.pos = jQuery.easing[ options.animatedProperties[ this.prop ] ]( this.state, n, 0, 1, options.duration );
                       this.now = this.start + ((this.end - this.start) * this.pos);
                   }
                   // Perform the next step of the animation
                   this.update();
               }

               return true;
           }
       };

       jQuery.extend( jQuery.fx, {
           tick: function() {
               for ( var timers = jQuery.timers, i = 0 ; i < timers.length ; ++i ) {
                   if ( !timers[i]() ) {
                       timers.splice(i--, 1);
                   }
               }

               if ( !timers.length ) {
                   jQuery.fx.stop();
               }
           },

           interval: 13,

           stop: function() {
               clearInterval( timerId );
               timerId = null;
           },

           speeds: {
               slow: 600,
               fast: 200,
               // Default speed
               _default: 400
           },

           step: {
               opacity: function( fx ) {
                   jQuery.style( fx.elem, "opacity", fx.now );
               },

               _default: function( fx ) {
                   if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
                       fx.elem.style[ fx.prop ] = (fx.prop === "width" || fx.prop === "height" ? Math.max(0, fx.now) : fx.now) + fx.unit;
                   } else {
                       fx.elem[ fx.prop ] = fx.now;
                   }
               }
           }
       });

       if ( jQuery.expr && jQuery.expr.filters ) {
           jQuery.expr.filters.animated = function( elem ) {
               return jQuery.grep(jQuery.timers, function( fn ) {
                   return elem === fn.elem;
               }).length;
           };
       }

// Try to restore the default display value of an element
       function defaultDisplay( nodeName ) {

           if ( !elemdisplay[ nodeName ] ) {

               var elem = jQuery( "<" + nodeName + ">" ).appendTo( "body" ),
                       display = elem.css( "display" );

               elem.remove();

               // If the simple way fails,
               // get element's real default display by attaching it to a temp iframe
               if ( display === "none" || display === "" ) {
                   // No iframe to use yet, so create it
                   if ( !iframe ) {
                       iframe = document.createElement( "iframe" );
                       iframe.frameBorder = iframe.width = iframe.height = 0;
                   }

                   document.body.appendChild( iframe );

                   // Create a cacheable copy of the iframe document on first call.
                   // IE and Opera will allow us to reuse the iframeDoc without re-writing the fake html
                   // document to it, Webkit & Firefox won't allow reusing the iframe document
                   if ( !iframeDoc || !iframe.createElement ) {
                       iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
                       iframeDoc.write( "<!doctype><html><body></body></html>" );
                   }

                   elem = iframeDoc.createElement( nodeName );

                   iframeDoc.body.appendChild( elem );

                   display = jQuery.css( elem, "display" );

                   document.body.removeChild( iframe );
               }

               // Store the correct default display
               elemdisplay[ nodeName ] = display;
           }

           return elemdisplay[ nodeName ];
       }




       var rtable = /^t(?:able|d|h)$/i,
               rroot = /^(?:body|html)$/i;

       if ( "getBoundingClientRect" in document.documentElement ) {
           jQuery.fn.offset = function( options ) {
               var elem = this[0], box;

               if ( options ) {
                   return this.each(function( i ) {
                       jQuery.offset.setOffset( this, options, i );
                   });
               }

               if ( !elem || !elem.ownerDocument ) {
                   return null;
               }

               if ( elem === elem.ownerDocument.body ) {
                   return jQuery.offset.bodyOffset( elem );
               }

               try {
                   box = elem.getBoundingClientRect();
               } catch(e) {}

               var doc = elem.ownerDocument,
                       docElem = doc.documentElement;

               // Make sure we're not dealing with a disconnected DOM node
               if ( !box || !jQuery.contains( docElem, elem ) ) {
                   return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
               }

               var body = doc.body,
                       win = getWindow(doc),
                       clientTop  = docElem.clientTop  || body.clientTop  || 0,
                       clientLeft = docElem.clientLeft || body.clientLeft || 0,
                       scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
                       scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
                       top  = box.top  + scrollTop  - clientTop,
                       left = box.left + scrollLeft - clientLeft;

               return { top: top, left: left };
           };

       } else {
           jQuery.fn.offset = function( options ) {
               var elem = this[0];

               if ( options ) {
                   return this.each(function( i ) {
                       jQuery.offset.setOffset( this, options, i );
                   });
               }

               if ( !elem || !elem.ownerDocument ) {
                   return null;
               }

               if ( elem === elem.ownerDocument.body ) {
                   return jQuery.offset.bodyOffset( elem );
               }

               jQuery.offset.initialize();

               var computedStyle,
                       offsetParent = elem.offsetParent,
                       prevOffsetParent = elem,
                       doc = elem.ownerDocument,
                       docElem = doc.documentElement,
                       body = doc.body,
                       defaultView = doc.defaultView,
                       prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
                       top = elem.offsetTop,
                       left = elem.offsetLeft;

               while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
                   if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed" ) {
                       break;
                   }

                   computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
                   top  -= elem.scrollTop;
                   left -= elem.scrollLeft;

                   if ( elem === offsetParent ) {
                       top  += elem.offsetTop;
                       left += elem.offsetLeft;

                       if ( jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
                           top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
                           left += parseFloat( computedStyle.borderLeftWidth ) || 0;
                       }

                       prevOffsetParent = offsetParent;
                       offsetParent = elem.offsetParent;
                   }

                   if ( jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
                       top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
                       left += parseFloat( computedStyle.borderLeftWidth ) || 0;
                   }

                   prevComputedStyle = computedStyle;
               }

               if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
                   top  += body.offsetTop;
                   left += body.offsetLeft;
               }

               if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === "fixed" ) {
                   top  += Math.max( docElem.scrollTop, body.scrollTop );
                   left += Math.max( docElem.scrollLeft, body.scrollLeft );
               }

               return { top: top, left: left };
           };
       }

       jQuery.offset = {
           initialize: function() {
               var body = document.body, container = document.createElement("div"), innerDiv, checkDiv, table, td, bodyMarginTop = parseFloat( jQuery.css(body, "marginTop") ) || 0,
                       html = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";

               jQuery.extend( container.style, { position: "absolute", top: 0, left: 0, margin: 0, border: 0, width: "1px", height: "1px", visibility: "hidden" } );

               container.innerHTML = html;
               body.insertBefore( container, body.firstChild );
               innerDiv = container.firstChild;
               checkDiv = innerDiv.firstChild;
               td = innerDiv.nextSibling.firstChild.firstChild;

               this.doesNotAddBorder = (checkDiv.offsetTop !== 5);
               this.doesAddBorderForTableAndCells = (td.offsetTop === 5);

               checkDiv.style.position = "fixed";
               checkDiv.style.top = "20px";

               // safari subtracts parent border width here which is 5px
               this.supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15);
               checkDiv.style.position = checkDiv.style.top = "";

               innerDiv.style.overflow = "hidden";
               innerDiv.style.position = "relative";

               this.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);

               this.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop);

               body.removeChild( container );
               jQuery.offset.initialize = jQuery.noop;
           },

           bodyOffset: function( body ) {
               var top = body.offsetTop,
                       left = body.offsetLeft;

               jQuery.offset.initialize();

               if ( jQuery.offset.doesNotIncludeMarginInBodyOffset ) {
                   top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
                   left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
               }

               return { top: top, left: left };
           },

           setOffset: function( elem, options, i ) {
               var position = jQuery.css( elem, "position" );

               // set position first, in-case top/left are set even on static elem
               if ( position === "static" ) {
                   elem.style.position = "relative";
               }

               var curElem = jQuery( elem ),
                       curOffset = curElem.offset(),
                       curCSSTop = jQuery.css( elem, "top" ),
                       curCSSLeft = jQuery.css( elem, "left" ),
                       calculatePosition = (position === "absolute" || position === "fixed") && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
                       props = {}, curPosition = {}, curTop, curLeft;

               // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
               if ( calculatePosition ) {
                   curPosition = curElem.position();
                   curTop = curPosition.top;
                   curLeft = curPosition.left;
               } else {
                   curTop = parseFloat( curCSSTop ) || 0;
                   curLeft = parseFloat( curCSSLeft ) || 0;
               }

               if ( jQuery.isFunction( options ) ) {
                   options = options.call( elem, i, curOffset );
               }

               if (options.top != null) {
                   props.top = (options.top - curOffset.top) + curTop;
               }
               if (options.left != null) {
                   props.left = (options.left - curOffset.left) + curLeft;
               }

               if ( "using" in options ) {
                   options.using.call( elem, props );
               } else {
                   curElem.css( props );
               }
           }
       };


       jQuery.fn.extend({
           position: function() {
               if ( !this[0] ) {
                   return null;
               }

               var elem = this[0],

               // Get *real* offsetParent
                       offsetParent = this.offsetParent(),

               // Get correct offsets
                       offset       = this.offset(),
                       parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

               // Subtract element margins
               // note: when an element has margin: auto the offsetLeft and marginLeft
               // are the same in Safari causing offset.left to incorrectly be 0
               offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
               offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

               // Add offsetParent borders
               parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
               parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

               // Subtract the two offsets
               return {
                   top:  offset.top  - parentOffset.top,
                   left: offset.left - parentOffset.left
               };
           },

           offsetParent: function() {
               return this.map(function() {
                   var offsetParent = this.offsetParent || document.body;
                   while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
                       offsetParent = offsetParent.offsetParent;
                   }
                   return offsetParent;
               });
           }
       });


// Create scrollLeft and scrollTop methods
       jQuery.each( ["Left", "Top"], function( i, name ) {
           var method = "scroll" + name;

           jQuery.fn[ method ] = function( val ) {
               var elem, win;

               if ( val === undefined ) {
                   elem = this[ 0 ];

                   if ( !elem ) {
                       return null;
                   }

                   win = getWindow( elem );

                   // Return the scroll offset
                   return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
                           jQuery.support.boxModel && win.document.documentElement[ method ] ||
                                   win.document.body[ method ] :
                           elem[ method ];
               }

               // Set the scroll offset
               return this.each(function() {
                   win = getWindow( this );

                   if ( win ) {
                       win.scrollTo(
                               !i ? val : jQuery( win ).scrollLeft(),
                               i ? val : jQuery( win ).scrollTop()
                       );

                   } else {
                       this[ method ] = val;
                   }
               });
           };
       });

       function getWindow( elem ) {
           return jQuery.isWindow( elem ) ?
                   elem :
                   elem.nodeType === 9 ?
                           elem.defaultView || elem.parentWindow :
                           false;
       }




// Create innerHeight, innerWidth, outerHeight and outerWidth methods
       jQuery.each([ "Height", "Width" ], function( i, name ) {

           var type = name.toLowerCase();

           // innerHeight and innerWidth
           jQuery.fn["inner" + name] = function() {
               return this[0] ?
                       parseFloat( jQuery.css( this[0], type, "padding" ) ) :
                       null;
           };

           // outerHeight and outerWidth
           jQuery.fn["outer" + name] = function( margin ) {
               return this[0] ?
                       parseFloat( jQuery.css( this[0], type, margin ? "margin" : "border" ) ) :
                       null;
           };

           jQuery.fn[ type ] = function( size ) {
               // Get window width or height
               var elem = this[0];
               if ( !elem ) {
                   return size == null ? null : this;
               }

               if ( jQuery.isFunction( size ) ) {
                   return this.each(function( i ) {
                       var self = jQuery( this );
                       self[ type ]( size.call( this, i, self[ type ]() ) );
                   });
               }

               if ( jQuery.isWindow( elem ) ) {
                   // Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
                   // 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
                   var docElemProp = elem.document.documentElement[ "client" + name ];
                   return elem.document.compatMode === "CSS1Compat" && docElemProp ||
                           elem.document.body[ "client" + name ] || docElemProp;

                   // Get document width or height
               } else if ( elem.nodeType === 9 ) {
                   // Either scroll[Width/Height] or offset[Width/Height], whichever is greater
                   return Math.max(
                           elem.documentElement["client" + name],
                           elem.body["scroll" + name], elem.documentElement["scroll" + name],
                           elem.body["offset" + name], elem.documentElement["offset" + name]
                   );

                   // Get or set width or height on the element
               } else if ( size === undefined ) {
                   var orig = jQuery.css( elem, type ),
                           ret = parseFloat( orig );

                   return jQuery.isNaN( ret ) ? orig : ret;

                   // Set the width or height on the element (default to pixels if value is unitless)
               } else {
                   return this.css( type, typeof size === "string" ? size : size + "px" );
               }
           };

       });


       window.jQuery = window.$ = jQuery;


   })(window);

   </script>
   <script type="text/javascript">
   /*
    * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
    *
    * Uses the built in easing capabilities added In jQuery 1.1
    * to offer multiple easing options
    *
    * TERMS OF USE - jQuery Easing
    *
    * Open source under the BSD License.
    *
    * Copyright ? 2008 George McGinley Smith
    * All rights reserved.
    *
    * Redistribution and use in source and binary forms, with or without modification,
    * are permitted provided that the following conditions are met:
    *
    * Redistributions of source code must retain the above copyright notice, this list of
    * conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice, this list
    * of conditions and the following disclaimer in the documentation and/or other materials
    * provided with the distribution.
    *
    * Neither the name of the author nor the names of contributors may be used to endorse
    * or promote products derived from this software without specific prior written permission.
    *
    * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
    * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
    * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
    * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
    * OF THE POSSIBILITY OF SUCH DAMAGE.
    *
    */
   // t: current time, b: begInnIng value, c: change In value, d: duration
   jQuery.easing['jswing'] = jQuery.easing['swing'];
   jQuery.extend( jQuery.easing,
           {
               def: 'easeOutQuad',
               swing: function (x, t, b, c, d) {
//alert(jQuery.easing.default);
                   return jQuery.easing[jQuery.easing.def](x, t, b, c, d);
               },
               easeInQuad: function (x, t, b, c, d) {
                   return c*(t/=d)*t + b;
               },
               easeOutQuad: function (x, t, b, c, d) {
                   return -c *(t/=d)*(t-2) + b;
               },
               easeInOutQuad: function (x, t, b, c, d) {
                   if ((t/=d/2) < 1) return c/2*t*t + b;
                   return -c/2 * ((--t)*(t-2) - 1) + b;
               },
               easeInCubic: function (x, t, b, c, d) {
                   return c*(t/=d)*t*t + b;
               },
               easeOutCubic: function (x, t, b, c, d) {
                   return c*((t=t/d-1)*t*t + 1) + b;
               },
               easeInOutCubic: function (x, t, b, c, d) {
                   if ((t/=d/2) < 1) return c/2*t*t*t + b;
                   return c/2*((t-=2)*t*t + 2) + b;
               },
               easeInQuart: function (x, t, b, c, d) {
                   return c*(t/=d)*t*t*t + b;
               },
               easeOutQuart: function (x, t, b, c, d) {
                   return -c * ((t=t/d-1)*t*t*t - 1) + b;
               },
               easeInOutQuart: function (x, t, b, c, d) {
                   if ((t/=d/2) < 1) return c/2*t*t*t*t + b;
                   return -c/2 * ((t-=2)*t*t*t - 2) + b;
               },
               easeInQuint: function (x, t, b, c, d) {
                   return c*(t/=d)*t*t*t*t + b;
               },
               easeOutQuint: function (x, t, b, c, d) {
                   return c*((t=t/d-1)*t*t*t*t + 1) + b;
               },
               easeInOutQuint: function (x, t, b, c, d) {
                   if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;
                   return c/2*((t-=2)*t*t*t*t + 2) + b;
               },
               easeInSine: function (x, t, b, c, d) {
                   return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
               },
               easeOutSine: function (x, t, b, c, d) {
                   return c * Math.sin(t/d * (Math.PI/2)) + b;
               },
               easeInOutSine: function (x, t, b, c, d) {
                   return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
               },
               easeInExpo: function (x, t, b, c, d) {
                   return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
               },
               easeOutExpo: function (x, t, b, c, d) {
                   return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
               },
               easeInOutExpo: function (x, t, b, c, d) {
                   if (t==0) return b;
                   if (t==d) return b+c;
                   if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
                   return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
               },
               easeInCirc: function (x, t, b, c, d) {
                   return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
               },
               easeOutCirc: function (x, t, b, c, d) {
                   return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
               },
               easeInOutCirc: function (x, t, b, c, d) {
                   if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
                   return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
               },
               easeInElastic: function (x, t, b, c, d) {
                   var s=1.70158;var p=0;var a=c;
                   if (t==0) return b; if ((t/=d)==1) return b+c; if (!p) p=d*.3;
                   if (a < Math.abs(c)) { a=c; var s=p/4; }
                   else var s = p/(2*Math.PI) * Math.asin (c/a);
                   return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
               },
               easeOutElastic: function (x, t, b, c, d) {
                   var s=1.70158;var p=0;var a=c;
                   if (t==0) return b; if ((t/=d)==1) return b+c; if (!p) p=d*.3;
                   if (a < Math.abs(c)) { a=c; var s=p/4; }
                   else var s = p/(2*Math.PI) * Math.asin (c/a);
                   return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
               },
               easeInOutElastic: function (x, t, b, c, d) {
                   var s=1.70158;var p=0;var a=c;
                   if (t==0) return b; if ((t/=d/2)==2) return b+c; if (!p) p=d*(.3*1.5);
                   if (a < Math.abs(c)) { a=c; var s=p/4; }
                   else var s = p/(2*Math.PI) * Math.asin (c/a);
                   if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
                   return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
               },
               easeInBack: function (x, t, b, c, d, s) {
                   if (s == undefined) s = 1.70158;
                   return c*(t/=d)*t*((s+1)*t - s) + b;
               },
               easeOutBack: function (x, t, b, c, d, s) {
                   if (s == undefined) s = 1.70158;
                   return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
               },
               easeInOutBack: function (x, t, b, c, d, s) {
                   if (s == undefined) s = 1.70158;
                   if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
                   return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
               },
               easeInBounce: function (x, t, b, c, d) {
                   return c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d) + b;
               },
               easeOutBounce: function (x, t, b, c, d) {
                   if ((t/=d) < (1/2.75)) {
                       return c*(7.5625*t*t) + b;
                   } else if (t < (2/2.75)) {
                       return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
                   } else if (t < (2.5/2.75)) {
                       return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
                   } else {
                       return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
                   }
               },
               easeInOutBounce: function (x, t, b, c, d) {
                   if (t < d/2) return jQuery.easing.easeInBounce (x, t*2, 0, c, d) * .5 + b;
                   return jQuery.easing.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;
               }
           });
   /*
    *
    * TERMS OF USE - EASING EQUATIONS
    *
    * Open source under the BSD License.
    *
    * Copyright ? 2001 Robert Penner
    * All rights reserved.
    *
    * Redistribution and use in source and binary forms, with or without modification,
    * are permitted provided that the following conditions are met:
    *
    * Redistributions of source code must retain the above copyright notice, this list of
    * conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice, this list
    * of conditions and the following disclaimer in the documentation and/or other materials
    * provided with the distribution.
    *
    * Neither the name of the author nor the names of contributors may be used to endorse
    * or promote products derived from this software without specific prior written permission.
    *
    * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
    * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
    * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
    * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
    * OF THE POSSIBILITY OF SUCH DAMAGE.
    *
    */
   </script>
   <script type="text/javascript">



   /**
    * o-------------------------------------------------------------------------------o
    * | This file is part of the RGraph package. RGraph is Free software, licensed    |
    * | under the MIT license - so it's free to use for all purposes. Extended        |
    * | support is available if required and donations are always welcome! You can    |
    * | read more here:                                                               |
    * |                         http://www.rgraph.net/support                         |
    * o-------------------------------------------------------------------------------o
    */

   /**
    * Initialise the various objects
    */
   if (typeof(RGraph) == 'undefined') RGraph = {isRGraph:true,type:'common'};

   RGraph.Highlight      = {};
   RGraph.Registry       = {};
   RGraph.Registry.store = [];
   RGraph.Registry.store['chart.event.handlers']       = [];
   RGraph.Registry.store['__rgraph_event_listeners__'] = []; // Used in the new system for tooltips
   RGraph.background     = {};
   RGraph.objects        = [];
   RGraph.Resizing       = {};
   RGraph.events         = [];
   RGraph.cursor         = [];

   RGraph.HTML = RGraph.HTML || {};

   RGraph.ObjectRegistry                    = {};
   RGraph.ObjectRegistry.objects            = {};
   RGraph.ObjectRegistry.objects.byUID      = [];
   RGraph.ObjectRegistry.objects.byCanvasID = [];


   /**
    * Some "constants"
    */
   PI       = Math.PI;
   HALFPI   = PI / 2;
   TWOPI    = PI * 2;
   ISFF     = navigator.userAgent.indexOf('Firefox') != -1;
   ISOPERA  = navigator.userAgent.indexOf('Opera') != -1;
   ISCHROME = navigator.userAgent.indexOf('Chrome') != -1;
   ISSAFARI = navigator.userAgent.indexOf('Safari') != -1 && !ISCHROME;
   ISWEBKIT = navigator.userAgent.indexOf('WebKit') != -1;
   //ISIE     is defined below
   //ISIE6    is defined below
   //ISIE7    is defined below
   //ISIE8    is defined below
   //ISIE9    is defined below
   //ISIE9    is defined below
   //ISIE9UP  is defined below
   //ISIE10   is defined below
   //ISIE10UP is defined below
   //ISIE11   is defined below
   //ISIE11UP is defined below
   //ISOLD    is defined below


   /**
    * Returns five values which are used as a nice scale
    *
    * @param  max int    The maximum value of the graph
    * @param  obj object The graph object
    * @return     array   An appropriate scale
    */
   RGraph.getScale = function (max, obj)
   {
       /**
        * Special case for 0
        */
       if (max == 0) {
           return ['0.2', '0.4', '0.6', '0.8', '1.0'];
       }

       var original_max = max;

       /**
        * Manually do decimals
        */
       if (max <= 1) {
           if (max > 0.5) {
               return [0.2,0.4,0.6,0.8, Number(1).toFixed(1)];

           } else if (max >= 0.1) {
               return obj.Get('chart.scale.round') ? [0.2,0.4,0.6,0.8,1] : [0.1,0.2,0.3,0.4,0.5];

           } else {

               var tmp = max;
               var exp = 0;

               while (tmp < 1.01) {
                   exp += 1;
                   tmp *= 10;
               }

               var ret = ['2e-' + exp, '4e-' + exp, '6e-' + exp, '8e-' + exp, '10e-' + exp];


               if (max <= ('5e-' + exp)) {
                   ret = ['1e-' + exp, '2e-' + exp, '3e-' + exp, '4e-' + exp, '5e-' + exp];
               }

               return ret;
           }
       }

       // Take off any decimals
       if (String(max).indexOf('.') > 0) {
           max = String(max).replace(/\.\d+$/, '');
       }

       var interval = Math.pow(10, Number(String(Number(max)).length - 1));
       var topValue = interval;

       while (topValue < max) {
           topValue += (interval / 2);
       }

       // Handles cases where the max is (for example) 50.5
       if (Number(original_max) > Number(topValue)) {
           topValue += (interval / 2);
       }

       // Custom if the max is greater than 5 and less than 10
       if (max < 10) {
           topValue = (Number(original_max) <= 5 ? 5 : 10);
       }

       /**
        * Added 02/11/2010 to create "nicer" scales
        */
       if (obj && typeof(obj.Get('chart.scale.round')) == 'boolean' && obj.Get('chart.scale.round')) {
           topValue = 10 * interval;
       }

       return [topValue * 0.2, topValue * 0.4, topValue * 0.6, topValue * 0.8, topValue];
   }
























   /**
    * Returns an appropriate scale. The return value is actualy anm object consiosting of:
    *  scale.max
    *  scale.min
    *  scale.scale
    *
    * @param  obj object  The graph object
    * @param  prop object An object consisting of configuration properties
    * @return     object  An object containg scale information
    */
   RGraph.getScale2 = function (obj, opt)
   {
       var RG   = RGraph;
       var ca   = obj.canvas;
       var co   = obj.context;
       var prop = obj.properties;

       var numlabels    = typeof(opt['ylabels.count']) == 'number' ? opt['ylabels.count'] : 5;
       var units_pre    = typeof(opt['units.pre']) == 'string' ? opt['units.pre'] : '';
       var units_post   = typeof(opt['units.post']) == 'string' ? opt['units.post'] : '';
       var max          = Number(opt['max']);
       var min          = typeof(opt['min']) == 'number' ? opt['min'] : 0;
       var strict       = opt['strict'];
       var decimals     = Number(opt['scale.decimals']); // Sometimes the default is null
       var point        = opt['scale.point']; // Default is a string in all chart libraries so no need to cast it
       var thousand     = opt['scale.thousand']; // Default is a string in all chart libraries so no need to cast it
       var original_max = max;
       var round        = opt['scale.round'];
       var scale        = {'max':1,'labels':[]};



       /**
        * Special case for 0
        *
        * ** Must be first **
        */
       if (!max) {

           var max   = 1;

           var scale = {max:1,min:0,labels:[]};

           for (var i=0; i<numlabels; ++i) {
               var label = ((((max - min) / numlabels) + min) * (i + 1)).toFixed(decimals);
               scale.labels.push(units_pre + label + units_post);
           }

           /**
            * Manually do decimals
            */
       } else if (max <= 1 && !strict) {

           if (max > 0.5) {

               max  = 1;
               min  = min;
               scale.min = min;

               for (var i=0; i<numlabels; ++i) {
                   var label = ((((max - min) / numlabels) * (i + 1)) + min).toFixed(decimals);

                   scale.labels.push(units_pre + label + units_post);
               }

           } else if (max >= 0.1) {

               max   = 0.5;
               min   = min;
               scale = {'max': 0.5, 'min':min,'labels':[]}

               for (var i=0; i<numlabels; ++i) {
                   var label = ((((max - min) / numlabels) + min) * (i + 1)).toFixed(decimals);
                   scale.labels.push(units_pre + label + units_post);
               }

           } else {

               scale = {'min':min,'labels':[]}
               var max_str = String(max);

               if (max_str.indexOf('e') > 0) {
                   var numdecimals = Math.abs(max_str.substring(max_str.indexOf('e') + 1));
               } else {
                   var numdecimals = String(max).length - 2;
               }

               var max = 1  / Math.pow(10,numdecimals - 1);

               for (var i=0; i<numlabels; ++i) {
                   var label = ((((max - min) / numlabels) + min) * (i + 1));
                   label = label.toExponential();
                   label = label.split(/e/);
                   label[0] = Math.round(label[0]);
                   label = label.join('e');
                   scale.labels.push(label);
               }

               //This makes the top scale value of the format 10e-2 instead of 1e-1
               tmp = scale.labels[scale.labels.length - 1].split(/e/);
               tmp[0] += 0;
               tmp[1] = Number(tmp[1]) - 1;
               tmp = tmp[0] + 'e' + tmp[1];
               scale.labels[scale.labels.length - 1] = tmp;

               // Add the units
               for (var i=0; i<scale.labels.length ; ++i) {
                   scale.labels[i] = units_pre + scale.labels[i] + units_post;
               }

               scale.max = Number(max);
           }


       } else if (!strict) {


           /**
            * Now comes the scale handling for integer values
            */


               // This accomodates decimals by rounding the max up to the next integer
           max = Math.ceil(max);

           var interval = Math.pow(10, Math.max(1, Number(String(Number(max) - Number(min)).length - 1)) );

           var topValue = interval;

           while (topValue < max) {
               topValue += (interval / 2);
           }

           // Handles cases where the max is (for example) 50.5
           if (Number(original_max) > Number(topValue)) {
               topValue += (interval / 2);
           }

           // Custom if the max is greater than 5 and less than 10
           if (max <= 10) {
               topValue = (Number(original_max) <= 5 ? 5 : 10);
           }


           // Added 02/11/2010 to create "nicer" scales
           if (obj && typeof(round) == 'boolean' && round) {
               topValue = 10 * interval;
           }

           scale.max = topValue;

           // Now generate the scale. Temporarily set the objects chart.scale.decimal and chart.scale.point to those
           //that we've been given as the number_format functuion looks at those instead of using argumrnts.
           var tmp_point    = prop['chart.scale.point'];
           var tmp_thousand = prop['chart.scale.thousand'];

           obj.Set('chart.scale.thousand', thousand);
           obj.Set('chart.scale.point', point);


           for (var i=0; i<numlabels; ++i) {
               scale.labels.push( RG.number_format(obj, ((((i+1) / numlabels) * (topValue - min)) + min).toFixed(decimals), units_pre, units_post) );
           }

           obj.Set('chart.scale.thousand', tmp_thousand);
           obj.Set('chart.scale.point', tmp_point);

       } else if (typeof(max) == 'number' && strict) {

           /**
            * ymax is set and also strict
            */
           for (var i=0; i<numlabels; ++i) {
               scale.labels.push( RG.number_format(obj, ((((i+1) / numlabels) * (max - min)) + min).toFixed(decimals), units_pre, units_post) );
           }

           // ???
           scale.max = max;
       }


       scale.units_pre  = units_pre;
       scale.units_post = units_post;
       scale.point      = point;
       scale.decimals   = decimals;
       scale.thousand   = thousand;
       scale.numlabels  = numlabels;
       scale.round      = Boolean(round);
       scale.min        = min;


       return scale;
   }












   /**
    * Returns the maximum numeric value which is in an array
    *
    * @param  array arr The array (can also be a number, in which case it's returned as-is)
    * @param  int       Whether to ignore signs (ie negative/positive)
    * @return int       The maximum value in the array
    */
   RGraph.array_max = function (arr)
   {
       var max       = null;
       var MathLocal = Math;

       if (typeof(arr) == 'number') {
           return arr;
       }

       if (RGraph.is_null(arr)) {
           return 0;
       }

       for (var i=0,len=arr.length; i<len; ++i) {
           if (typeof(arr[i]) == 'number') {

               var val = arguments[1] ? MathLocal.abs(arr[i]) : arr[i];

               if (typeof max == 'number') {
                   max = MathLocal.max(max, val);
               } else {
                   max = val;
               }
           }
       }

       return max;
   }




   /**
    * Returns the maximum value which is in an array
    *
    * @param  array arr The array
    * @param  int   len The length to pad the array to
    * @param  mixed     The value to use to pad the array (optional)
    */
   RGraph.array_pad = function (arr, len)
   {
       if (arr.length < len) {
           var val = arguments[2] ? arguments[2] : null;

           for (var i=arr.length; i<len; i+=1) {
               arr[i] = val;
           }
       }

       return arr;
   }




   /**
    * An array sum function
    *
    * @param  array arr The  array to calculate the total of
    * @return int       The summed total of the arrays elements
    */
   RGraph.array_sum = function (arr)
   {
       // Allow integers
       if (typeof(arr) == 'number') {
           return arr;
       }

       // Account for null
       if (RGraph.is_null(arr)) {
           return 0;
       }

       var i, sum;
       var len = arr.length;

       for(i=0,sum=0;i<len;sum+=arr[i++]);
       return sum;
   }




   /**
    * Takes any number of arguments and adds them to one big linear array
    * which is then returned
    *
    * @param ... mixed The data to linearise. You can strings, booleans, numbers or arrays
    */
   RGraph.array_linearize = function ()
   {
       var arr  = [];
       var args = arguments;
       var RG   = RGraph;

       for (var i=0,len=args.length; i<len; ++i) {

           if (typeof(args[i]) == 'object' && args[i]) {
               for (var j=0; j<args[i].length; ++j) {
                   var sub = RG.array_linearize(args[i][j]);

                   for (var k=0; k<sub.length; ++k) {
                       arr.push(sub[k]);
                   }
               }
           } else {
               arr.push(args[i]);
           }
       }

       return arr;
   }




   /**
    * This is a useful function which is basically a shortcut for drawing left, right, top and bottom alligned text.
    *
    * @param object context The context
    * @param string font    The font
    * @param int    size    The size of the text
    * @param int    x       The X coordinate
    * @param int    y       The Y coordinate
    * @param string text    The text to draw
    * @parm  string         The vertical alignment. Can be null. "center" gives center aligned  text, "top" gives top aligned text.
    *                       Anything else produces bottom aligned text. Default is bottom.
    * @param  string        The horizontal alignment. Can be null. "center" gives center aligned  text, "right" gives right aligned text.
    *                       Anything else produces left aligned text. Default is left.
    * @param  bool          Whether to show a bounding box around the text. Defaults not to
    * @param int            The angle that the text should be rotate at (IN DEGREES)
    * @param string         Background color for the text
    * @param bool           Whether the text is bold or not
    */
   RGraph.Text = function (context, font, size, x, y, text)
   {
       // "Cache" the args as a local variable
       var args = arguments;

       // Handle undefined - change it to an empty string
       if ((typeof(text) != 'string' && typeof(text) != 'number') || text == 'undefined') {
           return;
       }




       /**
        * This accommodates multi-line text
        */
       if (typeof(text) == 'string' && text.match(/\r\n/)) {

           var dimensions = RGraph.MeasureText('M', args[11], font, size);

           /**
            * Measure the text (width and height)
            */

           var arr = text.split('\r\n');

           /**
            * Adjust the Y position
            */

           // This adjusts the initial y position
           if (args[6] && args[6] == 'center') y = (y - (dimensions[1] * ((arr.length - 1) / 2)));

           for (var i=1; i<arr.length; ++i) {

               RGraph.Text(context,
                       font,
                       size,
                       args[9] == -90 ? (x + (size * 1.5)) : x,
                       y + (dimensions[1] * i),
                       arr[i],
                       args[6] ? args[6] : null,
                       args[7],
                       args[8],
                       args[9],
                       args[10],
                       args[11],
                       args[12]);
           }

           // Update text to just be the first line
           text = arr[0];
       }


       // Accommodate MSIE
       if (document.all && ISOLD) {
           y += 2;
       }


       context.font = (args[11] ? 'Bold ': '') + size + 'pt ' + font;

       var i;
       var origX = x;
       var origY = y;
       var originalFillStyle = context.fillStyle;
       var originalLineWidth = context.lineWidth;

       // Need these now the angle can be specified, ie defaults for the former two args
       if (typeof(args[6])  == 'undefined') args[6]  = 'bottom'; // Vertical alignment. Default to bottom/baseline
       if (typeof(args[7])  == 'undefined') args[7]  = 'left';   // Horizontal alignment. Default to left
       if (typeof(args[8])  == 'undefined') args[8]  = null;     // Show a bounding box. Useful for positioning during development. Defaults to false
       if (typeof(args[9])  == 'undefined') args[9]  = 0;        // Angle (IN DEGREES) that the text should be drawn at. 0 is middle right, and it goes clockwise

       // The alignment is recorded here for purposes of Opera compatibility
       if (navigator.userAgent.indexOf('Opera') != -1) {
           context.canvas.__rgraph_valign__ = args[6];
           context.canvas.__rgraph_halign__ = args[7];
       }

       // First, translate to x/y coords
       context.save();

       context.canvas.__rgraph_originalx__ = x;
       context.canvas.__rgraph_originaly__ = y;

       context.translate(x, y);
       x = 0;
       y = 0;

       // Rotate the canvas if need be
       if (args[9]) {
           context.rotate(args[9] / (180 / PI));
       }


       // Vertical alignment - defaults to bottom
       if (args[6]) {

           var vAlign = args[6];

           if (vAlign == 'center') {
               context.textBaseline = 'middle';
           } else if (vAlign == 'top') {
               context.textBaseline = 'top';
           }
       }


       // Hoeizontal alignment - defaults to left
       if (args[7]) {

           var hAlign = args[7];
           var width  = context.measureText(text).width;

           if (hAlign) {
               if (hAlign == 'center') {
                   context.textAlign = 'center';
               } else if (hAlign == 'right') {
                   context.textAlign = 'right';
               }
           }
       }


       context.fillStyle = originalFillStyle;

       /**
        * Draw a bounding box if requested
        */
       context.save();
       context.fillText(text,0,0);
       context.lineWidth = 1;

       var width = context.measureText(text).width;
       var width_offset = (hAlign == 'center' ? (width / 2) : (hAlign == 'right' ? width : 0));
       var height = size * 1.5; // !!!
       var height_offset = (vAlign == 'center' ? (height / 2) : (vAlign == 'top' ? height : 0));
       var ieOffset = ISOLD ? 2 : 0;

       if (args[8]) {

           context.strokeRect(-3 - width_offset,
                   0 - 3 - height - ieOffset + height_offset,
                   width + 6,
                   height + 6);
           /**
            * If requested, draw a background for the text
            */
           if (args[10]) {
               context.fillStyle = args[10];
               context.fillRect(-3 - width_offset,
                       0 - 3 - height - ieOffset + height_offset,
                       width + 6,
                       height + 6);
           }


           context.fillStyle = originalFillStyle;


           /**
            * Do the actual drawing of the text
            */
           context.fillText(text,0,0);
       }
       context.restore();

       // Reset the lineWidth
       context.lineWidth = originalLineWidth;

       context.restore();
   }




   /**
    * Clears the canvas by setting the width. You can specify a colour if you wish.
    *
    * @param object canvas The canvas to clear
    */
   RGraph.Clear = function (ca)
   {
       var RG    = RGraph;
       var co    = ca.getContext('2d');
       var color = arguments[1];

       if (!ca) {
           return;
       }

       RG.FireCustomEvent(ca.__object__, 'onbeforeclear');

       if (ISIE8 && !color) {
           color = 'white';
       }

       /**
        * Can now clear the canvas back to fully transparent
        */
       if (!color || (color && color == 'rgba(0,0,0,0)' || color == 'transparent')) {

           co.clearRect(0,0,ca.width, ca.height);

           // Reset the globalCompositeOperation
           co.globalCompositeOperation = 'source-over';

       } else {

           co.fillStyle = color;
           co.beginPath();

           if (ISIE8) {
               co.fillRect(0,0,ca.width,ca.height);
           } else {
               co.fillRect(-10,-10,ca.width + 20,ca.height + 20);
           }

           co.fill();
       }

       //if (RG.ClearAnnotations) {
       //RG.ClearAnnotations(ca.id);
       //}

       /**
        * This removes any background image that may be present
        */
       if (RG.Registry.Get('chart.background.image.' + ca.id)) {
           var img = RG.Registry.Get('chart.background.image.' + ca.id);
           img.style.position = 'absolute';
           img.style.left     = '-10000px';
           img.style.top      = '-10000px';
       }

       /**
        * This hides the tooltip that is showing IF it has the same canvas ID as
        * that which is being cleared
        */
       if (RG.Registry.Get('chart.tooltip')) {
           RG.HideTooltip(ca);
           //RG.Redraw();
       }

       /**
        * Set the cursor to default
        */
       ca.style.cursor = 'default';

       RG.FireCustomEvent(ca.__object__, 'onclear');
   }




   /**
    * Draws the title of the graph
    *
    * @param object  canvas The canvas object
    * @param string  text   The title to write
    * @param integer gutter The size of the gutter
    * @param integer        The center X point (optional - if not given it will be generated from the canvas width)
    * @param integer        Size of the text. If not given it will be 14
    */
   RGraph.DrawTitle = function (obj, text, gutterTop)
   {
       var RG           = RGraph;
       var ca = canvas  = obj.canvas;
       var co = context = obj.context;
       var prop         = obj.properties;

       var gutterLeft   = prop['chart.gutter.left'];
       var gutterRight  = prop['chart.gutter.right'];
       var gutterTop    = gutterTop;
       var gutterBottom = prop['chart.gutter.bottom'];
       var size         = arguments[4] ? arguments[4] : 12;
       var bold         = prop['chart.title.bold'];
       var centerx      = (arguments[3] ? arguments[3] : ((ca.width - gutterLeft - gutterRight) / 2) + gutterLeft);
       var keypos       = prop['chart.key.position'];
       var vpos         = prop['chart.title.vpos'];
       var hpos         = prop['chart.title.hpos'];
       var bgcolor      = prop['chart.title.background'];
       var x            = prop['chart.title.x'];
       var y            = prop['chart.title.y'];
       var halign       = 'center';
       var valign       = 'center';

       // Account for 3D effect by faking the key position
       if (obj.type == 'bar' && prop['chart.variant'] == '3d') {
           keypos = 'gutter';
       }

       co.beginPath();
       co.fillStyle = prop['chart.text.color'] ? prop['chart.text.color'] : 'black';





       /**
        * Vertically center the text if the key is not present
        */
       if (keypos && keypos != 'gutter') {
           var valign = 'center';

       } else if (!keypos) {
           var valign = 'center';

       } else {
           var valign = 'bottom';
       }





       // if chart.title.vpos is a number, use that
       if (typeof(prop['chart.title.vpos']) == 'number') {
           vpos = prop['chart.title.vpos'] * gutterTop;

           if (prop['chart.xaxispos'] == 'top') {
               vpos = prop['chart.title.vpos'] * gutterBottom + gutterTop + (ca.height - gutterTop - gutterBottom);
           }

       } else {
           vpos = gutterTop - size - 5;

           if (prop['chart.xaxispos'] == 'top') {
               vpos = ca.height  - gutterBottom + size + 5;
           }
       }




       // if chart.title.hpos is a number, use that. It's multiplied with the (entire) canvas width
       if (typeof(hpos) == 'number') {
           centerx = hpos * ca.width;
       }

       /**
        * Now the chart.title.x and chart.title.y settings override (is set) the above
        */
       if (typeof(x) == 'number') centerx = x;
       if (typeof(y) == 'number') vpos    = y;




       /**
        * Horizontal alignment can now (Jan 2013) be specified
        */
       if (typeof(prop['chart.title.halign']) == 'string') {
           halign = prop['chart.title.halign'];
       }

       /**
        * Vertical alignment can now (Jan 2013) be specified
        */
       if (typeof(prop['chart.title.valign']) == 'string') {
           valign = prop['chart.title.valign'];
       }





       // Set the colour
       if (typeof(prop['chart.title.color'] != null)) {
           var oldColor = co.fillStyle
           var newColor = prop['chart.title.color']
           co.fillStyle = newColor ? newColor : 'black';
       }




       /**
        * Default font is Arial
        */
       var font = prop['chart.text.font'];




       /**
        * Override the default font with chart.title.font
        */
       if (typeof(prop['chart.title.font']) == 'string') {
           font = prop['chart.title.font'];
       }




       /**
        * Draw the title
        */
       RG.Text2(obj,{'font':font,
           'size':size,
           'x':centerx,
           'y':vpos,
           'text':text,
           'valign':valign,
           'halign':halign,
           'bounding':bgcolor != null,
           'bounding.fill':bgcolor,
           'bold':bold,
           'tag':'title'
       });

       // Reset the fill colour
       co.fillStyle = oldColor;
   }





   /**
    * This function returns the mouse position in relation to the canvas
    *
    * @param object e The event object.
    *
    RGraph.getMouseXY = function (e)
    {
        var el = (ISOLD ? event.srcElement : e.target);
        var x;
        var y;

        // ???
        var paddingLeft = el.style.paddingLeft ? parseInt(el.style.paddingLeft) : 0;
        var paddingTop  = el.style.paddingTop ? parseInt(el.style.paddingTop) : 0;
        var borderLeft  = el.style.borderLeftWidth ? parseInt(el.style.borderLeftWidth) : 0;
        var borderTop   = el.style.borderTopWidth  ? parseInt(el.style.borderTopWidth) : 0;

        if (ISIE8) e = event;

        // Browser with offsetX and offsetY
        if (typeof(e.offsetX) == 'number' && typeof(e.offsetY) == 'number') {
            x = e.offsetX;
            y = e.offsetY;

        // FF and other
        } else {
            x = 0;
            y = 0;

            while (el != document.body && el) {
                x += el.offsetLeft;
                y += el.offsetTop;

                el = el.offsetParent;
            }

            x = e.pageX - x;
            y = e.pageY - y;
        }

        return [x, y];
    }*/


   RGraph.getMouseXY = function(e)
   {
       var el      = e.target;
       var ca      = el;
       var caStyle = ca.style;
       var offsetX = 0;
       var offsetY = 0;
       var x;
       var y;
       var ISFIXED     = (ca.style.position == 'fixed');
       var borderLeft  = parseInt(caStyle.borderLeftWidth) || 0;
       var borderTop   = parseInt(caStyle.borderTopWidth) || 0;
       var paddingLeft = parseInt(caStyle.paddingLeft) || 0
       var paddingTop  = parseInt(caStyle.paddingTop) || 0
       var additionalX = borderLeft + paddingLeft;
       var additionalY = borderTop + paddingTop;


       if (typeof(e.offsetX) == 'number' && typeof(e.offsetY) == 'number') {

           if (ISFIXED) {
               if (ISOPERA) {
                   x = e.offsetX;
                   y = e.offsetY;

               } else if (ISWEBKIT) {
                   x = e.offsetX - paddingLeft - borderLeft;
                   y = e.offsetY - paddingTop - borderTop;

               } else if (ISIE) {
                   x = e.offsetX - paddingLeft;
                   y = e.offsetY - paddingTop;

               } else {
                   x = e.offsetX;
                   y = e.offsetY;
               }




           } else {




               if (!ISIE && !ISOPERA) {
                   x = e.offsetX - borderLeft - paddingLeft;
                   y = e.offsetY - borderTop - paddingTop;

               } else if (ISIE) {
                   x = e.offsetX - paddingLeft;
                   y = e.offsetY - paddingTop;

               } else {
                   x = e.offsetX;
                   y = e.offsetY;
               }
           }

       } else {

           if (typeof(el.offsetParent) != 'undefined') {
               do {
                   offsetX += el.offsetLeft;
                   offsetY += el.offsetTop;
               } while ((el = el.offsetParent));
           }

           x = e.pageX - offsetX - additionalX;
           y = e.pageY - offsetY - additionalY;

           x -= (2 * (parseInt(document.body.style.borderLeftWidth) || 0));
           y -= (2 * (parseInt(document.body.style.borderTopWidth) || 0));

           //x += (parseInt(caStyle.borderLeftWidth) || 0);
           //y += (parseInt(caStyle.borderTopWidth) || 0);
       }

       // We return a javascript array with x and y defined
       return [x, y];
   }




   /**
    * This function returns a two element array of the canvas x/y position in
    * relation to the page
    *
    * @param object canvas
    */
   RGraph.getCanvasXY = function (canvas)
   {
       var x  = 0;
       var y  = 0;
       var el = canvas; // !!!

       do {

           x += el.offsetLeft;
           y += el.offsetTop;

           // ACCOUNT FOR TABLES IN wEBkIT
           if (el.tagName.toLowerCase() == 'table' && (ISCHROME || ISSAFARI)) {
               x += parseInt(el.border) || 0;
               y += parseInt(el.border) || 0;
           }

           el = el.offsetParent;

       } while (el && el.tagName.toLowerCase() != 'body');


       var paddingLeft = canvas.style.paddingLeft ? parseInt(canvas.style.paddingLeft) : 0;
       var paddingTop  = canvas.style.paddingTop ? parseInt(canvas.style.paddingTop) : 0;
       var borderLeft  = canvas.style.borderLeftWidth ? parseInt(canvas.style.borderLeftWidth) : 0;
       var borderTop   = canvas.style.borderTopWidth  ? parseInt(canvas.style.borderTopWidth) : 0;

       if (navigator.userAgent.indexOf('Firefox') > 0) {
           x += parseInt(document.body.style.borderLeftWidth) || 0;
           y += parseInt(document.body.style.borderTopWidth) || 0;
       }

       return [x + paddingLeft + borderLeft, y + paddingTop + borderTop];
   }




   /**
    * This function determines whther a canvas is fixed (CSS positioning) or not. If not it returns
    * false. If it is then the element that is fixed is returned (it may be a parent of the canvas).
    *
    * @return Either false or the fixed positioned element
    */
   RGraph.isFixed = function (canvas)
   {
       var obj = canvas;
       var i = 0;

       while (obj && obj.tagName.toLowerCase() != 'body' && i < 99) {

           if (obj.style.position == 'fixed') {
               return obj;
           }

           obj = obj.offsetParent;
       }

       return false;
   }




   /**
    * Registers a graph object (used when the canvas is redrawn)
    *
    * @param object obj The object to be registered
    */
   RGraph.Register = function (obj)
   {
       // Checking this property ensures the object is only registered once
       if (!obj.Get('chart.noregister')) {
           // As of 21st/1/2012 the object registry is now used
           RGraph.ObjectRegistry.Add(obj);
           obj.Set('chart.noregister', true);
       }
   }




   /**
    * Causes all registered objects to be redrawn
    *
    * @param string An optional color to use to clear the canvas
    */
   RGraph.Redraw = function ()
   {
       var objectRegistry = RGraph.ObjectRegistry.objects.byCanvasID;

       // Get all of the canvas tags on the page
       var tags = document.getElementsByTagName('canvas');

       for (var i=0,len=tags.length; i<len; ++i) {
           if (tags[i].__object__ && tags[i].__object__.isRGraph) {

               // Only clear the canvas if it's not Trace'ing - this applies to the Line/Scatter Trace effects
               if (!tags[i].noclear) {
                   RGraph.Clear(tags[i], arguments[0] ? arguments[0] : null);
               }
           }
       }

       // Go through the object registry and redraw *all* of the canvas'es that have been registered
       for (var i=0,len=objectRegistry.length; i<len; ++i) {
           if (objectRegistry[i]) {
               var id = objectRegistry[i][0];
               objectRegistry[i][1].Draw();
           }
       }
   }




   /**
    * Causes all registered objects ON THE GIVEN CANVAS to be redrawn
    *
    * @param canvas object The canvas object to redraw
    * @param        bool   Optional boolean which defaults to true and determines whether to clear the canvas
    */
   RGraph.RedrawCanvas = function (canvas)
   {
       var objects = RGraph.ObjectRegistry.getObjectsByCanvasID(canvas.id);

       /**
        * First clear the canvas
        */
       if (!arguments[1] || (typeof(arguments[1]) == 'boolean' && !arguments[1] == false) ) {

           // TODO This function should really support passing a color as the second optional argument - which is then used in the below
           // call
           RGraph.Clear(canvas);
       }

       /**
        * Now redraw all the charts associated with that canvas
        */
       for (var i=0,len=objects.length; i<len; ++i) {
           if (objects[i]) {
               if (objects[i] && objects[i].isRGraph) { // Is it an RGraph object ??
                   objects[i].Draw();
               }
           }
       }
   }




   /**
    * This function draws the background for the bar chart, line chart and scatter chart.
    *
    * @param  object obj The graph object
    */
   RGraph.background.Draw = function (obj)
   {
       var RG           = RGraph;
       var ca = canvas  = obj.canvas;
       var co = context = obj.context;
       var prop         = obj.properties;

       var height       = 0;
       var gutterLeft   = obj.gutterLeft;
       var gutterRight  = obj.gutterRight;
       var gutterTop    = obj.gutterTop;
       var gutterBottom = obj.gutterBottom;
       var variant      = prop['chart.variant'];

       co.fillStyle = prop['chart.text.color'];

       // If it's a bar and 3D variant, translate
       if (variant == '3d') {
           co.save();
           co.translate(10, -5);
       }

       // X axis title
       if (typeof(prop['chart.title.xaxis']) == 'string' && prop['chart.title.xaxis'].length) {

           var size = prop['chart.text.size'] + 2;
           var font = prop['chart.text.font'];
           var bold = prop['chart.title.xaxis.bold'];

           if (typeof(prop['chart.title.xaxis.size']) == 'number') {
               size = prop['chart.title.xaxis.size'];
           }

           if (typeof(prop['chart.title.xaxis.font']) == 'string') {
               font = prop['chart.title.xaxis.font'];
           }

           var hpos = ((ca.width - gutterLeft - gutterRight) / 2) + gutterLeft;
           var vpos = ca.height - gutterBottom + 25;

           if (typeof(prop['chart.title.xaxis.pos']) == 'number') {
               vpos = ca.height - (gutterBottom * prop['chart.title.xaxis.pos']);
           }




           // Specifically specified X/Y positions
           if (typeof prop['chart.title.xaxis.x'] == 'number') {
               hpos = prop['chart.title.xaxis.x'];
           }

           if (typeof prop['chart.title.xaxis.y'] == 'number') {
               vpos = prop['chart.title.xaxis.y'];
           }




           RG.Text2(obj, {'font':font,
               'size':size,
               'x':hpos,
               'y':vpos,
               'text':prop['chart.title.xaxis'],
               'halign':'center',
               'valign':'center',
               'bold':bold,
               'tag': 'title xaxis'
           });
       }

       // Y axis title
       if (typeof(prop['chart.title.yaxis']) == 'string' && prop['chart.title.yaxis'].length) {

           var size  = prop['chart.text.size'] + 2;
           var font  = prop['chart.text.font'];
           var angle = 270;
           var bold  = prop['chart.title.yaxis.bold'];
           var color = prop['chart.title.yaxis.color'];

           if (typeof(prop['chart.title.yaxis.pos']) == 'number') {
               var yaxis_title_pos = prop['chart.title.yaxis.pos'] * gutterLeft;
           } else {
               var yaxis_title_pos = ((gutterLeft - 25) / gutterLeft) * gutterLeft;
           }

           if (typeof(prop['chart.title.yaxis.size']) == 'number') {
               size = prop['chart.title.yaxis.size'];
           }

           if (typeof(prop['chart.title.yaxis.font']) == 'string') {
               font = prop['chart.title.yaxis.font'];
           }

           if (prop['chart.title.yaxis.align'] == 'right' || prop['chart.title.yaxis.position'] == 'right') {
               angle = 90;
               yaxis_title_pos = prop['chart.title.yaxis.pos'] ? (ca.width - gutterRight) + (prop['chart.title.yaxis.pos'] * gutterRight) :
                       ca.width - gutterRight + prop['chart.text.size'] + 5;
           } else {
               yaxis_title_pos = yaxis_title_pos;
           }

           var y = ((ca.height - gutterTop - gutterBottom) / 2) + gutterTop;

           // Specifically specified X/Y positions
           if (typeof prop['chart.title.yaxis.x'] == 'number') {
               yaxis_title_pos = prop['chart.title.yaxis.x'];
           }

           if (typeof prop['chart.title.yaxis.y'] == 'number') {
               y = prop['chart.title.yaxis.y'];
           }

           co.fillStyle = color;
           RG.Text2(obj, {'font':font,
               'size':size,
               'x':yaxis_title_pos,
               'y':y,
               'valign':'center',
               'halign':'center',
               'angle':angle,
               'bold':bold,
               'text':prop['chart.title.yaxis'],
               'tag':'title yaxis'
           });
       }

       /**
        * If the background color is spec ified - draw that. It's a rectangle that fills the
        * entire are within the gutters
        */
       var bgcolor = prop['chart.background.color'];
       if (bgcolor) {
           co.fillStyle = bgcolor;
           co.fillRect(gutterLeft, gutterTop, ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);
       }

       /**
        * Draw horizontal background bars
        */
       co.beginPath(); // Necessary?

       co.fillStyle   = prop['chart.background.barcolor1'];
       co.strokeStyle = co.fillStyle;
       height = (ca.height - gutterBottom);

       for (var i=gutterTop; i<height ; i+=80) {
           co.fillRect(gutterLeft, i, ca.width - gutterLeft - gutterRight, Math.min(40, ca.height - gutterBottom - i) );
       }

       co.fillStyle   = prop['chart.background.barcolor2'];
       co.strokeStyle = co.fillStyle;
       height = (ca.height - gutterBottom);

       for (var i= (40 + gutterTop); i<height; i+=80) {
           co.fillRect(gutterLeft, i, ca.width - gutterLeft - gutterRight, i + 40 > (ca.height - gutterBottom) ? ca.height - (gutterBottom + i) : 40);
       }

       //context.stroke();
       co.beginPath();


       // Draw the background grid
       if (prop['chart.background.grid']) {

           // If autofit is specified, use the .numhlines and .numvlines along with the width to work
           // out the hsize and vsize
           if (prop['chart.background.grid.autofit']) {

               /**
                * Align the grid to the tickmarks
                */
               if (prop['chart.background.grid.autofit.align']) {

                   // Align the horizontal lines
                   obj.Set('chart.background.grid.autofit.numhlines', prop['chart.ylabels.count']);

                   // Align the vertical lines for the line
                   if (obj.type == 'line') {
                       if (prop['chart.labels'] && prop['chart.labels'].length) {
                           obj.Set('chart.background.grid.autofit.numvlines', prop['chart.labels'].length - 1);
                       } else {
                           obj.Set('chart.background.grid.autofit.numvlines', obj.data[0].length - 1);
                       }

                       // Align the vertical lines for the bar
                   } else if (obj.type == 'bar' && prop['chart.labels'] && prop['chart.labels'].length) {
                       obj.Set('chart.background.grid.autofit.numvlines', prop['chart.labels'].length);
                   }
               }

               var vsize = ((ca.width - gutterLeft - gutterRight)) / prop['chart.background.grid.autofit.numvlines'];
               var hsize = (ca.height - gutterTop - gutterBottom) / prop['chart.background.grid.autofit.numhlines'];

               obj.Set('chart.background.grid.vsize', vsize);
               obj.Set('chart.background.grid.hsize', hsize);
           }

           co.beginPath();
           co.lineWidth   = prop['chart.background.grid.width'] ? prop['chart.background.grid.width'] : 1;
           co.strokeStyle = prop['chart.background.grid.color'];

           // Dashed background grid
           if (prop['chart.background.grid.dashed'] && typeof co.setLineDash == 'function') {
               co.setLineDash([3,2]);
           }

           // Dotted background grid
           if (prop['chart.background.grid.dotted'] && typeof co.setLineDash == 'function') {
               co.setLineDash([1,2]);
           }


           // Draw the horizontal lines
           if (prop['chart.background.grid.hlines']) {
               height = (ca.height - gutterBottom)
               for (y=gutterTop; y<height; y+=prop['chart.background.grid.hsize']) {
                   context.moveTo(gutterLeft, Math.round(y));
                   context.lineTo(ca.width - gutterRight, Math.round(y));
               }
           }

           if (prop['chart.background.grid.vlines']) {
               // Draw the vertical lines
               var width = (ca.width - gutterRight)
               for (x=gutterLeft; x<=width; x+=prop['chart.background.grid.vsize']) {
                   co.moveTo(Math.round(x), gutterTop);
                   co.lineTo(Math.round(x), ca.height - gutterBottom);
               }
           }

           if (prop['chart.background.grid.border']) {
               // Make sure a rectangle, the same colour as the grid goes around the graph
               co.strokeStyle = prop['chart.background.grid.color'];
               co.strokeRect(Math.round(gutterLeft), Math.round(gutterTop), ca.width - gutterLeft - gutterRight, ca.height - gutterTop - gutterBottom);
           }
       }

       context.stroke();

       // Reset the line dash
       if (typeof co.setLineDash == 'function') {
           co.setLineDash([1,0]);
       }

       // If it's a bar and 3D variant, translate
       if (variant == '3d') {
           co.restore();
       }

       // Draw the title if one is set
       if ( typeof(prop['chart.title']) == 'string') {

           if (obj.type == 'gantt') {
               gutterTop -= 10;
           }

           RG.DrawTitle(obj,
                   prop['chart.title'],
                   gutterTop,
                   null,
                   prop['chart.title.size'] ? prop['chart.title.size'] : prop['chart.text.size'] + 2);
       }

       co.stroke();
   }




   /**
    * Makes a clone of an object
    *
    * @param obj val The object to clone
    */
   RGraph.array_clone = function (obj)
   {
       var RG = RGraph;

       if(obj == null || typeof(obj) != 'object') {
           return obj;
       }

       var temp = [];

       for (var i=0,len=obj.length;i<len; ++i) {

           if (typeof(obj[i]) == 'number') {
               temp[i] = (function (arg) {return Number(arg);})(obj[i]);
           } else if (typeof(obj[i]) == 'string') {
               temp[i] = (function (arg) {return String(arg);})(obj[i]);
           } else if (typeof(obj[i]) == 'function') {
               temp[i] = obj[i];

           } else {
               temp[i] = RG.array_clone(obj[i]);
           }
       }

       return temp;
   }




   /**
    * Formats a number with thousand seperators so it's easier to read
    *
    * @param  integer obj The chart object
    * @param  integer num The number to format
    * @param  string      The (optional) string to prepend to the string
    * @param  string      The (optional) string to append to the string
    * @return string      The formatted number
    */
   RGraph.number_format = function (obj, num)
   {
       var RG   = RGraph;
       var ca   = obj.canvas;
       var co   = obj.context;
       var prop = obj.properties;

       var i;
       var prepend = arguments[2] ? String(arguments[2]) : '';
       var append  = arguments[3] ? String(arguments[3]) : '';
       var output  = '';
       var decimal = '';
       var decimal_seperator  = typeof(prop['chart.scale.point']) == 'string' ? prop['chart.scale.point'] : '.';
       var thousand_seperator = typeof(prop['chart.scale.thousand']) == 'string' ? prop['chart.scale.thousand'] : ',';
       RegExp.$1   = '';
       var i,j;

       if (typeof(prop['chart.scale.formatter']) == 'function') {
           return prop['chart.scale.formatter'](obj, num);
       }

       // Ignore the preformatted version of "1e-2"
       if (String(num).indexOf('e') > 0) {
           return String(prepend + String(num) + append);
       }

       // We need then number as a string
       num = String(num);

       // Take off the decimal part - we re-append it later
       if (num.indexOf('.') > 0) {
           var tmp = num;
           num     = num.replace(/\.(.*)/, ''); // The front part of the number
           decimal = tmp.replace(/(.*)\.(.*)/, '$2'); // The decimal part of the number
       }

       // Thousand seperator
       //var seperator = arguments[1] ? String(arguments[1]) : ',';
       var seperator = thousand_seperator;

       /**
        * Work backwards adding the thousand seperators
        */
       var foundPoint;
       for (i=(num.length - 1),j=0; i>=0; j++,i--) {
           var character = num.charAt(i);

           if ( j % 3 == 0 && j != 0) {
               output += seperator;
           }

           /**
            * Build the output
            */
           output += character;
       }

       /**
        * Now need to reverse the string
        */
       var rev = output;
       output = '';
       for (i=(rev.length - 1); i>=0; i--) {
           output += rev.charAt(i);
       }

       // Tidy up
       //output = output.replace(/^-,/, '-');
       if (output.indexOf('-' + prop['chart.scale.thousand']) == 0) {
           output = '-' + output.substr(('-' + prop['chart.scale.thousand']).length);
       }

       // Reappend the decimal
       if (decimal.length) {
           output =  output + decimal_seperator + decimal;
           decimal = '';
           RegExp.$1 = '';
       }

       // Minor bugette
       if (output.charAt(0) == '-') {
           output = output.replace(/-/, '');
           prepend = '-' + prepend;
       }

       return prepend + output + append;
   }




   /**
    * Draws horizontal coloured bars on something like the bar, line or scatter
    */
   RGraph.DrawBars = function (obj)
   {
       var prop  = obj.properties;
       var co    = obj.context;
       var ca    = obj.canvas;
       var RG    = RGraph;
       var hbars = prop['chart.background.hbars'];

       if (hbars === null) {
           return;
       }

       /**
        * Draws a horizontal bar
        */
       co.beginPath();

       for (i=0,len=hbars.length; i<len; ++i) {

           var start  = hbars[i][0];
           var length = hbars[i][1];
           var color  = hbars[i][2];


           // Perform some bounds checking
           if(RG.is_null(start))start = obj.scale2.max
           if (start > obj.scale2.max) start = obj.scale2.max;
           if (RG.is_null(length)) length = obj.scale2.max - start;
           if (start + length > obj.scale2.max) length = obj.scale2.max - start;
           if (start + length < (-1 * obj.scale2.max) ) length = (-1 * obj.scale2.max) - start;

           if (prop['chart.xaxispos'] == 'center' && start == obj.scale2.max && length < (obj.scale2.max * -2)) {
               length = obj.scale2.max * -2;
           }


           /**
            * Draw the bar
            */
           var x = prop['chart.gutter.left'];
           var y = obj.getYCoord(start);
           var w = ca.width - prop['chart.gutter.left'] - prop['chart.gutter.right'];
           var h = obj.getYCoord(start + length) - y;

           // Accommodate Opera :-/
           if (ISOPERA != -1 && prop['chart.xaxispos'] == 'center' && h < 0) {
               h *= -1;
               y = y - h;
           }

           /**
            * Account for X axis at the top
            */
           if (prop['chart.xaxispos'] == 'top') {
               y  = ca.height - y;
               h *= -1;
           }

           co.fillStyle = color;
           co.fillRect(x, y, w, h);
       }
       /*





        // If the X axis is at the bottom, and a negative max is given, warn the user
        if (obj.Get('chart.xaxispos') == 'bottom' && (hbars[i][0] < 0 || (hbars[i][1] + hbars[i][1] < 0)) ) {
        alert('[' + obj.type.toUpperCase() + ' (ID: ' + obj.id + ') BACKGROUND HBARS] You have a negative value in one of your background hbars values, whilst the X axis is in the center');
        }

        var ystart = (obj.grapharea - (((hbars[i][0] - obj.scale2.min) / (obj.scale2.max - obj.scale2.min)) * obj.grapharea));
        //var height = (Math.min(hbars[i][1], obj.max - hbars[i][0]) / (obj.scale2.max - obj.scale2.min)) * obj.grapharea;
        var height = obj.getYCoord(hbars[i][0]) - obj.getYCoord(hbars[i][1]);

        // Account for the X axis being in the center
        if (obj.Get('chart.xaxispos') == 'center') {
        ystart /= 2;
        //height /= 2;
        }

        ystart += obj.Get('chart.gutter.top')

        var x = obj.Get('chart.gutter.left');
        var y = ystart - height;
        var w = obj.canvas.width - obj.Get('chart.gutter.left') - obj.Get('chart.gutter.right');
        var h = height;

        // Accommodate Opera :-/
        if (navigator.userAgent.indexOf('Opera') != -1 && obj.Get('chart.xaxispos') == 'center' && h < 0) {
        h *= -1;
        y = y - h;
        }

        /**
        * Account for X axis at the top
        */
       //if (obj.Get('chart.xaxispos') == 'top') {
       //    y  = obj.canvas.height - y;
       //    h *= -1;
       //}

       //obj.context.fillStyle = hbars[i][2];
       //obj.context.fillRect(x, y, w, h);
       //}
   }




   /**
    * Draws in-graph labels.
    *
    * @param object obj The graph object
    */
   RGraph.DrawInGraphLabels = function (obj)
   {
       var RG      = RGraph;
       var ca      = obj.canvas;
       var co      = obj.context;
       var prop    = obj.properties;
       var labels  = prop['chart.labels.ingraph'];
       var labels_processed = [];

       // Defaults
       var fgcolor   = 'black';
       var bgcolor   = 'white';
       var direction = 1;

       if (!labels) {
           return;
       }

       /**
        * Preprocess the labels array. Numbers are expanded
        */
       for (var i=0,len=labels.length; i<len; i+=1) {
           if (typeof(labels[i]) == 'number') {
               for (var j=0; j<labels[i]; ++j) {
                   labels_processed.push(null);
               }
           } else if (typeof(labels[i]) == 'string' || typeof(labels[i]) == 'object') {
               labels_processed.push(labels[i]);

           } else {
               labels_processed.push('');
           }
       }

       /**
        * Turn off any shadow
        */
       RG.NoShadow(obj);

       if (labels_processed && labels_processed.length > 0) {

           for (var i=0,len=labels_processed.length; i<len; ++i) {
               if (labels_processed[i]) {
                   var coords = obj.coords[i];

                   if (coords && coords.length > 0) {
                       var x      = (obj.type == 'bar' ? coords[0] + (coords[2] / 2) : coords[0]);
                       var y      = (obj.type == 'bar' ? coords[1] + (coords[3] / 2) : coords[1]);
                       var length = typeof(labels_processed[i][4]) == 'number' ? labels_processed[i][4] : 25;

                       co.beginPath();
                       co.fillStyle   = 'black';
                       co.strokeStyle = 'black';


                       if (obj.type == 'bar') {

                           /**
                            * X axis at the top
                            */
                           if (obj.Get('chart.xaxispos') == 'top') {
                               length *= -1;
                           }

                           if (prop['chart.variant'] == 'dot') {
                               co.moveTo(Math.round(x), obj.coords[i][1] - 5);
                               co.lineTo(Math.round(x), obj.coords[i][1] - 5 - length);

                               var text_x = Math.round(x);
                               var text_y = obj.coords[i][1] - 5 - length;

                           } else if (prop['chart.variant'] == 'arrow') {
                               co.moveTo(Math.round(x), obj.coords[i][1] - 5);
                               co.lineTo(Math.round(x), obj.coords[i][1] - 5 - length);

                               var text_x = Math.round(x);
                               var text_y = obj.coords[i][1] - 5 - length;

                           } else {

                               co.arc(Math.round(x), y, 2.5, 0, 6.28, 0);
                               co.moveTo(Math.round(x), y);
                               co.lineTo(Math.round(x), y - length);

                               var text_x = Math.round(x);
                               var text_y = y - length;
                           }

                           co.stroke();
                           co.fill();


                       } else if (obj.type == 'line') {

                           if (
                                   typeof(labels_processed[i]) == 'object' &&
                                           typeof(labels_processed[i][3]) == 'number' &&
                                           labels_processed[i][3] == -1
                                   ) {

                               co.moveTo(Math.round(x), y + 5);
                               co.lineTo(Math.round(x), y + 5 + length);

                               co.stroke();
                               co.beginPath();

                               // This draws the arrow
                               co.moveTo(Math.round(x), y + 5);
                               co.lineTo(Math.round(x) - 3, y + 10);
                               co.lineTo(Math.round(x) + 3, y + 10);
                               co.closePath();

                               var text_x = x;
                               var text_y = y + 5 + length;

                           } else {

                               var text_x = x;
                               var text_y = y - 5 - length;

                               co.moveTo(Math.round(x), y - 5);
                               co.lineTo(Math.round(x), y - 5 - length);

                               co.stroke();
                               co.beginPath();

                               // This draws the arrow
                               co.moveTo(Math.round(x), y - 5);
                               co.lineTo(Math.round(x) - 3, y - 10);
                               co.lineTo(Math.round(x) + 3, y - 10);
                               co.closePath();
                           }

                           co.fill();
                       }

                       // Taken out on the 10th Nov 2010 - unnecessary
                       //var width = context.measureText(labels[i]).width;

                       co.beginPath();

                       // Fore ground color
                       co.fillStyle = (typeof(labels_processed[i]) == 'object' && typeof(labels_processed[i][1]) == 'string') ? labels_processed[i][1] : 'black';

                       RG.Text2(obj,{'font':prop['chart.text.font'],
                           'size':prop['chart.text.size'],
                           'x':text_x,
                           'y':text_y,
                           'text': (typeof(labels_processed[i]) == 'object' && typeof(labels_processed[i][0]) == 'string') ? labels_processed[i][0] : labels_processed[i],
                           'valign': 'bottom',
                           'halign':'center',
                           'bounding':true,
                           'bounding.fill': (typeof(labels_processed[i]) == 'object' && typeof(labels_processed[i][2]) == 'string') ? labels_processed[i][2] : 'white',
                           'tag':'labels ingraph'
                       });
                       co.fill();
                   }
               }
           }
       }
   }




   /**
    * This function "fills in" key missing properties that various implementations lack
    *
    * @param object e The event object
    */
   RGraph.FixEventObject = function (e)
   {
       if (ISOLD) {
           var e = event;

           e.pageX  = (event.clientX + document.body.scrollLeft);
           e.pageY  = (event.clientY + document.body.scrollTop);
           e.target = event.srcElement;

           if (!document.body.scrollTop && document.documentElement.scrollTop) {
               e.pageX += parseInt(document.documentElement.scrollLeft);
               e.pageY += parseInt(document.documentElement.scrollTop);
           }
       }


       // Any browser that doesn't implement stopPropagation() (MSIE)
       if (!e.stopPropagation) {
           e.stopPropagation = function () {window.event.cancelBubble = true;}
       }

       return e;
   }




   /**
    * Thisz function hides the crosshairs coordinates
    */
   RGraph.HideCrosshairCoords = function ()
   {
       var RG  = RGraph;
       var div = RG.Registry.Get('chart.coordinates.coords.div');

       if (   div
               && div.style.opacity == 1
               && div.__object__.Get('chart.crosshairs.coords.fadeout')
               ) {

           var style = RG.Registry.Get('chart.coordinates.coords.div').style;

           setTimeout(function() {style.opacity = 0.9;}, 25);
           setTimeout(function() {style.opacity = 0.8;}, 50);
           setTimeout(function() {style.opacity = 0.7;}, 75);
           setTimeout(function() {style.opacity = 0.6;}, 100);
           setTimeout(function() {style.opacity = 0.5;}, 125);
           setTimeout(function() {style.opacity = 0.4;}, 150);
           setTimeout(function() {style.opacity = 0.3;}, 175);
           setTimeout(function() {style.opacity = 0.2;}, 200);
           setTimeout(function() {style.opacity = 0.1;}, 225);
           setTimeout(function() {style.opacity = 0;}, 250);
           setTimeout(function() {style.display = 'none';}, 275);
       }
   }




   /**
    * Draws the3D axes/background
    */
   RGraph.Draw3DAxes = function (obj)
   {
       var prop = obj.properties;
       var co   = obj.context;
       var ca   = obj.canvas;

       var gutterLeft    = prop['chart.gutter.left'];
       var gutterRight   = prop['chart.gutter.right'];
       var gutterTop     = prop['chart.gutter.top'];
       var gutterBottom  = prop['chart.gutter.bottom'];


       co.strokeStyle = '#aaa';
       co.fillStyle = '#ddd';

       // Draw the vertical left side
       co.beginPath();
       co.moveTo(gutterLeft, gutterTop);
       co.lineTo(gutterLeft + 10, gutterTop - 5);
       co.lineTo(gutterLeft + 10, ca.height - gutterBottom - 5);
       co.lineTo(gutterLeft, ca.height - gutterBottom);
       co.closePath();

       co.stroke();
       co.fill();

       // Draw the bottom floor
       co.beginPath();
       co.moveTo(gutterLeft, ca.height - gutterBottom);
       co.lineTo(gutterLeft + 10, ca.height - gutterBottom - 5);
       co.lineTo(ca.width - gutterRight + 10,  ca.height - gutterBottom - 5);
       co.lineTo(ca.width - gutterRight, ca.height - gutterBottom);
       co.closePath();

       co.stroke();
       co.fill();
   }





   /**
    * This function attempts to "fill in" missing functions from the canvas
    * context object. Only two at the moment - measureText() nd fillText().
    *
    * @param object context The canvas 2D context
    */
   RGraph.OldBrowserCompat = function (co)
   {
       if (!co) {
           return;
       }

       if (!co.measureText) {

           // This emulates the measureText() function
           co.measureText = function (text)
           {
               var textObj = document.createElement('DIV');
               textObj.innerHTML = text;
               textObj.style.position = 'absolute';
               textObj.style.top = '-100px';
               textObj.style.left = 0;
               document.body.appendChild(textObj);

               var width = {width: textObj.offsetWidth};

               textObj.style.display = 'none';

               return width;
           }
       }

       if (!co.fillText) {
           // This emulates the fillText() method
           co.fillText    = function (text, targetX, targetY)
           {
               return false;
           }
       }

       // If IE8, add addEventListener()
       if (!co.canvas.addEventListener) {
           window.addEventListener = function (ev, func, bubble)
           {
               return this.attachEvent('on' + ev, func);
           }

           co.canvas.addEventListener = function (ev, func, bubble)
           {
               return this.attachEvent('on' + ev, func);
           }
       }
   }




   /**
    * Draws a rectangle with curvy corners
    *
    * @param co object The context
    * @param x number The X coordinate (top left of the square)
    * @param y number The Y coordinate (top left of the square)
    * @param w number The width of the rectangle
    * @param h number The height of the rectangle
    * @param   number The radius of the curved corners
    * @param   boolean Whether the top left corner is curvy
    * @param   boolean Whether the top right corner is curvy
    * @param   boolean Whether the bottom right corner is curvy
    * @param   boolean Whether the bottom left corner is curvy
    */
   RGraph.strokedCurvyRect = function (co, x, y, w, h)
   {
       // The corner radius
       var r = arguments[5] ? arguments[5] : 3;

       // The corners
       var corner_tl = (arguments[6] || arguments[6] == null) ? true : false;
       var corner_tr = (arguments[7] || arguments[7] == null) ? true : false;
       var corner_br = (arguments[8] || arguments[8] == null) ? true : false;
       var corner_bl = (arguments[9] || arguments[9] == null) ? true : false;

       co.beginPath();

       // Top left side
       co.moveTo(x + (corner_tl ? r : 0), y);
       co.lineTo(x + w - (corner_tr ? r : 0), y);

       // Top right corner
       if (corner_tr) {
           co.arc(x + w - r, y + r, r, PI + HALFPI, TWOPI, false);
       }

       // Top right side
       co.lineTo(x + w, y + h - (corner_br ? r : 0) );

       // Bottom right corner
       if (corner_br) {
           co.arc(x + w - r, y - r + h, r, TWOPI, HALFPI, false);
       }

       // Bottom right side
       co.lineTo(x + (corner_bl ? r : 0), y + h);

       // Bottom left corner
       if (corner_bl) {
           co.arc(x + r, y - r + h, r, HALFPI, PI, false);
       }

       // Bottom left side
       co.lineTo(x, y + (corner_tl ? r : 0) );

       // Top left corner
       if (corner_tl) {
           co.arc(x + r, y + r, r, PI, PI + HALFPI, false);
       }

       co.stroke();
   }




   /**
    * Draws a filled rectangle with curvy corners
    *
    * @param context object The context
    * @param x       number The X coordinate (top left of the square)
    * @param y       number The Y coordinate (top left of the square)
    * @param w       number The width of the rectangle
    * @param h       number The height of the rectangle
    * @param         number The radius of the curved corners
    * @param         boolean Whether the top left corner is curvy
    * @param         boolean Whether the top right corner is curvy
    * @param         boolean Whether the bottom right corner is curvy
    * @param         boolean Whether the bottom left corner is curvy
    */
   RGraph.filledCurvyRect = function (co, x, y, w, h)
   {
       // The corner radius
       var r = arguments[5] ? arguments[5] : 3;

       // The corners
       var corner_tl = (arguments[6] || arguments[6] == null) ? true : false;
       var corner_tr = (arguments[7] || arguments[7] == null) ? true : false;
       var corner_br = (arguments[8] || arguments[8] == null) ? true : false;
       var corner_bl = (arguments[9] || arguments[9] == null) ? true : false;

       co.beginPath();

       // First draw the corners

       // Top left corner
       if (corner_tl) {
           co.moveTo(x + r, y + r);
           co.arc(x + r, y + r, r, PI, PI + HALFPI, false);
       } else {
           co.fillRect(x, y, r, r);
       }

       // Top right corner
       if (corner_tr) {
           co.moveTo(x + w - r, y + r);
           co.arc(x + w - r, y + r, r, PI + HALFPI, 0, false);
       } else {
           co.moveTo(x + w - r, y);
           co.fillRect(x + w - r, y, r, r);
       }


       // Bottom right corner
       if (corner_br) {
           co.moveTo(x + w - r, y + h - r);
           co.arc(x + w - r, y - r + h, r, 0, HALFPI, false);
       } else {
           co.moveTo(x + w - r, y + h - r);
           co.fillRect(x + w - r, y + h - r, r, r);
       }

       // Bottom left corner
       if (corner_bl) {
           co.moveTo(x + r, y + h - r);
           co.arc(x + r, y - r + h, r, HALFPI, PI, false);
       } else {
           co.moveTo(x, y + h - r);
           co.fillRect(x, y + h - r, r, r);
       }

       // Now fill it in
       co.fillRect(x + r, y, w - r - r, h);
       co.fillRect(x, y + r, r + 1, h - r - r);
       co.fillRect(x + w - r - 1, y + r, r + 1, h - r - r);

       co.fill();
   }




   /**
    * Hides the zoomed canvas
    */
   RGraph.HideZoomedCanvas = function ()
   {
       var interval = 15;
       var frames   = 10;

       if (typeof(__zoomedimage__) == 'object') {
           var obj  = __zoomedimage__.obj;
           var prop = obj.properties;
       } else {
           return;
       }

       if (prop['chart.zoom.fade.out']) {
           for (var i=frames,j=1; i>=0; --i, ++j) {
               if (typeof(__zoomedimage__) == 'object') {
                   setTimeout("__zoomedimage__.style.opacity = " + String(i / 10), j * interval);
               }
           }

           if (typeof(__zoomedbackground__) == 'object') {
               setTimeout("__zoomedbackground__.style.opacity = " + String(i / frames), j * interval);
           }
       }

       if (typeof(__zoomedimage__) == 'object') {
           setTimeout("__zoomedimage__.style.display = 'none'", prop['chart.zoom.fade.out'] ? (frames * interval) + 10 : 0);
       }

       if (typeof(__zoomedbackground__) == 'object') {
           setTimeout("__zoomedbackground__.style.display = 'none'", prop['chart.zoom.fade.out'] ? (frames * interval) + 10 : 0);
       }
   }




   /**
    * Adds an event handler
    *
    * @param object obj   The graph object
    * @param string event The name of the event, eg ontooltip
    * @param object func  The callback function
    */
   RGraph.AddCustomEventListener = function (obj, name, func)
   {
       var RG = RGraph;

       if (typeof(RG.events[obj.uid]) == 'undefined') {
           RG.events[obj.uid] = [];
       }

       RG.events[obj.uid].push([obj, name, func]);

       return RG.events[obj.uid].length - 1;
   }




   /**
    * Used to fire one of the RGraph custom events
    *
    * @param object obj   The graph object that fires the event
    * @param string event The name of the event to fire
    */
   RGraph.FireCustomEvent = function (obj, name)
   {
       var RG = RGraph;

       if (obj && obj.isRGraph) {

           // New style of adding custom events
           if (obj[name]) {
               (obj[name])(obj);
           }

           var uid = obj.uid;

           if (   typeof(uid) == 'string'
                   && typeof(RG.events) == 'object'
                   && typeof(RG.events[uid]) == 'object'
                   && RG.events[uid].length > 0) {

               for(var j=0; j<RG.events[uid].length; ++j) {
                   if (RG.events[uid][j] && RG.events[uid][j][1] == name) {
                       RG.events[uid][j][2](obj);
                   }
               }
           }
       }
   }




   /**
    * If you prefer, you can use the SetConfig() method to set the configuration information
    * for your chart. You may find that setting the configuration this way eases reuse.
    *
    * @param object obj    The graph object
    * @param object config The graph configuration information
    */
   RGraph.SetConfig = function (obj, config)
   {
       for (i in config) {
           if (typeof(i) == 'string') {
               obj.Set(i, config[i]);
           }
       }

       return obj;
   }




   /**
    * Clears all the custom event listeners that have been registered
    *
    * @param    string Limits the clearing to this object ID
    */
   RGraph.RemoveAllCustomEventListeners = function ()
   {
       var RG = RGraph;
       var id = arguments[0];

       if (id && RG.events[id]) {
           RG.events[id] = [];
       } else {
           RG.events = [];
       }
   }




   /**
    * Clears a particular custom event listener
    *
    * @param object obj The graph object
    * @param number i   This is the index that is return by .AddCustomEventListener()
    */
   RGraph.RemoveCustomEventListener = function (obj, i)
   {
       var RG = RGraph;

       if (   typeof(RG.events) == 'object'
               && typeof(RG.events[obj.id]) == 'object'
               && typeof(RG.events[obj.id][i]) == 'object') {

           RG.events[obj.id][i] = null;
       }
   }




   /**
    * This draws the background
    *
    * @param object obj The graph object
    */
   RGraph.DrawBackgroundImage = function (obj)
   {
       var prop = obj.properties;
       var ca   = obj.canvas;
       var co   = obj.context;
       var RG   = RGraph;

       if (typeof(prop['chart.background.image']) == 'string') {
           if (typeof(ca.__rgraph_background_image__) == 'undefined') {
               var img = new Image();
               img.__object__  = obj;
               img.__canvas__  = ca;
               img.__context__ = co;
               img.src         = obj.Get('chart.background.image');

               ca.__rgraph_background_image__ = img;
           } else {
               img = ca.__rgraph_background_image__;
           }

           // When the image has loaded - redraw the canvas
           img.onload = function ()
           {
               obj.__rgraph_background_image_loaded__ = true;
               RG.Clear(ca);
               RG.RedrawCanvas(ca);
           }

           var gutterLeft   = obj.gutterLeft;
           var gutterRight  = obj.gutterRight;
           var gutterTop    = obj.gutterTop;
           var gutterBottom = obj.gutterBottom;
           var stretch      = prop['chart.background.image.stretch'];
           var align        = prop['chart.background.image.align'];

           // Handle chart.background.image.align
           if (typeof(align) == 'string') {
               if (align.indexOf('right') != -1) {
                   var x = ca.width - img.width - gutterRight;
               } else {
                   var x = gutterLeft;
               }

               if (align.indexOf('bottom') != -1) {
                   var y = ca.height - img.height - gutterBottom;
               } else {
                   var y = gutterTop;
               }
           } else {
               var x = gutterLeft || 25;
               var y = gutterTop || 25;
           }

           // X/Y coords take precedence over the align
           var x = typeof(prop['chart.background.image.x']) == 'number' ? prop['chart.background.image.x'] : x;
           var y = typeof(prop['chart.background.image.y']) == 'number' ? prop['chart.background.image.y'] : y;
           var w = stretch ? ca.width - gutterLeft - gutterRight : img.width;
           var h = stretch ? ca.height - gutterTop - gutterBottom : img.height;

           /**
            * You can now specify the width and height of the image
            */
           if (typeof(prop['chart.background.image.w']) == 'number') w  = prop['chart.background.image.w'];
           if (typeof(prop['chart.background.image.h']) == 'number') h = prop['chart.background.image.h'];

           co.drawImage(img,x,y,w, h);
       }
   }




   /**
    * This function determines wshether an object has tooltips or not
    *
    * @param object obj The chart object
    */
   RGraph.hasTooltips = function (obj)
   {
       var prop = obj.properties;

       if (typeof(prop['chart.tooltips']) == 'object' && prop['chart.tooltips']) {
           for (var i=0,len=prop['chart.tooltips'].length; i<len; ++i) {
               if (!RGraph.is_null(obj.Get('chart.tooltips')[i])) {
                   return true;
               }
           }
       } else if (typeof(prop['chart.tooltips']) == 'function') {
           return true;
       }

       return false;
   }




   /**
    * This function creates a (G)UID which can be used to identify objects.
    *
    * @return string (g)uid The (G)UID
    */
   RGraph.CreateUID = function ()
   {
       return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c)
       {
           var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
           return v.toString(16);
       });
   }



   /**
    * This is the new object registry, used to facilitate multiple objects per canvas.
    *
    * @param object obj The object to register
    */
   RGraph.ObjectRegistry.Add = function (obj)
   {
       var uid = obj.uid;
       var id  = obj.canvas.id;
       var RG = RGraph;

       /**
        * Index the objects by UID
        */
       RG.ObjectRegistry.objects.byUID.push([uid, obj]);

       /**
        * Index the objects by the canvas that they're drawn on
        */
       RG.ObjectRegistry.objects.byCanvasID.push([id, obj]);
   }




   /**
    * Remove an object from the object registry
    *
    * @param object obj The object to remove.
    */
   RGraph.ObjectRegistry.Remove = function (obj)
   {
       var id  = obj.id;
       var uid = obj.uid;
       var RG  = RGraph;

       for (var i=0; i<RG.ObjectRegistry.objects.byUID.length; ++i) {
           if (RG.ObjectRegistry.objects.byUID[i] && RG.ObjectRegistry.objects.byUID[i][1].uid == uid) {
               RG.ObjectRegistry.objects.byUID[i] = null;
           }
       }


       for (var i=0; i<RG.ObjectRegistry.objects.byCanvasID.length; ++i) {
           if (   RG.ObjectRegistry.objects.byCanvasID[i]
                   && RG.ObjectRegistry.objects.byCanvasID[i][1]
                   && RG.ObjectRegistry.objects.byCanvasID[i][1].uid == uid) {

               RG.ObjectRegistry.objects.byCanvasID[i] = null;
           }
       }

   }




   /**
    * Removes all objects from the ObjectRegistry. If either the ID of a canvas is supplied,
    * or the canvas itself, then only objects pertaining to that canvas are cleared.
    *
    * @param mixed   Either a canvas object (as returned by document.getElementById()
    *                or the ID of a canvas (ie a string)
    */
   RGraph.ObjectRegistry.Clear = function ()
   {
       var RG = RGraph;

       // If an ID is supplied restrict the learing to that
       if (arguments[0]) {
           var id      = (typeof(arguments[0]) == 'object' ? arguments[0].id : arguments[0]);
           var objects = RG.ObjectRegistry.getObjectsByCanvasID(id);

           for (var i=0; i<objects.length; ++i) {
               RG.ObjectRegistry.Remove(objects[i]);
           }

       } else {

           RG.ObjectRegistry.objects            = {};
           RG.ObjectRegistry.objects.byUID      = [];
           RG.ObjectRegistry.objects.byCanvasID = [];
       }
   }




   /**
    * Lists all objects in the ObjectRegistry
    *
    * @param boolean ret Whether to return the list or alert() it
    */
   RGraph.ObjectRegistry.List = function ()
   {
       var list = [];
       var RG   = RGraph;

       for (var i=0,len=RG.ObjectRegistry.objects.byUID.length; i<len; ++i) {
           if (RG.ObjectRegistry.objects.byUID[i]) {
               list.push(RG.ObjectRegistry.objects.byUID[i][1].type);
           }
       }

       if (arguments[0]) {
           return list;
       } else {
           p(list);
       }
   }




   /**
    * Clears the ObjectRegistry of objects that are of a certain given type
    *
    * @param type string The type to clear
    */
   RGraph.ObjectRegistry.ClearByType = function (type)
   {
       var RG      = RGraph;
       var objects = RG.ObjectRegistry.objects.byUID;

       for (var i=0; i<objects.length; ++i) {
           if (objects[i]) {
               var uid = objects[i][0];
               var obj = objects[i][1];

               if (obj && obj.type == type) {
                   RG.ObjectRegistry.Remove(obj);
               }
           }
       }
   }




   /**
    * This function provides an easy way to go through all of the objects that are held in the
    * Registry
    *
    * @param func function This function is run for every object. Its passed the object as an argument
    * @param string type Optionally, you can pass a type of object to look for
    */
   RGraph.ObjectRegistry.Iterate = function (func)
   {
       var objects = RGraph.ObjectRegistry.objects.byUID;

       for (var i=0; i<objects.length; ++i) {

           if (typeof arguments[1] == 'string') {

               var types = arguments[1].split(/,/);

               for (var j=0; j<types.length; ++j) {
                   if (types[j] == objects[i][1].type) {
                       func(objects[i][1]);
                   }
               }
           } else {
               func(objects[i][1]);
           }
       }
   }




   /**
    * Retrieves all objects for a given canvas id
    *
    * @patarm id string The canvas ID to get objects for.
    */
   RGraph.ObjectRegistry.getObjectsByCanvasID = function (id)
   {
       var store = RGraph.ObjectRegistry.objects.byCanvasID;
       var ret = [];

       // Loop through all of the objects and return the appropriate ones
       for (var i=0; i<store.length; ++i) {
           if (store[i] && store[i][0] == id ) {
               ret.push(store[i][1]);
           }
       }

       return ret;
   }




   /**
    * Retrieves the relevant object based on the X/Y position.
    *
    * @param  object e The event object
    * @return object   The applicable (if any) object
    */
   RGraph.ObjectRegistry.getFirstObjectByXY =
           RGraph.ObjectRegistry.getObjectByXY = function (e)
           {
               var canvas  = e.target;
               var ret     = null;
               var objects = RGraph.ObjectRegistry.getObjectsByCanvasID(canvas.id);

               for (var i=(objects.length - 1); i>=0; --i) {

                   var obj = objects[i].getObjectByXY(e);

                   if (obj) {
                       return obj;
                   }
               }
           }




   /**
    * Retrieves the relevant objects based on the X/Y position.
    * NOTE This function returns an array of objects
    *
    * @param  object e The event object
    * @return          An array of pertinent objects. Note the there may be only one object
    */
   RGraph.ObjectRegistry.getObjectsByXY = function (e)
   {
       var canvas  = e.target;
       var ret     = [];
       var objects = RGraph.ObjectRegistry.getObjectsByCanvasID(canvas.id);

       // Retrieve objects "front to back"
       for (var i=(objects.length - 1); i>=0; --i) {

           var obj = objects[i].getObjectByXY(e);

           if (obj) {
               ret.push(obj);
           }
       }

       return ret;
   }




   /**
    * Retrieves the object with the corresponding UID
    *
    * @param string uid The UID to get the relevant object for
    */
   RGraph.ObjectRegistry.getObjectByUID = function (uid)
   {
       var objects = RGraph.ObjectRegistry.objects.byUID;

       for (var i=0; i<objects.length; ++i) {
           if (objects[i] && objects[i][1].uid == uid) {
               return objects[i][1];
           }
       }
   }




   /**
    * Brings a chart to the front of the ObjectRegistry by
    * removing it and then readding it at the end and then
    * redrawing the canvas
    *
    * @param object  obj    The object to bring to the front
    * @param boolean redraw Whether to redraw the canvas after the
    *                       object has been moved
    */
   RGraph.ObjectRegistry.bringToFront = function (obj)
   {
       var redraw = typeof arguments[1] == 'undefined' ? true : arguments[1];

       RGraph.ObjectRegistry.Remove(obj);
       RGraph.ObjectRegistry.Add(obj);

       if (redraw) {
           RGraph.RedrawCanvas(obj.canvas);
       }
   }




   /**
    * Retrieves the objects that are the given type
    *
    * @param  mixed canvas  The canvas to check. It can either be the canvas object itself or just the ID
    * @param  string type   The type to look for
    * @return array         An array of one or more objects
    */
   RGraph.ObjectRegistry.getObjectsByType = function (type)
   {
       var objects = RGraph.ObjectRegistry.objects.byUID;
       var ret     = [];

       for (var i=0; i<objects.length; ++i) {

           if (objects[i] && objects[i][1] && objects[i][1].type && objects[i][1].type && objects[i][1].type == type) {
               ret.push(objects[i][1]);
           }
       }

       return ret;
   }




   /**
    * Retrieves the FIRST object that matches the given type
    *
    * @param  string type   The type of object to look for
    * @return object        The FIRST object that matches the given type
    */
   RGraph.ObjectRegistry.getFirstObjectByType = function (type)
   {
       var objects = RGraph.ObjectRegistry.objects.byUID;

       for (var i=0; i<objects.length; ++i) {
           if (objects[i] && objects[i][1] && objects[i][1].type == type) {
               return objects[i][1];
           }
       }

       return null;
   }




   /**
    * This takes centerx, centery, x and y coordinates and returns the
    * appropriate angle relative to the canvas angle system. Remember
    * that the canvas angle system starts at the EAST axis
    *
    * @param  number cx  The centerx coordinate
    * @param  number cy  The centery coordinate
    * @param  number x   The X coordinate (eg the mouseX if coming from a click)
    * @param  number y   The Y coordinate (eg the mouseY if coming from a click)
    * @return number     The relevant angle (measured in in RADIANS)
    */
   RGraph.getAngleByXY = function (cx, cy, x, y)
   {
       var angle = Math.atan((y - cy) / (x - cx));
       angle = Math.abs(angle)

       if (x >= cx && y >= cy) {
           angle += TWOPI;

       } else if (x >= cx && y < cy) {
           angle = (HALFPI - angle) + (PI + HALFPI);

       } else if (x < cx && y < cy) {
           angle += PI;

       } else {
           angle = PI - angle;
       }

       /**
        * Upper and lower limit checking
        */
       if (angle > TWOPI) {
           angle -= TWOPI;
       }

       return angle;
   }




   /**
    * This function returns the distance between two points. In effect the
    * radius of an imaginary circle that is centered on x1 and y1. The name
    * of this function is derived from the word "Hypoteneuse", which in
    * trigonmetry is the longest side of a triangle
    *
    * @param number x1 The original X coordinate
    * @param number y1 The original Y coordinate
    * @param number x2 The target X coordinate
    * @param number y2 The target Y  coordinate
    */
   RGraph.getHypLength = function (x1, y1, x2, y2)
   {
       var ret = Math.sqrt(((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1)));

       return ret;
   }




   /**
    * This function gets the end point (X/Y coordinates) of a given radius.
    * You pass it the center X/Y and the radius and this function will return
    * the endpoint X/Y coordinates.
    *
    * @param number cx The center X coord
    * @param number cy The center Y coord
    * @param number r  The lrngth of the radius
    */
   RGraph.getRadiusEndPoint = function (cx, cy, angle, radius)
   {
       var x = cx + (Math.cos(angle) * radius);
       var y = cy + (Math.sin(angle) * radius);

       return [x, y];
   }




   /**
    * This installs all of the event listeners
    *
    * @param object obj The chart object
    */
   RGraph.InstallEventListeners = function (obj)
   {
       var RG   = RGraph;
       var prop = obj.properties;

       /**
        * Don't attempt to install event listeners for older versions of MSIE
        */
       if (ISOLD) {
           return;
       }

       /**
        * If this function exists, then the dynamic file has been included.
        */
       if (RG.InstallCanvasClickListener) {

           RG.InstallWindowMousedownListener(obj);
           RG.InstallWindowMouseupListener(obj);
           RG.InstallCanvasMousemoveListener(obj);
           RG.InstallCanvasMouseupListener(obj);
           RG.InstallCanvasMousedownListener(obj);
           RG.InstallCanvasClickListener(obj);

       } else if (   RG.hasTooltips(obj)
               || prop['chart.adjustable']
               || prop['chart.annotatable']
               || prop['chart.contextmenu']
               || prop['chart.resizable']
               || prop['chart.key.interactive']
               || prop['chart.events.click']
               || prop['chart.events.mousemove']
               || typeof obj.onclick == 'function'
               || typeof obj.onmousemove == 'function'
               ) {

           alert('[RGRAPH] You appear to have used dynamic features but not included the file: RGraph.common.dynamic.js');
       }
   }




   /**
    * Loosly mimicks the PHP function print_r();
    */
   RGraph.pr = function (obj)
   {
       var indent = (arguments[2] ? arguments[2] : '    ');
       var str    = '';

       var counter = typeof arguments[3] == 'number' ? arguments[3] : 0;

       if (counter >= 5) {
           return '';
       }

       switch (typeof obj) {

           case 'string':    str += obj + ' (' + (typeof obj) + ', ' + obj.length + ')'; break;
           case 'number':    str += obj + ' (' + (typeof obj) + ')'; break;
           case 'boolean':   str += obj + ' (' + (typeof obj) + ')'; break;
           case 'function':  str += 'function () {}'; break;
           case 'undefined': str += 'undefined'; break;
           case 'null':      str += 'null'; break;

           case 'object':
               // In case of null
               if (RGraph.is_null(obj)) {
                   str += indent + 'null\n';
               } else {
                   str += indent + 'Object {' + '\n'
                   for (j in obj) {
                       str += indent + '    ' + j + ' => ' + RGraph.pr(obj[j], true, indent + '    ', counter + 1) + '\n';
                   }
                   str += indent + '}';
               }
               break;


           default:
               str += 'Unknown type: ' + typeof obj + '';
               break;
       }


       /**
        * Finished, now either return if we're in a recursed call, or alert()
        * if we're not.
        */
       if (!arguments[1]) {
           alert(str);
       }

       return str;
   }




   /**
    * Produces a dashed line
    *
    * @param object co The 2D context
    * @param number x1 The start X coordinate
    * @param number y1 The start Y coordinate
    * @param number x2 The end X coordinate
    * @param number y2 The end Y coordinate
    */
   RGraph.DashedLine = function(co, x1, y1, x2, y2)
   {
       /**
        * This is the size of the dashes
        */
       var size = 5;

       /**
        * The optional fifth argument can be the size of the dashes
        */
       if (typeof(arguments[5]) == 'number') {
           size = arguments[5];
       }

       var dx  = x2 - x1;
       var dy  = y2 - y1;
       var num = Math.floor(Math.sqrt((dx * dx) + (dy * dy)) / size);

       var xLen = dx / num;
       var yLen = dy / num;

       var count = 0;

       do {
           (count % 2 == 0 && count > 0) ? co.lineTo(x1, y1) : co.moveTo(x1, y1);

           x1 += xLen;
           y1 += yLen;
       } while(count++ <= num);
   }




   /**
    * Makes an AJAX call. It calls the given callback (a function) when ready
    *
    * @param string   url      The URL to retrieve
    * @param function callback A function that is called when the response is ready, there's an example below
    *                          called "myCallback".
    */
   RGraph.AJAX = function (url, callback)
   {
       // Mozilla, Safari, ...
       if (window.XMLHttpRequest) {
           var httpRequest = new XMLHttpRequest();

           // MSIE
       } else if (window.ActiveXObject) {
           var httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
       }

       httpRequest.onreadystatechange = function ()
       {
           if (this.readyState == 4 && this.status == 200) {
               this.__user_callback__ = callback;
               this.__user_callback__(this.responseText);
           }
       }

       httpRequest.open('GET', url, true);
       httpRequest.send();
   }




   /**
    * Makes an AJAX POST request. It calls the given callback (a function) when ready
    *
    * @param string   url      The URL to retrieve
    * @param object   data     The POST data
    * @param function callback A function that is called when the response is ready, there's an example below
    *                          called "myCallback".
    */
   RGraph.AJAX.POST = function (url, data, callback)
   {
       // Used when building the POST string
       var crumbs = [];

       // Mozilla, Safari, ...
       if (window.XMLHttpRequest) {
           var httpRequest = new XMLHttpRequest();

           // MSIE
       } else if (window.ActiveXObject) {
           var httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
       }

       httpRequest.onreadystatechange = function ()
       {
           if (this.readyState == 4 && this.status == 200) {
               this.__user_callback__ = callback;
               this.__user_callback__(this.responseText);
           }
       }

       httpRequest.open('POST', url, true);
       httpRequest.setRequestHeader("Content-type","application/x-www-form-urlencoded");

       for (i in data) {
           if (typeof i == 'string') {
               crumbs.push(i + '=' + encodeURIComponent(data[i]));
           }
       }

       httpRequest.send(crumbs.join('&'));
   }




   /**
    * Uses the above function but calls the call back passing a number as its argument
    *
    * @param url string The URL to fetch
    * @param callback function Your callback function (which is passed the number as an argument)
    */
   RGraph.AJAX.getNumber = function (url, callback)
   {
       RGraph.AJAX(url, function ()
       {
           var num = parseFloat(this.responseText);

           callback(num);
       });
   }




   /**
    * Uses the above function but calls the call back passing a string as its argument
    *
    * @param url string The URL to fetch
    * @param callback function Your callback function (which is passed the string as an argument)
    */
   RGraph.AJAX.getString = function (url, callback)
   {
       RGraph.AJAX(url, function ()
       {
           var str = String(this.responseText);

           callback(str);
       });
   }




   /**
    * Uses the above function but calls the call back passing JSON (ie a JavaScript object ) as its argument
    *
    * @param url string The URL to fetch
    * @param callback function Your callback function (which is passed the JSON object as an argument)
    */
   RGraph.AJAX.getJSON = function (url, callback)
   {
       RGraph.AJAX(url, function ()
       {

           var json = eval('(' + this.responseText + ')');

           callback(json);
       });
   }




   /**
    * Uses the above RGraph.AJAX function but calls the call back passing an array as its argument.
    * Useful if you're retrieving CSV data
    *
    * @param url string The URL to fetch
    * @param callback function Your callback function (which is passed the CSV/array as an argument)
    */
   RGraph.AJAX.getCSV = function (url, callback)
   {
       var seperator = arguments[2] ? arguments[2] : ',';

       RGraph.AJAX(url, function ()
       {
           var regexp = new RegExp(seperator);
           var arr = this.responseText.split(regexp);

           // Convert the strings to numbers
           for (var i=0,len=arr.length;i<len;++i) {
               arr[i] = parseFloat(arr[i]);
           }

           callback(arr);
       });
   }




   /**
    * Rotates the canvas
    *
    * @param object canvas The canvas to rotate
    * @param  int   x      The X coordinate about which to rotate the canvas
    * @param  int   y      The Y coordinate about which to rotate the canvas
    * @param  int   angle  The angle(in RADIANS) to rotate the canvas by
    */
   RGraph.RotateCanvas = function (ca, x, y, angle)
   {
       var co = ca.getContext('2d');

       co.translate(x, y);
       co.rotate(angle);
       co.translate(0 - x, 0 - y);
   }




   /**
    * Measures text by creating a DIV in the document and adding the relevant text to it.
    * Then checking the .offsetWidth and .offsetHeight.
    *
    * @param  string text   The text to measure
    * @param  bool   bold   Whether the text is bold or not
    * @param  string font   The font to use
    * @param  size   number The size of the text (in pts)
    * @return array         A two element array of the width and height of the text
    */
   RGraph.MeasureText = function (text, bold, font, size)
   {
       // Add the sizes to the cache as adding DOM elements is costly and causes slow downs
       if (typeof(__rgraph_measuretext_cache__) == 'undefined') {
           __rgraph_measuretext_cache__ = [];
       }

       var str = text + ':' + bold + ':' + font + ':' + size;
       if (typeof(__rgraph_measuretext_cache__) == 'object' && __rgraph_measuretext_cache__[str]) {
           return __rgraph_measuretext_cache__[str];
       }

       if (!__rgraph_measuretext_cache__['text-div']) {
           var div = document.createElement('DIV');
           div.style.position = 'absolute';
           div.style.top = '-100px';
           div.style.left = '-100px';
           document.body.appendChild(div);

           // Now store the newly created DIV
           __rgraph_measuretext_cache__['text-div'] = div;

       } else if (__rgraph_measuretext_cache__['text-div']) {
           var div = __rgraph_measuretext_cache__['text-div'];
       }

       div.innerHTML = text.replace(/\r\n/g, '<br />');
       div.style.fontFamily = font;
       div.style.fontWeight = bold ? 'bold' : 'normal';
       div.style.fontSize = (size || 12) + 'pt';

       var size = [div.offsetWidth, div.offsetHeight];

       //document.body.removeChild(div);
       __rgraph_measuretext_cache__[str] = size;

       return size;
   }




   /* New text function. Accepts two arguments:
    *  o obj - The chart object
    *  o opt - An object/hash/map of properties. This can consist of:
    *          x                The X coordinate (REQUIRED)
    *          y                The Y coordinate (REQUIRED)
    *          text             The text to show (REQUIRED)
    *          font             The font to use
    *          size             The size of the text (in pt)
    *          bold             Whether the text shouldd be bold or not
    *          marker           Whether to show a marker that indicates the X/Y coordinates
    *          valign           The vertical alignment
    *          halign           The horizontal alignment
    *          bounding         Whether to draw a bounding box for the text
    *          boundingStroke   The strokeStyle of the bounding box
    *          boundingFill     The fillStyle of the bounding box
    */
   RGraph.Text2 = function (obj, opt)
   {
       /**
        * An RGraph object can be given, or a string or the 2D rendering context
        * The coords are placed on the obj.coordsText variable ONLY if it's an RGraph object. The function
        * still returns the cooords though in all cases.
        */
       if (obj && obj.isRGraph) {
           var co = obj.context;
           var ca = obj.canvas;
       } else if (typeof obj == 'string') {
           var ca = document.getElementById(obj);
           var co = ca.getContext('2d');
       } else if (typeof obj.getContext == 'function') {
           var ca = obj;
           var co = ca.getContext('2d');
       } else if (obj.toString().indexOf('CanvasRenderingContext2D') != -1) {
           var co = obj;
           var ca = obj.context;
       }

       var x              = opt.x;
       var y              = opt.y;
       var originalX      = x;
       var originalY      = y;
       var text           = opt.text;
       var text_multiline = text.split(/\r?\n/g);
       var numlines       = text_multiline.length;
       var font           = opt.font ? opt.font : 'Arial';
       var size           = opt.size ? opt.size : 10;
       var size_pixels    = size * 1.5;
       var bold           = opt.bold;
       var halign         = opt.halign ? opt.halign : 'left';
       var valign         = opt.valign ? opt.valign : 'bottom';
       var tag            = typeof opt.tag == 'string' && opt.tag.length > 0 ? opt.tag : '';
       var marker         = opt.marker;
       var angle          = opt.angle || 0;

       /**
        * Changed the name of boundingFill/boundingStroke - this allows you to still use those names
        */
       if (typeof opt.boundingFill == 'string')   opt['bounding.fill']   = opt.boundingFill;
       if (typeof opt.boundingStroke == 'string') opt['bounding.stroke'] = opt.boundingStroke;

       var bounding                = opt.bounding;
       var bounding_stroke         = opt['bounding.stroke'] ? opt['bounding.stroke'] : 'black';
       var bounding_fill           = opt['bounding.fill'] ? opt['bounding.fill'] : 'rgba(255,255,255,0.7)';
       var bounding_shadow         = opt['bounding.shadow'];
       var bounding_shadow_color   = opt['bounding.shadow.color'] || '#ccc';
       var bounding_shadow_blur    = opt['bounding.shadow.blur'] || 3;
       var bounding_shadow_offsetx = opt['bounding.shadow.offsetx'] || 3;
       var bounding_shadow_offsety = opt['bounding.shadow.offsety'] || 3;
       var bounding_linewidth      = opt['bounding.linewidth'] || 1;



       /**
        * Initialize the return value to an empty object
        */
       var ret = {};



       /**
        * The text arg must be a string or a number
        */
       if (typeof text == 'number') {
           text = String(text);
       }

       if (typeof text != 'string') {
           alert('[RGRAPH TEXT] The text given must a string or a number');
           return;
       }



       /**
        * This facilitates vertical text
        */
       if (angle != 0) {
           co.save();
           co.translate(x, y);
           co.rotate((Math.PI / 180) * angle)
           x = 0;
           y = 0;
       }



       /**
        * Set the font
        */
       co.font = (opt.bold ? 'bold ' : '') + size + 'pt ' + font;



       /**
        * Measure the width/height. This must be done AFTER the font has been set
        */
       var width=0;
       for (var i=0; i<numlines; ++i) {
           width = Math.max(width, co.measureText(text_multiline[i]).width);
       }
       var height = size_pixels * numlines;




       /**
        * Accommodate old MSIE 7/8
        */
       //if (document.all && ISOLD) {
       //y += 2;
       //}



       /**
        * If marker is specified draw a marker at the X/Y coordinates
        */
       if (opt.marker) {
           var marker_size = 10;
           var strokestyle = co.strokeStyle;
           co.beginPath();
           co.strokeStyle = 'red';
           co.moveTo(x, y - marker_size);
           co.lineTo(x, y + marker_size);
           co.moveTo(x - marker_size, y);
           co.lineTo(x + marker_size, y);
           co.stroke();
           co.strokeStyle = strokestyle;
       }



       /**
        * Set the horizontal alignment
        */
       if (halign == 'center') {
           co.textAlign = 'center';
           var boundingX = x - 2 - (width / 2);
       } else if (halign == 'right') {
           co.textAlign = 'right';
           var boundingX = x - 2 - width;
       } else {
           co.textAlign = 'left';
           var boundingX = x - 2;
       }


       /**
        * Set the vertical alignment
        */
       if (valign == 'center') {

           co.textBaseline = 'middle';
           // Move the text slightly
           y -= 1;

           y -= ((numlines - 1) / 2) * size_pixels;
           var boundingY = y - (size_pixels / 2) - 2;

       } else if (valign == 'top') {
           co.textBaseline = 'top';

           var boundingY = y - 2;

       } else {

           co.textBaseline = 'bottom';

           // Move the Y coord if multiline text
           if (numlines > 1) {
               y -= ((numlines - 1) * size_pixels);
           }

           var boundingY = y - size_pixels - 2;
       }

       var boundingW = width + 4;
       var boundingH = height + 4;



       /**
        * Draw a bounding box if required
        */
       if (bounding) {

           var pre_bounding_linewidth     = co.lineWidth;
           var pre_bounding_strokestyle   = co.strokeStyle;
           var pre_bounding_fillstyle     = co.fillStyle;
           var pre_bounding_shadowcolor   = co.shadowColor;
           var pre_bounding_shadowblur    = co.shadowBlur;
           var pre_bounding_shadowoffsetx = co.shadowOffsetX;
           var pre_bounding_shadowoffsety = co.shadowOffsetY;

           co.lineWidth   = bounding_linewidth;
           co.strokeStyle = bounding_stroke;
           co.fillStyle   = bounding_fill;

           if (bounding_shadow) {
               co.shadowColor   = bounding_shadow_color;
               co.shadowBlur    = bounding_shadow_blur;
               co.shadowOffsetX = bounding_shadow_offsetx;
               co.shadowOffsetY = bounding_shadow_offsety;
           }

           //obj.context.strokeRect(boundingX, boundingY, width + 6, (size_pixels * numlines) + 4);
           //obj.context.fillRect(boundingX, boundingY, width + 6, (size_pixels * numlines) + 4);
           co.strokeRect(boundingX, boundingY, boundingW, boundingH);
           co.fillRect(boundingX, boundingY, boundingW, boundingH);

           // Reset the linewidth,colors and shadow to it's original setting
           co.lineWidth     = pre_bounding_linewidth;
           co.strokeStyle   = pre_bounding_strokestyle;
           co.fillStyle     = pre_bounding_fillstyle;
           co.shadowColor   = pre_bounding_shadowcolor
           co.shadowBlur    = pre_bounding_shadowblur
           co.shadowOffsetX = pre_bounding_shadowoffsetx
           co.shadowOffsetY = pre_bounding_shadowoffsety
       }



       /**
        * Draw the text
        */
       if (numlines > 1) {
           for (var i=0; i<numlines; ++i) {
               co.fillText(text_multiline[i], x, y + (size_pixels * i));
           }
       } else {
           co.fillText(text, x, y);
       }



       /**
        * If the text is at 90 degrees restore() the canvas - getting rid of the rotation
        * and the translate that we did
        */
       if (angle != 0) {
           if (angle == 90) {
               if (halign == 'left') {
                   if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
                   if (valign == 'center') {boundingX = originalX - (height / 2) - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
                   if (valign == 'top')    {boundingX = originalX - height - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}

               } else if (halign == 'center') {
                   if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}
                   if (valign == 'center') {boundingX = originalX - (height / 2) -  2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}
                   if (valign == 'top')    {boundingX = originalX - height -  2; boundingY = originalY - (width / 2) - 2; boundingW = height + 4; boundingH = width + 4;}

               } else if (halign == 'right') {
                   if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
                   if (valign == 'center') {boundingX = originalX - (height / 2) - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
                   if (valign == 'top')    {boundingX = originalX - height - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
               }

           } else if (angle == 180) {

               if (halign == 'left') {
                   if (valign == 'bottom') {boundingX = originalX - width - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}
                   if (valign == 'center') {boundingX = originalX - width - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}
                   if (valign == 'top')    {boundingX = originalX - width - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}

               } else if (halign == 'center') {
                   if (valign == 'bottom') {boundingX = originalX - (width / 2) - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}
                   if (valign == 'center') {boundingX = originalX - (width / 2) - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}
                   if (valign == 'top')    {boundingX = originalX - (width / 2) - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}

               } else if (halign == 'right') {
                   if (valign == 'bottom') {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = width + 4; boundingH = height + 4;}
                   if (valign == 'center') {boundingX = originalX - 2; boundingY = originalY - (height / 2) - 2; boundingW = width + 4; boundingH = height + 4;}
                   if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - height - 2; boundingW = width + 4; boundingH = height + 4;}
               }

           } else if (angle == 270) {

               if (halign == 'left') {
                   if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
                   if (valign == 'center') {boundingX = originalX - (height / 2) - 4; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}
                   if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - width - 2; boundingW = height + 4; boundingH = width + 4;}

               } else if (halign == 'center') {
                   if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}
                   if (valign == 'center') {boundingX = originalX - (height/2) - 4; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}
                   if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - (width/2) - 2; boundingW = height + 4; boundingH = width + 4;}

               } else if (halign == 'right') {
                   if (valign == 'bottom') {boundingX = originalX - height - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
                   if (valign == 'center') {boundingX = originalX - (height/2) - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
                   if (valign == 'top')    {boundingX = originalX - 2; boundingY = originalY - 2; boundingW = height + 4; boundingH = width + 4;}
               }
           }

           co.restore();
       }




       /**
        * Reset the text alignment so that text rendered
        */
       co.textBaseline = 'alphabetic';
       co.textAlign    = 'left';





       /**
        * Fill the ret variable with details of the text
        */
       ret.x      = boundingX;
       ret.y      = boundingY;
       ret.width  = boundingW;
       ret.height = boundingH
       ret.object = obj;
       ret.text   = text;
       ret.tag    = tag;



       /**
        * Save and then return the details of the text (but oly
        * if it's an RGraph object that was given)
        */
       if (obj && obj.isRGraph && obj.coordsText) {
           obj.coordsText.push(ret);
       }

       return ret;
   }




   /**
    * Takes a sequential index abd returns the group/index variation of it. Eg if you have a
    * sequential index from a grouped bar chart this function can be used to convert that into
    * an appropriate group/index combination
    *
    * @param nindex number The sequential index
    * @param data   array  The original data (which is grouped)
    * @return              The group/index information
    */
   RGraph.sequentialIndexToGrouped = function (index, data)
   {
       var group         = 0;
       var grouped_index = 0;

       while (--index >= 0) {

           if (RGraph.is_null(data[group])) {
               group++;
               grouped_index = 0;
               continue;
           }

           // Allow for numbers as well as arrays in the dataset
           if (typeof data[group] == 'number') {
               group++
               grouped_index = 0;
               continue;
           }


           grouped_index++;

           if (grouped_index >= data[group].length) {
               group++;
               grouped_index = 0;
           }
       }

       return [group, grouped_index];
   }




   /**
    * Similar to the jQuery each() function - this lets you iterate easily over an array. The 'this' variable is set]
    * to the array in the callback function.
    *
    * @param array    arr The array
    * @param function func The function to call
    * @param object        Optionally you can specify the object that the "this" variable is set to
    */
   RGraph.each = function (arr, func)
   {
       for(var i=0, len=arr.length; i<len; i+=1) {

           if (typeof arguments[2] !== 'undefined') {
               var ret = func.call(arguments[2], i, arr[i]);
           } else {
               var ret = func.call(arr, i, arr[i]);
           }

           if (ret === false) {
               return;
           }
       }
   }




   /**
    * Checks whether strings or numbers are empty or not. It also
    * handles null or variables set to undefined. If a variable really
    * is undefined - ie it hasn't been declared at all - you need to use
    * "typeof variable" and check the return value - which will be undefined.
    *
    * @param mixed value The variable to check
    */
   function empty (value)
   {
       if (!value || value.length <= 0) {
           return true;
       }

       return false;
   }




   /**
    * This function highlights a rectangle
    *
    * @param object obj    The chart object
    * @param number shape  The coordinates of the rect to highlight
    */
   RGraph.Highlight.Rect = function (obj, shape)
   {
       var ca   = obj.canvas;
       var co   = obj.context;
       var prop = obj.properties;

       if (prop['chart.tooltips.highlight']) {


           // Safari seems to need this
           co.lineWidth = 1;

           /**
            * Draw a rectangle on the canvas to highlight the appropriate area
            */
           co.beginPath();

           co.strokeStyle = prop['chart.highlight.stroke'];
           co.fillStyle   = prop['chart.highlight.fill'];

           co.strokeRect(shape['x'],shape['y'],shape['width'],shape['height']);
           co.fillRect(shape['x'],shape['y'],shape['width'],shape['height']);
           co.stroke;
           co.fill();
       }
   }




   /**
    * This function highlights a point
    *
    * @param object obj    The chart object
    * @param number shape  The coordinates of the rect to highlight
    */
   RGraph.Highlight.Point = function (obj, shape)
   {
       var prop = obj.properties;
       var ca   = obj.canvas;
       var co   = obj.context;

       if (prop['chart.tooltips.highlight']) {

           /**
            * Draw a rectangle on the canvas to highlight the appropriate area
            */
           co.beginPath();
           co.strokeStyle = prop['chart.highlight.stroke'];
           co.fillStyle   = prop['chart.highlight.fill'];
           var radius   = prop['chart.highlight.point.radius'] || 2;
           co.arc(shape['x'],shape['y'],radius, 0, TWOPI, 0);
           co.stroke();
           co.fill();
       }
   }




   /**
    * Creates an HTML tag
    *
    * @param string type
    * @param obj    parent
    * @param obj
    * @param obj
    */
   RGraph.HTML.create = function (type, parent)
   {
       var obj = document.createElement(type);




       // Add the attributes
       if (arguments[2]) {
           this.attr(obj, arguments[2]);
       }




       // Add the styles
       if (arguments[3]) {
           this.css(obj, arguments[3]);
       }




       /**
        * Add the tag to the object that has been provided (usually the document)
        */
       parent.appendChild(obj);


       return obj;
   }




   /**
    * Sets attributes on a HTML object
    *
    * @param object obj
    * @param object attr
    */
   RGraph.HTML.attr = function (obj, attr)
   {
       for (i in attr) {
           if (typeof i == 'string') {
               obj[i] = attr[i];
           }
       }
   }




   /**
    * Sets CSS on a HTML object
    *
    * @param object obj
    * @param object css
    */
   RGraph.HTML.css = function (obj, styles)
   {
       var style = obj.style;

       for (i in styles) {
           if (typeof i == 'string') {
               style[i] = styles[i];
           }
       }
   }




   /**
    * This is the same as Date.parse - though a little more flexible.
    *
    * @param string str The date string to parse
    * @return Returns the same thing as Date.parse
    */
   RGraph.parseDate = function (str)
   {
       str.trim();

       // Allow for: now (just the word "now")
       if (str === 'now') {
           str = (new Date()).toString();
       }

       // Allow for: 2013-11-22 12:12:12 or  2013/11/22 12:12:12
       if (str.match(/^(\d\d\d\d)(-|\/)(\d\d)(-|\/)(\d\d)( |T)(\d\d):(\d\d):(\d\d)$/)) {
           str = RegExp.$1 + '-' + RegExp.$3 + '-' + RegExp.$5 + 'T' + RegExp.$7 + ':' + RegExp.$8 + ':' + RegExp.$9;
       }

       // Allow for: 2013-11-22
       if (str.match(/^\d\d\d\d-\d\d-\d\d$/)) {
           str = str.replace(/-/, '/');
       }

       // Allow for: 12:09:44 (time only using todays date)
       if (str.match(/^\d\d:\d\d:\d\d$/)) {

           var dateObj  = new Date();
           var date     = dateObj.getDate();
           var month    = dateObj.getMonth() + 1;
           var year     = dateObj.getFullYear();

           str = (year + '-' + month + '-' + date) + ' ' + str;
       }

       return Date.parse(str);
   }




   // Reset all of the color values to their original values
   RGraph.resetColorsToOriginalValues = function (obj)
   {
       if (obj.original_colors) {
           // Reset the colors to their original values
           for (var j in obj.original_colors) {
               if (typeof j === 'string') {
                   obj.properties[j] = RGraph.array_clone(obj.original_colors[j]);
               }
           }
       }

       // Reset the colorsParsed flag so that they're parsed for gradients again
       obj.colorsParsed = false;
   }




   /**
    * This function is a short-cut for the canvas path syntax (which can be rather verbose)
    *
    * @param mixed  obj  This can either be the 2D context or an RGraph object
    * @param array  path The path details
    */
   RGraph.Path = function (obj, path)
   {
       /**
        * Allow either the RGraph object or the context to be used as the first argument
        */
       if (obj.isRGraph && typeof obj.type === 'string') {
           var co = obj.context;
       } else if (obj.toString().indexOf('CanvasRenderingContext2D') > 0) {
           var co = obj;
       }

       /**
        * If the Path information has been passed as a  string - split it up
        */
       if (typeof path == 'string') {
           path = path.split(/ +/);
       }

       /**
        * Go through the path information
        */
       for (var i=0,len=path.length; i<len; i+=1) {

           var op = path[i];

           // 100,100,50,0,Math.PI * 1.5, false
           switch (op) {
               case 'b':co.beginPath();break;
               case 'c':co.closePath();break;
               case 'm':co.moveTo(parseFloat(path[i+1]),parseFloat(path[i+2]));i+=2;break;
               case 'l':co.lineTo(parseFloat(path[i+1]),parseFloat(path[i+2]));i+=2;break;
               case 's':co.strokeStyle=path[i+1];co.stroke();i+=1;break;
               case 'f':co.fillStyle=path[i+1];co.fill();i+=1;break;
               case 'qc':co.quadraticCurveTo(parseFloat(path[i+1]),parseFloat(path[i+2]),parseFloat(path[i+3]),parseFloat(path[i+4]));i+=4;break;
               case 'bc':co.bezierCurveTo(parseFloat(path[i+1]),parseFloat(path[i+2]),parseFloat(path[i+3]),parseFloat(path[i+4]),parseFloat(path[i+5]),parseFloat(path[i+6]));i+=6;break;
               case 'r':co.rect(parseFloat(path[i+1]),parseFloat(path[i+2]),parseFloat(path[i+3]),parseFloat(path[i+4]));i+=4;break;
               case 'a':co.arc(parseFloat(path[i+1]),parseFloat(path[i+2]),parseFloat(path[i+3]),parseFloat(path[i+4]),parseFloat(path[i+5]),path[i+6]==='true'||path[i+6]===true?true:false);i+=6;break;
               case 'at':co.arcTo(parseFloat(path[i+1]),parseFloat(path[i+2]),parseFloat(path[i+3]),parseFloat(path[i+4]),parseFloat(path[i+5]));i+=5;break;
               case 'lw':co.lineWidth=parseFloat(path[i+1]);i+=1;break;
               case 'lj':co.lineJoin=path[i+1];i+=1;break;
               case 'lc':co.lineCap=path[i+1];i+=1;break;
               case 'sc':co.shadowColor=path[i+1];i+=1;break;
               case 'sb':co.shadowBlur=parseFloat(path[i+1]);i+=1;break;
               case 'sx':co.shadowOffsetX=parseFloat(path[i+1]);i+=1;break;
               case 'sy':co.shadowOffsetY=parseFloat(path[i+1]);i+=1;break;
               case 'fu':(path[i+1])(obj);i+=1;break;
           }
       }
   }



   // Some other functions. Because they're rarely changed - they're hand minified
   RGraph.LinearGradient=function(obj,x1,y1,x2,y2,color1,color2){var gradient=obj.context.createLinearGradient(x1,y1,x2,y2);var numColors=arguments.length-5;for (var i=5;i<arguments.length;++i){var color=arguments[i];var stop=(i-5)/(numColors-1);gradient.addColorStop(stop,color);}return gradient;}
   RGraph.RadialGradient=function(obj,x1,y1,r1,x2,y2,r2,color1,color2){var gradient=obj.context.createRadialGradient(x1,y1,r1,x2,y2,r2);var numColors=arguments.length-7;for(var i=7;i<arguments.length; ++i){var color=arguments[i];var stop=(i-7)/(numColors-1);gradient.addColorStop(stop,color);}return gradient;}
   RGraph.array_shift=function(arr){var ret=[];for(var i=1;i<arr.length;++i){ret.push(arr[i]);}return ret;}
   RGraph.AddEventListener=function(id,e,func){var type=arguments[3]?arguments[3]:'unknown';RGraph.Registry.Get('chart.event.handlers').push([id,e,func,type]);}
   RGraph.ClearEventListeners=function(id){if(id&&id=='window'){window.removeEventListener('mousedown',window.__rgraph_mousedown_event_listener_installed__,false);window.removeEventListener('mouseup',window.__rgraph_mouseup_event_listener_installed__,false);}else{var canvas = document.getElementById(id);canvas.removeEventListener('mouseup',canvas.__rgraph_mouseup_event_listener_installed__,false);canvas.removeEventListener('mousemove',canvas.__rgraph_mousemove_event_listener_installed__,false);canvas.removeEventListener('mousedown',canvas.__rgraph_mousedown_event_listener_installed__,false);canvas.removeEventListener('click',canvas.__rgraph_click_event_listener_installed__,false);}}
   RGraph.HidePalette=function(){var div=RGraph.Registry.Get('palette');if(typeof(div)=='object'&&div){div.style.visibility='hidden';div.style.display='none';RGraph.Registry.Set('palette',null);}}
   RGraph.random=function(min,max){var dp=arguments[2]?arguments[2]:0;var r=Math.random();return Number((((max - min) * r) + min).toFixed(dp));}
   RGraph.random.array=function(num,min,max){var arr = [];for(var i=0;i<num;i++)arr.push(RGraph.random(min,max));return arr;}
   RGraph.NoShadow=function(obj){obj.context.shadowColor='rgba(0,0,0,0)';obj.context.shadowBlur=0;obj.context.shadowOffsetX=0;obj.context.shadowOffsetY=0;}
   RGraph.SetShadow=function(obj,color,offsetx,offsety,blur){obj.context.shadowColor=color;obj.context.shadowOffsetX=offsetx;obj.context.shadowOffsetY=offsety;obj.context.shadowBlur=blur;}
   RGraph.array_reverse=function(arr){var newarr=[];for(var i=arr.length-1;i>=0;i--){newarr.push(arr[i]);}return newarr;}
   RGraph.Registry.Set=function(name,value){RGraph.Registry.store[name]=value;return value;}
   RGraph.Registry.Get=function(name){return RGraph.Registry.store[name];}
   RGraph.degrees2Radians=function(degrees){return degrees*(PI/180);}
   RGraph.log=(function(n,base){var log=Math.log;return function(n,base){return log(n)/(base?log(base):1);};})();
   RGraph.is_array=function(obj){return obj!=null&&obj.constructor.toString().indexOf('Array')!=-1;}
   RGraph.trim=function(str){return RGraph.ltrim(RGraph.rtrim(str));}
   RGraph.ltrim=function(str){return str.replace(/^(\s|\0)+/, '');}
   RGraph.rtrim=function(str){return str.replace(/(\s|\0)+$/, '');}
   RGraph.GetHeight=function(obj){return obj.canvas.height;}
   RGraph.GetWidth=function(obj){return obj.canvas.width;}
   RGraph.is_null=function(arg){if(arg==null||(typeof(arg))=='object'&&!arg){return true;}return false;}
   RGraph.Timer=function(label){if(typeof(RGraph.TIMER_LAST_CHECKPOINT)=='undefined'){RGraph.TIMER_LAST_CHECKPOINT=Date.now();}var now=Date.now();console.log(label+': '+(now-RGraph.TIMER_LAST_CHECKPOINT).toString());RGraph.TIMER_LAST_CHECKPOINT=now;}
   RGraph.Async=function(func){return setTimeout(func,arguments[1]?arguments[1]:1);}
   RGraph.isIE=function(){return navigator.userAgent.indexOf('Trident')>0||navigator.userAgent.indexOf('MSIE')>0;};ISIE=RGraph.isIE();
   RGraph.isIE6=function(){return navigator.userAgent.indexOf('MSIE 6')>0;};ISIE6=RGraph.isIE6();
   RGraph.isIE7=function(){return navigator.userAgent.indexOf('MSIE 7')>0;};ISIE7=RGraph.isIE7();
   RGraph.isIE8=function(){return navigator.userAgent.indexOf('MSIE 8')>0;};ISIE8=RGraph.isIE8();
   RGraph.isIE9=function(){return navigator.userAgent.indexOf('MSIE 9')>0;};ISIE9=RGraph.isIE9();
   RGraph.isIE10=function(){return navigator.userAgent.indexOf('MSIE 10')>0;};ISIE10=RGraph.isIE10();
   RGraph.isIE11=function(){return navigator.userAgent.indexOf('MSIE')==-1&&navigator.userAgent.indexOf('Trident')>0;};ISIE11=RGraph.isIE11();
   RGraph.isIE9up=function(){return ISIE9||ISIE10||ISIE11;};ISIE9UP=RGraph.isIE9up();
   RGraph.isIE10up=function(){return ISIE10||ISIE11};ISIE10UP=RGraph.isIE10up();
   RGraph.isIE11up=function(){return ISIE11};ISIE11UP=RGraph.isIE11up();
   RGraph.isOld=function(){return ISIE6||ISIE7||ISIE8;};ISOLD=RGraph.isOld();
   RGraph.Reset=function(canvas){canvas.width=canvas.width;RGraph.ObjectRegistry.Clear(canvas);canvas.__rgraph_aa_translated__=false;}
   function pd(variable){RGraph.pr(variable);}
   function p(variable){RGraph.pr(arguments[0],arguments[1],arguments[3]);}
   function a(variable){alert(variable);}
   function cl(variable){return console.log(variable);}
   </script>
   <script type="text/javascript">
   /**
    * o-------------------------------------------------------------------------------o
    * | This file is part of the RGraph package. RGraph is Free software, licensed    |
    * | under the MIT license - so it's free to use for all purposes. Extended        |
    * | support is available if required and donations are always welcome! You can    |
    * | read more here:                                                               |
    * |                         http://www.rgraph.net/support                         |
    * o-------------------------------------------------------------------------------o
    */

   if (typeof(RGraph) == 'undefined') RGraph = {};

   /**
    * The bar chart constructor
    *
    * @param object canvas The canvas object
    * @param array  data   The chart data
    */
   RGraph.Bar = function (id, data)
   {
       // Get the canvas and context objects
       this.id                = id;
       this.canvas            = document.getElementById(typeof id === 'object' ? id.id : id);
       this.context           = this.canvas.getContext ? this.canvas.getContext("2d") : null;
       this.canvas.__object__ = this;
       this.type              = 'bar';
       this.max               = 0;
       this.stackedOrGrouped  = false;
       this.isRGraph          = true;
       this.uid               = RGraph.CreateUID();
       this.canvas.uid        = this.canvas.uid ? this.canvas.uid : RGraph.CreateUID();
       this.colorsParsed      = false;
       this.original_colors   = [];


       /**
        * Compatibility with older browsers
        */
       RGraph.OldBrowserCompat(this.context);


       // Various config type stuff
       this.properties = {
           'chart.background.barcolor1':   'rgba(0,0,0,0)',
           'chart.background.barcolor2':   'rgba(0,0,0,0)',
           'chart.background.grid':        true,
           'chart.background.grid.color':  '#ddd',
           'chart.background.grid.width':  1,
           'chart.background.grid.hsize':  20,
           'chart.background.grid.vsize':  20,
           'chart.background.grid.vlines': true,
           'chart.background.grid.hlines': true,
           'chart.background.grid.border': true,
           'chart.background.grid.autofit':true,
           'chart.background.grid.autofit.numhlines': 5,
           'chart.background.grid.autofit.numvlines': 20,
           'chart.background.grid.dashed': false,
           'chart.background.grid.dotted': false,
           'chart.background.image.stretch': true,
           'chart.background.image.x':     null,
           'chart.background.image.y':     null,
           'chart.background.image.w':     null,
           'chart.background.image.h':     null,
           'chart.background.image.align': null,
           'chart.numyticks':              10,
           'chart.hmargin':                5,
           'chart.hmargin.grouped':        1,
           'chart.strokecolor':            'rgba(0,0,0,0)',
           'chart.axis.color':             'black',
           'chart.axis.linewidth':         1,
           'chart.gutter.top':             25,
           'chart.gutter.bottom':          25,
           'chart.gutter.left':            25,
           'chart.gutter.right':           25,
           'chart.labels':                 null,
           'chart.labels.ingraph':         null,
           'chart.labels.above':           false,
           'chart.labels.above.decimals':  0,
           'chart.labels.above.size':      null,
           'chart.labels.above.color':     null,
           'chart.labels.above.angle':     null,
           'chart.ylabels':                true,
           'chart.ylabels.count':          5,
           'chart.ylabels.inside':         false,
           'chart.xlabels.offset':         0,
           'chart.xaxispos':               'bottom',
           'chart.yaxispos':               'left',
           'chart.text.angle':             0,
           'chart.text.color':             'black', // Gradients aren't supported for this color
           'chart.text.size':              10,
           'chart.text.font':              'Arial',
           'chart.ymin':                   0,
           'chart.ymax':                   null,
           'chart.title':                  '',
           'chart.title.font':             null,
           'chart.title.background':       null, // Gradients aren't supported for this color
           'chart.title.hpos':             null,
           'chart.title.vpos':             null,
           'chart.title.bold':             true,
           'chart.title.xaxis':            '',
           'chart.title.xaxis.bold':       true,
           'chart.title.xaxis.size':       null,
           'chart.title.xaxis.font':       null,
           'chart.title.yaxis':            '',
           'chart.title.yaxis.bold':       true,
           'chart.title.yaxis.size':       null,
           'chart.title.yaxis.font':       null,
           'chart.title.yaxis.color':      null, // Gradients aren't supported for this color
           'chart.title.xaxis.pos':        null,
           'chart.title.yaxis.pos':        null,
           'chart.title.yaxis.x':          null,
           'chart.title.yaxis.y':          null,
           'chart.title.xaxis.x':          null,
           'chart.title.xaxis.y':          null,
           'chart.title.x':                null,
           'chart.title.y':                null,
           'chart.title.halign':           null,
           'chart.title.valign':           null,
           'chart.colors':                 ['#01B4FF', '#0f0', '#00f', '#ff0', '#0ff', '#0f0'],
           'chart.colors.sequential':      false,
           'chart.colors.reverse':         false,
           'chart.grouping':               'grouped',
           'chart.variant':                'bar',
           'chart.variant.sketch.verticals': true,
           'chart.shadow':                 false,
           'chart.shadow.color':           '#999',  // Gradients aren't supported for this color
           'chart.shadow.offsetx':         3,
           'chart.shadow.offsety':         3,
           'chart.shadow.blur':            3,
           'chart.tooltips':               null,
           'chart.tooltips.effect':        'fade',
           'chart.tooltips.css.class':     'RGraph_tooltip',
           'chart.tooltips.event':         'onclick',
           'chart.tooltips.highlight':     true,
           'chart.highlight.stroke':       'rgba(0,0,0,0)',
           'chart.highlight.fill':         'rgba(255,255,255,0.7)',
           'chart.background.hbars':       null,
           'chart.key':                    null,
           'chart.key.background':         'white',
           'chart.key.position':           'graph',
           'chart.key.shadow':             false,
           'chart.key.shadow.color':       '#666',
           'chart.key.shadow.blur':        3,
           'chart.key.shadow.offsetx':     2,
           'chart.key.shadow.offsety':     2,
           'chart.key.position.gutter.boxed':false,
           'chart.key.position.x':         null,
           'chart.key.position.y':         null,
           'chart.key.interactive':        false,
           'chart.key.interactive.highlight.chart.stroke':'black',
           'chart.key.interactive.highlight.chart.fill':'rgba(255,255,255,0.7)',
           'chart.key.interactive.highlight.label':'rgba(255,0,0,0.2)',
           'chart.key.halign':             'right',
           'chart.key.color.shape':        'square',
           'chart.key.rounded':            true,
           'chart.key.text.size':          10,
           'chart.key.linewidth':          1,
           'chart.key.colors':             null,
           'chart.key.text.color':         'black',
           'chart.contextmenu':            null,
           'chart.units.pre':              '',
           'chart.units.post':             '',
           'chart.scale.decimals':         0,
           'chart.scale.point':            '.',
           'chart.scale.thousand':         ',',
           'chart.crosshairs':             false,
           'chart.crosshairs.color':       '#333',
           'chart.crosshairs.hline':       true,
           'chart.crosshairs.vline':       true,
           'chart.linewidth':              1,
           'chart.annotatable':            false,
           'chart.annotate.color':         'black',
           'chart.zoom.factor':            1.5,
           'chart.zoom.fade.in':           true,
           'chart.zoom.fade.out':          true,
           'chart.zoom.hdir':              'right',
           'chart.zoom.vdir':              'down',
           'chart.zoom.frames':            25,
           'chart.zoom.delay':             16.666,
           'chart.zoom.shadow':            true,
           'chart.zoom.background':        true,
           'chart.resizable':              false,
           'chart.resize.handle.background': null,
           'chart.adjustable':             false,
           'chart.noaxes':                 false,
           'chart.noxaxis':                false,
           'chart.noyaxis':                false,
           'chart.events.click':           null,
           'chart.events.mousemove':       null,
           'chart.numxticks':              null,
           'chart.bevel':                  false
       }

       // Check for support
       if (!this.canvas) {
           alert('[BAR] No canvas support');
           return;
       }

       /**
        * Determine whether the chart will contain stacked or grouped bars
        */
       for (var i=0; i<data.length; ++i) {
           if (typeof(data[i]) == 'object' && !RGraph.is_null(data[i])) {
               this.stackedOrGrouped = true;
           }
       }


       /**
        * Create the dollar objects so that functions can be added to them
        */
       var linear_data = RGraph.array_linearize(data);
       for (var i=0; i<linear_data.length; ++i) {
           this['$' + i] = {};
       }


       // Store the data
       this.data = data;

       // Used to store the coords of the bars
       this.coords     = [];
       this.coords2    = [];
       this.coordsText = [];



       /**
        * This linearises the data. Doing so can make it easier to pull
        * out the appropriate data from tooltips
        */
       this.data_arr = RGraph.array_linearize(this.data);


       /**
        * Translate half a pixel for antialiasing purposes - but only if it hasn't beeen
        * done already
        */
       if (!this.canvas.__rgraph_aa_translated__) {
           this.context.translate(0.5,0.5);

           this.canvas.__rgraph_aa_translated__ = true;
       }




       ///////////////////////////////// SHORT PROPERTIES /////////////////////////////////




       var RG   = RGraph;
       var ca   = this.canvas;
       var co   = ca.getContext('2d');
       var prop = this.properties;
       //var $jq  = jQuery;




       //////////////////////////////////// METHODS ///////////////////////////////////////




       /**
        * A setter
        *
        * @param name  string The name of the property to set
        * @param value mixed  The value of the property
        */
       this.Set = function (name, value)
       {
           name = name.toLowerCase();

           /**
            * This should be done first - prepend the propertyy name with "chart." if necessary
            */
           if (name.substr(0,6) != 'chart.') {
               name = 'chart.' + name;
           }

           if (name == 'chart.labels.abovebar') {
               name = 'chart.labels.above';
           }

           if (name == 'chart.strokestyle') {
               name = 'chart.strokecolor';
           }

           /**
            * Check for xaxispos
            */
           if (name == 'chart.xaxispos' ) {
               if (value != 'bottom' && value != 'center' && value != 'top') {
                   alert('[BAR] (' + this.id + ') chart.xaxispos should be top, center or bottom. Tried to set it to: ' + value + ' Changing it to center');
                   value = 'center';
               }

               if (value == 'top') {
                   for (var i=0; i<this.data.length; ++i) {
                       if (typeof(this.data[i]) == 'number' && this.data[i] > 0) {
                           alert('[BAR] The data element with index ' + i + ' should be negative');
                       }
                   }
               }
           }

           /**
            * lineWidth doesn't appear to like a zero setting
            */
           if (name.toLowerCase() == 'chart.linewidth' && value == 0) {
               value = 0.0001;
           }

           prop[name] = value;

           return this;
       }




       /**
        * A getter
        *
        * @param name  string The name of the property to get
        */
       this.Get = function (name)
       {
           /**
            * This should be done first - prepend the property name with "chart." if necessary
            */
           if (name.substr(0,6) != 'chart.') {
               name = 'chart.' + name;
           }

           return prop[name];
       }




       /**
        * The function you call to draw the bar chart
        */
       this.Draw = function ()
       {
           // MUST be the first thing done!
           if (typeof(prop['chart.background.image']) == 'string') {
               RG.DrawBackgroundImage(this);
           }

           /**
            * Fire the onbeforedraw event
            */
           RG.FireCustomEvent(this, 'onbeforedraw');



           /**
            * Parse the colors. This allows for simple gradient syntax
            */
           if (!this.colorsParsed) {
               this.parseColors();

               // Don't want to do this again
               this.colorsParsed = true;
           }



           /**
            * This is new in May 2011 and facilitates indiviual gutter settings,
            * eg chart.gutter.left
            */
           this.gutterLeft   = prop['chart.gutter.left'];
           this.gutterRight  = prop['chart.gutter.right'];
           this.gutterTop    = prop['chart.gutter.top'];
           this.gutterBottom = prop['chart.gutter.bottom'];

           // Cache this in a class variable as it's used rather a lot

           /**
            * Check for tooltips and alert the user that they're not supported with pyramid charts
            */
           if (   (prop['chart.variant'] == 'pyramid' || prop['chart.variant'] == 'dot')
                   && typeof(prop['chart.tooltips']) == 'object'
                   && prop['chart.tooltips']
                   && prop['chart.tooltips'].length > 0) {

               alert('[BAR] (' + this.id + ') Sorry, tooltips are not supported with dot or pyramid charts');
           }

           /**
            * Stop the coords arrays from growing uncontrollably
            */
           this.coords     = [];
           this.coords2    = [];
           this.coordsText = [];

           /**
            * Work out a few things. They need to be here because they depend on things you can change before you
            * call Draw() but after you instantiate the object
            */
           this.max            = 0;
           this.grapharea      = ca.height - this.gutterTop - this.gutterBottom;
           this.halfgrapharea  = this.grapharea / 2;
           this.halfTextHeight = prop['chart.text.size'] / 2;


           // Progressively Draw the chart
           RG.background.Draw(this);




           //If it's a sketch chart variant, draw the axes first
           if (prop['chart.variant'] == 'sketch') {
               this.DrawAxes();
               this.Drawbars();
           } else {
               this.Drawbars();
               this.DrawAxes();
           }

           this.DrawLabels();


           /**
            * Draw the bevel if required
            */
           if (prop['chart.bevel'] || prop['chart.bevelled']) {
               this.DrawBevel();
           }


           // Draw the key if necessary
           if (prop['chart.key'] && prop['chart.key'].length) {
               RG.DrawKey(this, prop['chart.key'], prop['chart.colors']);
           }


           /**
            * Setup the context menu if required
            */
           if (prop['chart.contextmenu']) {
               RG.ShowContext(this);
           }




           /**
            * Draw "in graph" labels
            */
           if (prop['chart.labels.ingraph']) {
               RG.DrawInGraphLabels(this);
           }


           /**
            * This function enables resizing
            */
           if (prop['chart.resizable']) {
               RG.AllowResizing(this);
           }


           /**
            * This installs the event listeners
            */
           RG.InstallEventListeners(this);


           /**
            * Fire the RGraph ondraw event
            */
           RG.FireCustomEvent(this, 'ondraw');

           return this;
       }




       /**
        * Draws the charts axes
        */
       this.DrawAxes = function ()
       {
           if (prop['chart.noaxes']) {
               return;
           }

           var xaxispos = prop['chart.xaxispos'];
           var yaxispos = prop['chart.yaxispos'];
           var isSketch = prop['chart.variant'] == 'sketch';

           co.beginPath();
           co.strokeStyle = prop['chart.axis.color'];
           co.lineWidth   = prop['chart.axis.linewidth'] + 0.001;


           if (ISSAFARI == -1) {
               co.lineCap = 'square';
           }


           // Draw the Y axis
           if (prop['chart.noyaxis'] == false) {
               if (yaxispos == 'right') {
                   co.moveTo(ca.width - this.gutterRight + (isSketch ? 3 : 0), this.gutterTop - (isSketch ? 3 : 0));
                   co.lineTo(ca.width - this.gutterRight - (isSketch ? 2 : 0), ca.height - this.gutterBottom + (isSketch ? 5 : 0));
               } else {
                   co.moveTo(this.gutterLeft - (isSketch ? 2 : 0), this.gutterTop - (isSketch ? 5 : 0));
                   co.lineTo(this.gutterLeft - (isSketch ? 1 : 0), ca.height - this.gutterBottom + (isSketch ? 5 : 0));
               }
           }

           // Draw the X axis
           if (prop['chart.noxaxis'] == false) {
               if (xaxispos == 'center') {
                   co.moveTo(this.gutterLeft - (isSketch ? 5 : 0), Math.round(((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop + (isSketch ? 2 : 0)));
                   co.lineTo(ca.width - this.gutterRight + (isSketch ? 5 : 0), Math.round(((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop - (isSketch ? 2 : 0)));
               } else if (xaxispos == 'top') {
                   co.moveTo(this.gutterLeft - (isSketch ? 3 : 0), this.gutterTop - (isSketch ? 3 : 0));
                   co.lineTo(ca.width - this.gutterRight + (isSketch ? 5 : 0), this.gutterTop + (isSketch ? 2 : 0));
               } else {
                   co.moveTo(this.gutterLeft - (isSketch ? 5 : 0), ca.height - this.gutterBottom - (isSketch ? 2 : 0));
                   co.lineTo(ca.width - this.gutterRight + (isSketch ? 8 : 0), ca.height - this.gutterBottom + (isSketch ? 2 : 0));
               }
           }

           var numYTicks = prop['chart.numyticks'];

           // Draw the Y tickmarks
           if (prop['chart.noyaxis'] == false && !isSketch) {
               var yTickGap = (ca.height - this.gutterTop - this.gutterBottom) / numYTicks;
               var xpos     = yaxispos == 'left' ? this.gutterLeft : ca.width - this.gutterRight;

               if (this.properties['chart.numyticks'] > 0) {
                   for (y=this.gutterTop;
                        xaxispos == 'center' ? y <= (ca.height - this.gutterBottom) : y < (ca.height - this.gutterBottom + (xaxispos == 'top' ? 1 : 0));
                        y += yTickGap) {

                       if (xaxispos == 'center' && y == (this.gutterTop + (this.grapharea / 2))) continue;

                       // X axis at the top
                       if (xaxispos == 'top' && y == this.gutterTop) continue;

                       co.moveTo(xpos + (yaxispos == 'left' ? 0 : 0), Math.round(y));
                       co.lineTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(y));
                   }
               }

               /**
                * If the X axis is not being shown, draw an extra tick
                */
               if (prop['chart.noxaxis']) {
                   if (xaxispos == 'center') {
                       co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(ca.height / 2));
                       co.lineTo(xpos, Math.round(ca.height / 2));
                   } else if (xaxispos == 'top') {
                       co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(this.gutterTop));
                       co.lineTo(xpos, Math.round(this.gutterTop));
                   } else {
                       co.moveTo(xpos + (yaxispos == 'left' ? -3 : 3), Math.round(ca.height - this.gutterBottom));
                       co.lineTo(xpos, Math.round(ca.height - this.gutterBottom));
                   }
               }
           }


           // Draw the X tickmarks
           if (prop['chart.noxaxis'] == false && !isSketch) {

               if (typeof(prop['chart.numxticks']) == 'number') {
                   var xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / prop['chart.numxticks'];
               } else {
                   var xTickGap = (ca.width - this.gutterLeft - this.gutterRight) / this.data.length;
               }

               if (xaxispos == 'bottom') {
                   yStart   = ca.height - this.gutterBottom;
                   yEnd     = (ca.height - this.gutterBottom) + 3;
               } else if (xaxispos == 'top') {
                   yStart = this.gutterTop - 3;
                   yEnd   = this.gutterTop;
               } else if (xaxispos == 'center') {
                   yStart = ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop + 3;
                   yEnd   = ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop - 3;
               }

               yStart = yStart;
               yEnd = yEnd;

               //////////////// X TICKS ////////////////
               var noEndXTick = prop['chart.noendxtick'];

               for (x=this.gutterLeft + (yaxispos == 'left' ? xTickGap : 0),len=(ca.width - this.gutterRight + (yaxispos == 'left' ? 5 : 0)); x<len; x+=xTickGap) {

                   if (yaxispos == 'left' && !noEndXTick && x > this.gutterLeft) {
                       co.moveTo(Math.round(x), yStart);
                       co.lineTo(Math.round(x), yEnd);

                   } else if (yaxispos == 'left' && noEndXTick && x > this.gutterLeft && x < (ca.width - this.gutterRight) ) {
                       co.moveTo(Math.round(x), yStart);
                       co.lineTo(Math.round(x), yEnd);

                   } else if (yaxispos == 'right' && x < (ca.width - this.gutterRight) && !noEndXTick) {
                       co.moveTo(Math.round(x), yStart);
                       co.lineTo(Math.round(x), yEnd);

                   } else if (yaxispos == 'right' && x < (ca.width - this.gutterRight) && x > (this.gutterLeft) && noEndXTick) {
                       co.moveTo(Math.round(x), yStart);
                       co.lineTo(Math.round(x), yEnd);
                   }
               }

               if (prop['chart.noyaxis'] || prop['chart.numxticks'] == null) {
                   if (typeof(prop['chart.numxticks']) == 'number' && prop['chart.numxticks'] > 0) {
                       co.moveTo(Math.round(this.gutterLeft), yStart);
                       co.lineTo(Math.round(this.gutterLeft), yEnd);
                   }
               }

               //////////////// X TICKS ////////////////
           }

           /**
            * If the Y axis is not being shown, draw an extra tick
            */
           if (prop['chart.noyaxis'] && prop['chart.noxaxis'] == false && prop['chart.numxticks'] == null) {
               if (xaxispos == 'center') {
                   co.moveTo(Math.round(this.gutterLeft), (ca.height / 2) - 3);
                   co.lineTo(Math.round(this.gutterLeft), (ca.height / 2) + 3);
               } else {
                   co.moveTo(Math.round(this.gutterLeft), ca.height - this.gutterBottom);
                   co.lineTo(Math.round(this.gutterLeft), ca.height - this.gutterBottom + 3);
               }
           }

           co.stroke();
       }



       /**
        * Draws the bars
        */
       this.Drawbars = function ()
       {
           // Variable "caching" so the context can be accessed as a local variable
           var ca   = this.canvas;
           var co   = this.context;
           var prop = this.properties;

           co.lineWidth   = prop['chart.linewidth'];
           co.strokeStyle = prop['chart.strokecolor'];
           co.fillStyle   = prop['chart.colors'][0];
           var prevX      = 0;
           var prevY      = 0;
           var decimals   = prop['chart.scale.decimals'];

           /**
            * Work out the max value
            */
           if (prop['chart.ymax']) {

               this.scale2 = RGraph.getScale2(this, {
                   'max':prop['chart.ymax'],
                   'strict': true,
                   'min':prop['chart.ymin'],
                   'scale.thousand':prop['chart.scale.thousand'],
                   'scale.point':prop['chart.scale.point'],
                   'scale.decimals':prop['chart.scale.decimals'],
                   'ylabels.count':prop['chart.ylabels.count'],
                   'scale.round':prop['chart.scale.round'],
                   'units.pre': prop['chart.units.pre'],
                   'units.post': prop['chart.units.post']
               });

           } else {

               for (i=0; i<this.data.length; ++i) {
                   if (typeof(this.data[i]) == 'object') {
                       var value = prop['chart.grouping'] == 'grouped' ? Number(RGraph.array_max(this.data[i], true)) : Number(RGraph.array_sum(this.data[i])) ;

                   } else {
                       var value = Number(this.data[i]);
                   }

                   this.max = Math.max(Math.abs(this.max), Math.abs(value));
               }

               this.scale2 = RGraph.getScale2(this, {
                   'max':this.max,
                   'min':prop['chart.ymin'],
                   'scale.thousand':prop['chart.scale.thousand'],
                   'scale.point':prop['chart.scale.point'],
                   'scale.decimals':prop['chart.scale.decimals'],
                   'ylabels.count':prop['chart.ylabels.count'],
                   'scale.round':prop['chart.scale.round'],
                   'units.pre': prop['chart.units.pre'],
                   'units.post': prop['chart.units.post']
               });

               this.max = this.scale2.max;
           }
           /**
            * if the chart is adjustable fix the scale so that it doesn't change.
            */
           if (prop['chart.adjustable'] && !prop['chart.ymax']) {
               this.Set('chart.ymax', this.scale2.max);
           }

           /**
            * Draw horizontal bars here
            */
           if (prop['chart.background.hbars'] && prop['chart.background.hbars'].length > 0) {
               RGraph.DrawBars(this);
           }

           var variant = prop['chart.variant'];

           /**
            * Draw the 3D axes is necessary
            */
           if (variant == '3d') {
               RG.Draw3DAxes(this);
           }

           /**
            * Get the variant once, and draw the bars, be they regular, stacked or grouped
            */

           // Get these variables outside of the loop
           var xaxispos      = prop['chart.xaxispos'];
           var width         = (ca.width - this.gutterLeft - this.gutterRight ) / this.data.length;
           var orig_height   = height;
           var hmargin       = prop['chart.hmargin'];
           var shadow        = prop['chart.shadow'];
           var shadowColor   = prop['chart.shadow.color'];
           var shadowBlur    = prop['chart.shadow.blur'];
           var shadowOffsetX = prop['chart.shadow.offsetx'];
           var shadowOffsetY = prop['chart.shadow.offsety'];
           var strokeStyle   = prop['chart.strokecolor'];
           var colors        = prop['chart.colors'];
           var sequentialColorIndex = 0;

           for (i=0,len=this.data.length; i<len; i+=1) {

               // Work out the height
               //The width is up outside the loop
               var height = ((RGraph.array_sum(this.data[i]) < 0 ? RGraph.array_sum(this.data[i]) + this.scale2.min : RGraph.array_sum(this.data[i]) - this.scale2.min) / (this.scale2.max - this.scale2.min) ) * (ca.height - this.gutterTop - this.gutterBottom);

               // Half the height if the Y axis is at the center
               if (xaxispos == 'center') {
                   height /= 2;
               }

               var x = (i * width) + this.gutterLeft;
               var y = xaxispos == 'center' ? ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop - height
                       : ca.height - height - this.gutterBottom;

               // xaxispos is top
               if (xaxispos == 'top') {
                   y = this.gutterTop + Math.abs(height);
               }


               // Account for negative lengths - Some browsers (eg Chrome) don't like a negative value
               if (height < 0) {
                   y += height;
                   height = Math.abs(height);
               }

               /**
                * Turn on the shadow if need be
                */
               if (shadow) {
                   co.shadowColor   = shadowColor;
                   co.shadowBlur    = shadowBlur;
                   co.shadowOffsetX = shadowOffsetX;
                   co.shadowOffsetY = shadowOffsetY;
               }

               /**
                * Draw the bar
                */
               co.beginPath();
               if (typeof(this.data[i]) == 'number') {

                   var barWidth = width - (2 * hmargin);

                   /**
                    * Check for a negative bar width
                    */
                   if (barWidth < 0) {
                       alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');
                   }

                   // Set the fill color
                   co.strokeStyle = strokeStyle;
                   co.fillStyle = colors[0];

                   /**
                    * Sequential colors
                    */
                   if (prop['chart.colors.sequential']) {
                       co.fillStyle = colors[i];
                   }

                   if (variant == 'sketch') {

                       co.lineCap = 'round';

                       var sketchOffset = 3;

                       co.beginPath();

                       co.strokeStyle = colors[0];

                       /**
                        * Sequential colors
                        */
                       if (prop['chart.colors.sequential']) {
                           co.strokeStyle = colors[i];
                       }

                       // Left side
                       co.moveTo(x + hmargin + 2, y + height - 2);
                       co.lineTo(x + hmargin -    1, y - 4);

                       // The top
                       co.moveTo(x + hmargin - 3, y + -2 + (this.data[i] < 0 ? height : 0));
                       co.bezierCurveTo(
                               x + ((hmargin + width) * 0.33),
                               y + 15 + (this.data[i] < 0 ? height - 10: 0),
                               x + ((hmargin + width) * 0.66),
                               y + 5 + (this.data[i] < 0 ? height - 10 : 0),x + hmargin + width + -1, y + 0 + (this.data[i] < 0 ? height : 0)
                       );


                       // The right side
                       co.moveTo(x + hmargin + width - 5, y  - 5);
                       co.lineTo(x + hmargin + width - 3, y + height - 3);

                       if (prop['chart.variant.sketch.verticals']) {
                           for (var r=0.2; r<=0.8; r+=0.2) {
                               co.moveTo(x + hmargin + width + (r > 0.4 ? -1 : 3) - (r * width),y - 1);
                               co.lineTo(x + hmargin + width - (r > 0.4 ? 1 : -1) - (r * width), y + height + (r == 0.2 ? 1 : -2));
                           }
                       }

                       co.stroke();

                       // Regular bar
                   } else if (variant == 'bar' || variant == '3d' || variant == 'glass' || variant == 'bevel') {

                       if (RGraph.isOld() && shadow) {
                           this.DrawIEShadow([x + hmargin, y, barWidth, height]);
                       }

                       if (variant == 'glass') {
                           RGraph.filledCurvyRect(co, x + hmargin, y, barWidth, height, 3, this.data[i] > 0, this.data[i] > 0, this.data[i] < 0, this.data[i] < 0);
                           RGraph.strokedCurvyRect(co, x + hmargin, y, barWidth, height, 3, this.data[i] > 0, this.data[i] > 0, this.data[i] < 0, this.data[i] < 0);
                       } else {
                           // On 9th April 2013 these two were swapped around so that the stroke happens SECOND so that any
                           // shadow that is cast by the fill does not overwrite the stroke

                           co.beginPath();
                           co.rect(x + hmargin, y, barWidth, height);
                           co.fill();

                           // Turn the shadow off so that the stroke doesn't cast any "extra" shadow
                           // that would show inside the bar
                           RG.NoShadow(this);

                           co.beginPath();
                           co.rect(x + hmargin, y, barWidth, height);
                           co.stroke();
                       }

                       // 3D effect
                       if (variant == '3d') {

                           var prevStrokeStyle = co.strokeStyle;
                           var prevFillStyle   = co.fillStyle;

                           // Draw the top
                           co.beginPath();
                           co.moveTo(x + hmargin, y);
                           co.lineTo(x + hmargin + 10, y - 5);
                           co.lineTo(x + hmargin + 10 + barWidth, y - 5);
                           co.lineTo(x + hmargin + barWidth, y);
                           co.closePath();

                           co.stroke();
                           co.fill();

                           // Draw the right hand side
                           co.beginPath();
                           co.moveTo(x + hmargin + barWidth, y);
                           co.lineTo(x + hmargin + barWidth + 10, y - 5);
                           co.lineTo(x + hmargin + barWidth + 10, y + height - 5);
                           co.lineTo(x + hmargin + barWidth, y + height);
                           co.closePath();

                           co.stroke();
                           co.fill();

                           // Draw the darker top section
                           co.beginPath();
                           co.fillStyle = 'rgba(255,255,255,0.3)';
                           co.moveTo(x + hmargin, y);
                           co.lineTo(x + hmargin + 10, y - 5);
                           co.lineTo(x + hmargin + 10 + barWidth, y - 5);
                           co.lineTo(x + hmargin + barWidth, y);
                           co.lineTo(x + hmargin, y);
                           co.closePath();

                           co.stroke();
                           co.fill();

                           // Draw the darker right side section
                           co.beginPath();
                           co.fillStyle = 'rgba(0,0,0,0.4)';
                           co.moveTo(x + hmargin + barWidth, y);
                           co.lineTo(x + hmargin + barWidth + 10, y - 5);
                           co.lineTo(x + hmargin + barWidth + 10, y - 5 + height);
                           co.lineTo(x + hmargin + barWidth, y + height);
                           co.lineTo(x + hmargin + barWidth, y);
                           co.closePath();

                           co.stroke();
                           co.fill();

                           co.strokeStyle = prevStrokeStyle;
                           co.fillStyle   = prevFillStyle;

                           // Glass variant
                       } else if (variant == 'glass') {

                           var grad = co.createLinearGradient(x + hmargin,y,x + hmargin + (barWidth / 2),y);
                           grad.addColorStop(0, 'rgba(255,255,255,0.9)');
                           grad.addColorStop(1, 'rgba(255,255,255,0.5)');

                           co.beginPath();
                           co.fillStyle = grad;
                           co.fillRect(x + hmargin + 2,y + (this.data[i] > 0 ? 2 : 0),(barWidth / 2) - 2,height - 2);
                           co.fill();
                       }

                       // This bit draws the text labels that appear above the bars if requested
                       if (prop['chart.labels.above']) {

                           // Turn off any shadow
                           if (shadow) {
                               RGraph.NoShadow(this);
                           }

                           var yPos = y - 3;
                           var xPos = x + hmargin + (barWidth / 2);

                           // Account for negative bars
                           if (this.data[i] < 0) {
                               yPos += height + 6 + (prop['chart.text.size']);
                           }

                           // Account for chart.xaxispos=top
                           if (prop['chart.xaxispos'] == 'top') {
                               yPos = this.gutterTop + height + 6 + (typeof(prop['chart.labels.above.size']) == 'number' ? prop['chart.labels.above.size'] : prop['chart.text.size'] - 4);
                           }

                           // Account for chart.variant=3d
                           if (prop['chart.variant'] == '3d') {
                               yPos -= 3;
                               xPos += 5;
                           }

                           // Angled above labels
                           if (this.properties['chart.labels.above.angle']) {
                               var angle = -45;
                               var halign = 'left';
                               var valign = 'center';
                           } else {
                               var angle = 0;
                               var halign = 'center';
                               var valign = 'bottom';
                           }

                           // Above labels color
                           if (typeof this.properties['chart.labels.above.color'] == 'string') {
                               co.fillStyle = prop['chart.labels.above.color'];
                           } else {
                               co.fillStyle = prop['chart.text.color'];
                           }

                           RGraph.Text2(this, {'font': prop['chart.text.font'],
                               'size': typeof(prop['chart.labels.above.size']) == 'number' ? prop['chart.labels.above.size'] : prop['chart.text.size'] - 3,
                               'x': xPos,
                               'y': yPos,
                               'text': RGraph.number_format(this, Number(this.data[i]).toFixed(prop['chart.labels.above.decimals']),prop['chart.units.pre'],prop['chart.units.post']),
                               'halign': halign,
                               'marker': false,
                               'valign': valign,
                               'angle': angle,
                               'tag': 'labels.above'
                           });
                       }

                       // Dot chart
                   } else if (variant == 'dot') {

                       co.beginPath();
                       co.moveTo(x + (width / 2), y);
                       co.lineTo(x + (width / 2), y + height);
                       co.stroke();

                       co.beginPath();
                       co.fillStyle = this.properties['chart.colors'][i];
                       co.arc(x + (width / 2), y + (this.data[i] > 0 ? 0 : height), 2, 0, 6.28, 0);

                       // Set the colour for the dots
                       co.fillStyle = prop['chart.colors'][0];

                       /**
                        * Sequential colors
                        */
                       if (prop['chart.colors.sequential']) {
                           co.fillStyle = colors[i];
                       }

                       co.stroke();
                       co.fill();



                       // Unknown variant type
                   } else {
                       alert('[BAR] Warning! Unknown chart.variant: ' + variant);
                   }

                   this.coords.push([x + hmargin, y, width - (2 * hmargin), height]);

                   if (typeof this.coords2[i] == 'undefined') {
                       this.coords2[i] = [];
                   }
                   this.coords2[i].push([x + hmargin, y, width - (2 * hmargin), height]);


                   /**
                    * Stacked bar
                    */
               } else if (this.data[i] && typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'stacked') {

                   if (this.scale2.min) {
                       alert("[ERROR] Stacked Bar charts with a Y min are not supported");
                   }

                   var barWidth     = width - (2 * hmargin);
                   var redrawCoords = [];// Necessary to draw if the shadow is enabled
                   var startY       = 0;
                   var dataset      = this.data[i];

                   /**
                    * Check for a negative bar width
                    */
                   if (barWidth < 0) {
                       alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');
                   }

                   for (j=0; j<dataset.length; ++j) {

                       // Stacked bar chart and X axis pos in the middle - poitless since negative values are not permitted
                       if (xaxispos == 'center') {
                           alert("[BAR] It's pointless having the X axis position at the center on a stacked bar chart.");
                           return;
                       }

                       // Negative values not permitted for the stacked chart
                       if (this.data[i][j] < 0) {
                           alert('[BAR] Negative values are not permitted with a stacked bar chart. Try a grouped one instead.');
                           return;
                       }

                       /**
                        * Set the fill and stroke colors
                        */
                       co.strokeStyle = strokeStyle
                       co.fillStyle = colors[j];

                       if (prop['chart.colors.reverse']) {
                           co.fillStyle = colors[this.data[i].length - j - 1];
                       }

                       if (prop['chart.colors.sequential'] && colors[sequentialColorIndex]) {
                           co.fillStyle = colors[sequentialColorIndex++];
                       } else if (prop['chart.colors.sequential']) {
                           co.fillStyle = colors[sequentialColorIndex - 1];
                       }

                       var height = (dataset[j] / this.scale2.max) * (ca.height - this.gutterTop - this.gutterBottom );

                       // If the X axis pos is in the center, we need to half the  height
                       if (xaxispos == 'center') {
                           height /= 2;
                       }

                       var totalHeight = (RGraph.array_sum(dataset) / this.scale2.max) * (ca.height - hmargin - this.gutterTop - this.gutterBottom);

                       /**
                        * Store the coords for tooltips
                        */
                       this.coords.push([x + hmargin, y, width - (2 * hmargin), height]);
                       if (typeof this.coords2[i] == 'undefined') {
                           this.coords2[i] = [];
                       }
                       this.coords2[i].push([x + hmargin, y, width - (2 * hmargin), height]);

                       // MSIE shadow
                       if (RGraph.isOld() && shadow) {
                           this.DrawIEShadow([x + hmargin, y, width - (2 * hmargin), height + 1]);
                       }

                       if (height > 0) {
                           co.strokeRect(x + hmargin, y, width - (2 * hmargin), height);
                           co.fillRect(x + hmargin, y, width - (2 * hmargin), height);
                       }


                       if (j == 0) {
                           var startY = y;
                           var startX = x;
                       }

                       /**
                        * Store the redraw coords if the shadow is enabled
                        */
                       if (shadow) {
                           redrawCoords.push([x + hmargin, y, width - (2 * hmargin), height, co.fillStyle]);
                       }

                       /**
                        * Stacked 3D effect
                        */
                       if (variant == '3d') {

                           var prevFillStyle = co.fillStyle;
                           var prevStrokeStyle = co.strokeStyle;


                           // Draw the top side
                           if (j == 0) {
                               co.beginPath();
                               co.moveTo(startX + hmargin, y);
                               co.lineTo(startX + 10 + hmargin, y - 5);
                               co.lineTo(startX + 10 + barWidth + hmargin, y - 5);
                               co.lineTo(startX + barWidth + hmargin, y);
                               co.closePath();

                               co.fill();
                               co.stroke();
                           }

                           // Draw the side section
                           co.beginPath();
                           co.moveTo(startX + barWidth + hmargin, y);
                           co.lineTo(startX + barWidth + hmargin + 10, y - 5);
                           co.lineTo(startX + barWidth + hmargin + 10, y - 5 + height);
                           co.lineTo(startX + barWidth + hmargin , y + height);
                           co.closePath();

                           co.fill();
                           co.stroke();

                           // Draw the darker top side
                           if (j == 0) {
                               co.fillStyle = 'rgba(255,255,255,0.3)';
                               co.beginPath();
                               co.moveTo(startX + hmargin, y);
                               co.lineTo(startX + 10 + hmargin, y - 5);
                               co.lineTo(startX + 10 + barWidth + hmargin, y - 5);
                               co.lineTo(startX + barWidth + hmargin, y);
                               co.closePath();

                               co.fill();
                               co.stroke();
                           }

                           // Draw the darker side section
                           co.fillStyle = 'rgba(0,0,0,0.4)';
                           co.beginPath();
                           co.moveTo(startX + barWidth + hmargin, y);
                           co.lineTo(startX + barWidth + hmargin + 10, y - 5);
                           co.lineTo(startX + barWidth + hmargin + 10, y - 5 + height);
                           co.lineTo(startX + barWidth + hmargin , y + height);
                           co.closePath();

                           co.fill();
                           co.stroke();

                           co.strokeStyle = prevStrokeStyle;
                           co.fillStyle = prevFillStyle;
                       }

                       y += height;
                   }

                   // This bit draws the text labels that appear above the bars if requested
                   if (prop['chart.labels.above']) {

                       // Turn off any shadow
                       RG.NoShadow(this);

                       // Above labels color
                       if (typeof this.properties['chart.labels.above.color'] == 'string') {
                           co.fillStyle = prop['chart.labels.above.color'];
                       } else {
                           co.fillStyle = prop['chart.text.color'];
                       }

                       // Angled above labels
                       if (prop['chart.labels.above.angle']) {
                           var angle = -45;
                           var halign = 'left';
                           var valign = 'center';
                       } else {
                           var angle = 0;
                           var halign = 'center';
                           var valign = 'bottom';
                       }

                       RGraph.Text2(this,{'font': prop['chart.text.font'],
                           'size': typeof(prop['chart.labels.above.size']) == 'number' ? prop['chart.labels.above.size'] : prop['chart.text.size'] - 3,
                           'x': startX + (barWidth / 2) + prop['chart.hmargin'],
                           'y': startY - (prop['chart.shadow'] && prop['chart.shadow.offsety'] < 0 ? 7 : 4) - (prop['chart.variant'] == '3d' ? 5 : 0),
                           'text': String(prop['chart.units.pre'] + RGraph.array_sum(this.data[i]).toFixed(prop['chart.labels.above.decimals']) + prop['chart.units.post']),
                           'angle': angle,
                           'valign': valign,
                           'halign': halign,
                           'tag': 'labels.above'
                       });


                       // Turn any shadow back on
                       if (shadow) {
                           co.shadowColor   = shadowColor;
                           co.shadowBlur    = shadowBlur;
                           co.shadowOffsetX = shadowOffsetX;
                           co.shadowOffsetY = shadowOffsetY;
                       }
                   }


                   /**
                    * Redraw the bars if the shadow is enabled due to hem being drawn from the bottom up, and the
                    * shadow spilling over to higher up bars
                    */
                   if (shadow) {

                       RGraph.NoShadow(this);

                       for (k=0; k<redrawCoords.length; ++k) {
                           co.strokeStyle = strokeStyle;
                           co.fillStyle = redrawCoords[k][4];
                           co.strokeRect(redrawCoords[k][0], redrawCoords[k][1], redrawCoords[k][2], redrawCoords[k][3]);
                           co.fillRect(redrawCoords[k][0], redrawCoords[k][1], redrawCoords[k][2], redrawCoords[k][3]);

                           co.stroke();
                           co.fill();
                       }

                       // Reset the redraw coords to be empty
                       redrawCoords = [];
                   }
                   /**
                    * Grouped bar
                    */
               } else if (this.data[i] && typeof(this.data[i]) == 'object' && prop['chart.grouping'] == 'grouped') {

                   var redrawCoords = [];
                   co.lineWidth = prop['chart.linewidth'];

                   for (j=0; j<this.data[i].length; ++j) {

                       // Set the fill and stroke colors
                       co.strokeStyle = strokeStyle;
                       co.fillStyle   = colors[j];

                       /**
                        * Sequential colors
                        */
                       if (prop['chart.colors.sequential'] && colors[sequentialColorIndex]) {
                           co.fillStyle = colors[sequentialColorIndex++];
                       } else if (prop['chart.colors.sequential']) {
                           co.fillStyle = colors[sequentialColorIndex - 1];
                       }

                       var individualBarWidth = (width - (2 * hmargin)) / this.data[i].length;
                       var height = ((this.data[i][j] + (this.data[i][j] < 0 ? this.scale2.min : (-1 * this.scale2.min) )) / (this.scale2.max - this.scale2.min) ) * (ca.height - this.gutterTop - this.gutterBottom );
                       var groupedMargin = prop['chart.hmargin.grouped'];
                       var startX = x + hmargin + (j * individualBarWidth);

                       /**
                        * Check for a negative bar width
                        */
                       if (individualBarWidth < 0) {
                           alert('[RGRAPH] Warning: you have a negative bar width. This may be caused by the chart.hmargin being too high or the width of the canvas not being sufficient.');
                       }

                       // If the X axis pos is in the center, we need to half the  height
                       if (xaxispos == 'center') {
                           height /= 2;
                       }

                       /**
                        * Determine the start positioning for the bar
                        */
                       if (xaxispos == 'top') {
                           var startY = this.gutterTop;
                           var height = Math.abs(height);

                       } else if (xaxispos == 'center') {
                           var startY = this.gutterTop + (this.grapharea / 2) - height;

                       } else {
                           var startY = ca.height - this.gutterBottom - height;
                           var height = Math.abs(height);
                       }

                       /**
                        * Draw MSIE shadow
                        */
                       if (RGraph.isOld() && shadow) {
                           this.DrawIEShadow([startX, startY, individualBarWidth, height]);
                       }

                       co.strokeRect(startX + groupedMargin, startY, individualBarWidth - (2 * groupedMargin), height);
                       co.fillRect(startX + groupedMargin, startY, individualBarWidth - (2 * groupedMargin), height);
                       y += height;



                       /**
                        * Grouped 3D effect
                        */
                       if (variant == '3d') {
                           var prevFillStyle = co.fillStyle;
                           var prevStrokeStyle = co.strokeStyle;

                           // Draw the top side
                           co.beginPath();
                           co.moveTo(startX, startY);
                           co.lineTo(startX + 10, startY - 5);
                           co.lineTo(startX + 10 + individualBarWidth, startY - 5);
                           co.lineTo(startX + individualBarWidth, startY);
                           co.closePath();

                           co.fill();
                           co.stroke();

                           // Draw the side section
                           co.beginPath();
                           co.moveTo(startX + individualBarWidth, startY);
                           co.lineTo(startX + individualBarWidth + 10, startY - 5);
                           co.lineTo(startX + individualBarWidth + 10, startY - 5 + height);
                           co.lineTo(startX + individualBarWidth , startY + height);
                           co.closePath();

                           co.fill();
                           co.stroke();


                           // Draw the darker top side
                           co.fillStyle = 'rgba(255,255,255,0.3)';
                           co.beginPath();
                           co.moveTo(startX, startY);
                           co.lineTo(startX + 10, startY - 5);
                           co.lineTo(startX + 10 + individualBarWidth, startY - 5);
                           co.lineTo(startX + individualBarWidth, startY);
                           co.closePath();

                           co.fill();
                           co.stroke();

                           // Draw the darker side section
                           co.fillStyle = 'rgba(0,0,0,0.4)';
                           co.beginPath();
                           co.moveTo(startX + individualBarWidth, startY);
                           co.lineTo(startX + individualBarWidth + 10, startY - 5);
                           co.lineTo(startX + individualBarWidth + 10, startY - 5 + height);
                           co.lineTo(startX + individualBarWidth , startY + height);
                           co.closePath();

                           co.fill();
                           co.stroke();

                           co.strokeStyle = prevStrokeStyle;
                           co.fillStyle   = prevFillStyle;
                       }

                       if (height < 0) {
                           height = Math.abs(height);
                           startY = startY - height;
                       }

                       this.coords.push([startX + groupedMargin, startY, individualBarWidth - (2 * groupedMargin), height]);
                       if (typeof this.coords2[i] == 'undefined') {
                           this.coords2[i] = [];
                       }

                       this.coords2[i].push([startX + groupedMargin, startY, individualBarWidth - (2 * groupedMargin), height]);

                       // Facilitate shadows going to the left
                       if (prop['chart.shadow']) {
                           redrawCoords.push([startX + groupedMargin, startY, individualBarWidth - (2 * groupedMargin), height, co.fillStyle]);
                       }


                       // This bit draws the text labels that appear above the bars if requested
                       if (prop['chart.labels.above']) {

                           co.strokeStyle = 'rgba(0,0,0,0)';

                           // Turn off any shadow
                           if (shadow) {
                               RGraph.NoShadow(this);
                           }

                           var yPos = y - 3;

                           // Angled above labels
                           if (prop['chart.labels.above.angle']) {
                               var angle = -45;
                               var halign = 'left';
                               var valign = 'center';
                           } else {

                               var angle = 0;
                               var halign = 'center';
                               var valign = 'bottom';

                               // Account for negative bars
                               if (this.data[i][j] < 0 || prop['chart.xaxispos'] == 'top') {
                                   yPos = startY + height + 6;
                                   var valign = 'top';
                               } else {
                                   yPos = startY;
                               }
                           }

                           // Above labels color
                           if (typeof this.properties['chart.labels.above.color'] == 'string') {
                               co.fillStyle = prop['chart.labels.above.color'];
                           } else {
                               co.fillStyle = prop['chart.text.color'];
                           }

                           RGraph.Text2(this, {'font': prop['chart.text.font'],
                               'size': typeof(prop['chart.labels.above.size']) == 'number' ? prop['chart.labels.above.size'] : prop['chart.text.size'] - 3,
                               'x': startX + (individualBarWidth / 2),
                               'y': yPos - 3,
                               'text': RGraph.number_format(this, this.data[i][j].toFixed(prop['chart.labels.above.decimals'])),
                               'halign': halign,
                               'valign': valign,
                               'angle':angle,
                               'tag': 'labels.above'
                           });

                           // Turn any shadow back on
                           if (shadow) {
                               co.shadowColor   = shadowColor;
                               co.shadowBlur    = shadowBlur;
                               co.shadowOffsetX = shadowOffsetX;
                               co.shadowOffsetY = shadowOffsetY;
                           }
                       }
                   }

                   /**
                    * Redraw the bar if shadows are going to the left
                    */
                   if (redrawCoords.length) {

                       RGraph.NoShadow(this);

                       co.lineWidth = prop['chart.linewidth'];

                       co.beginPath();
                       for (var j=0; j<redrawCoords.length; ++j) {

                           co.fillStyle   = redrawCoords[j][4];
                           co.strokeStyle = prop['chart.strokecolor'];

                           co.fillRect(redrawCoords[j][0], redrawCoords[j][1], redrawCoords[j][2], redrawCoords[j][3]);
                           co.strokeRect(redrawCoords[j][0], redrawCoords[j][1], redrawCoords[j][2], redrawCoords[j][3]);
                       }
                       co.fill();
                       co.stroke();

                       redrawCoords = [];
                   }
               } else {
                   this.coords.push([]);
               }

               co.closePath();
           }

           /**
            * Turn off any shadow
            */
           RGraph.NoShadow(this);
       }



       /**
        * Draws the labels for the graph
        */
       this.DrawLabels = function ()
       {
           // Variable "caching" so the context can be accessed as a local variable
           var ca      = this.canvas;
           var co      = this.context;
           var prop    = this.properties;
           var context = co;

           var text_angle = prop['chart.text.angle'];
           var text_size  = prop['chart.text.size'];
           var labels     = prop['chart.labels'];


           // Draw the Y axis labels:
           if (prop['chart.ylabels']) {
               if (prop['chart.xaxispos'] == 'top')    this.Drawlabels_top();
               if (prop['chart.xaxispos'] == 'center') this.Drawlabels_center();
               if (prop['chart.xaxispos'] == 'bottom') this.Drawlabels_bottom();
           }

           /**
            * The X axis labels
            */
           if (typeof(labels) == 'object' && labels) {

               var yOffset = Number(prop['chart.xlabels.offset']);

               /**
                * Text angle
                */
               if (prop['chart.text.angle'] != 0) {
                   var valign =  'center';
                   var halign =  'right';
                   var angle  = 0 - prop['chart.text.angle'];
               } else {
                   var valign =  'top';
                   var halign =  'center';
                   var angle  = 0;
               }

               // Draw the X axis labels
               co.fillStyle = prop['chart.text.color'];

               // How wide is each bar
               var barWidth = (ca.width - this.gutterRight - this.gutterLeft) / labels.length;

               // Reset the xTickGap
               xTickGap = (ca.width - this.gutterRight - this.gutterLeft) / labels.length

               // Draw the X tickmarks
               var i=0;
               var font = prop['chart.text.font'];

               for (x=this.gutterLeft + (xTickGap / 2); x<=ca.width - this.gutterRight; x+=xTickGap) {

                   RGraph.Text2(this, {'font': font,
                       'size': text_size,
                       'x': x,
                       'y': prop['chart.xaxispos'] == 'top' ? this.gutterTop - yOffset - 5: (ca.height - this.gutterBottom) + yOffset + 3,
                       'text': String(labels[i++]),
                       'valign': prop['chart.xaxispos'] == 'top' ? 'bottom' : valign,
                       'halign': halign,
                       'tag':'label',
                       'marker':false,
                       'angle':angle,
                       'tag': 'labels'
                   });
               }
           }

           /**
            * If chart.labels.above.specific is specified, draw them
            */
           if (prop['chart.labels.above.specific']) {

               var labels = prop['chart.labels.above.specific'];

               for (var i=0; i<this.coords.length; ++i) {

                   var xaxispos = prop['chart.xaxispos'];
                   var coords = this.coords[i];
                   var value  = this.data_arr[i];
                   var valign =  (value >=0 && xaxispos != 'top') ? 'bottom' : 'top';
                   var halign = 'center';
                   var text   = labels[i];


                   if (text && text.toString().length > 0) {
                       RGraph.Text2(this, {'font': prop['chart.text.font'],
                           'size': prop['chart.labels.above.size'] ? prop['chart.labels.above.size'] : prop['chart.text.size'],
                           'x': coords[0] + (coords[2] / 2),
                           'y': (value >=0 && xaxispos != 'top') ? coords[1] - 5 : coords[1] + coords[3] + 3,
                           'text': String(labels[i]),
                           'valign': valign,
                           'halign': halign,
                           'tag': 'labels.above'
                       });
                   }
               }
           }
       }



       /**
        * Draws the X axis at the top
        */
       this.Drawlabels_top = function ()
       {
           var ca   = this.canvas;
           var co   = this.context;
           var prop = this.properties;

           co.beginPath();
           co.fillStyle   = prop['chart.text.color'];
           co.strokeStyle = 'black';

           if (prop['chart.xaxispos'] == 'top') {

               var context    = co;
               var text_size  = prop['chart.text.size'];
               var units_pre  = prop['chart.units.pre'];
               var units_post = prop['chart.units.post'];
               var align      = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';
               var font       = prop['chart.text.font'];
               var numYLabels = prop['chart.ylabels.count'];
               var ymin       = prop['chart.ymin'];

               if (prop['chart.ylabels.inside'] == true) {
                   var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;
                   var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';
                   var boxed = true;
               } else {
                   var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;
                   var boxed = false;
               }

               /**
                * Draw specific Y labels here so that the local variables can be reused
                */
               if (typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific']) {

                   var labels = RGraph.array_reverse(prop['chart.ylabels.specific']);
                   var grapharea = ca.height - this.gutterTop - this.gutterBottom;

                   for (var i=0; i<labels.length; ++i) {

                       var y = this.gutterTop + (grapharea * (i / labels.length)) + (grapharea / labels.length);

                       RGraph.Text2(this, {'font': font,
                           'size': text_size,
                           'x': xpos,
                           'y': y,
                           'text': String(labels[i]),
                           'valign': 'center',
                           'halign': align,
                           'bordered':boxed,
                           'tag': 'scale'
                       });
                   }

                   return;
               }







               /**
                * Draw the scale
                */
               var labels = this.scale2.labels;
               for (var i=0; i<labels.length; ++i) {
                   RGraph.Text2(this, {'font': font,
                       'size':text_size,
                       'x':xpos,
                       'y':this.gutterTop + ((this.grapharea / labels.length) * (i + 1)),
                       'text': '-' + labels[i],
                       'valign': 'center',
                       'halign': align,
                       'bordered': boxed,
                       'tag':'scale'});
               }








               /**
                * Show the minimum value if its not zero
                */
               if (prop['chart.ymin'] != 0 || prop['chart.noxaxis'] || prop['chart.scale.zerostart']) {

                   RGraph.Text2(this, {'font': font,
                       'size': text_size,
                       'x': xpos,
                       'y': this.gutterTop,
                       'text': (this.scale2.min != 0 ? '-' : '') + RGraph.number_format(this,(this.scale2.min.toFixed((prop['chart.scale.decimals']))), units_pre, units_post),
                       'valign': 'center',
                       'halign': align,
                       'bordered': boxed,
                       'tag': 'scale'});
               }

           }

           co.fill();
       }



       /**
        * Draws the X axis in the middle
        */
       this.Drawlabels_center = function ()
       {
           var ca   = this.canvas;
           var co   = this.context;
           var prop = this.properties;

           var font       = prop['chart.text.font'];
           var numYLabels = prop['chart.ylabels.count'];

           co.fillStyle = prop['chart.text.color'];

           if (prop['chart.xaxispos'] == 'center') {

               /**
                * Draw the top labels
                */
               var text_size  = prop['chart.text.size'];
               var units_pre  = prop['chart.units.pre'];
               var units_post = prop['chart.units.post'];
               var context = co;
               var align   = '';
               var xpos    = 0;
               var boxed   = false;
               var ymin    = prop['chart.ymin'];

               co.fillStyle   = prop['chart.text.color'];
               co.strokeStyle = 'black';

               if (prop['chart.ylabels.inside'] == true) {
                   var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;
                   var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';
                   var boxed = true;
               } else {
                   var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;
                   var align = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';
                   var boxed = false;
               }












               /**
                * Draw specific Y labels here so that the local variables can be reused
                */
               if (typeof(prop['chart.ylabels.specific']) == 'object' && prop['chart.ylabels.specific']) {

                   var labels    = prop['chart.ylabels.specific'];
                   var grapharea = ca.height - this.gutterTop - this.gutterBottom;

                   // Draw the top halves labels
                   for (var i=0; i<labels.length; ++i) {

                       var y = this.gutterTop + ((grapharea / 2) / (labels.length - 1)) * i;

                       RGraph.Text2(this, {'font':font,
                           'size':text_size,
                           'x':xpos,
                           'y':y,
                           'text':String(labels[i]),
                           'valign':'center',
                           'halign':align,
                           'bordered':boxed,
                           'tag': 'scale'
                       });
                   }

                   // Draw the bottom halves labels
                   for (var i=labels.length-1; i>=1; --i) {

                       var y = this.gutterTop  + (grapharea * (i / ((labels.length - 1) * 2) )) + (grapharea / 2);

                       RG.Text2(this, {'font':font,
                           'size':text_size,
                           'x':xpos,
                           'y':y,
                           'text':String(labels[labels.length - i - 1]),
                           'valign':'center',
                           'halign':align,
                           'bordered':boxed,
                           'tag': 'scale'
                       });
                   }

                   return;
               }










               /**
                * Draw the top halfs labels
                */
               for (var i=0; i<this.scale2.labels.length; ++i) {
                   var y    = this.gutterTop + this.halfgrapharea - ((this.halfgrapharea / numYLabels) * (i + 1));
                   var text = this.scale2.labels[i];
                   RG.Text2(this, {'font':font, 'size':text_size, 'x':xpos, 'y':y, 'text': text, 'valign':'center', 'halign': align, 'bordered': boxed, 'tag':'scale'});
               }

               /**
                * Draw the bottom halfs labels
                */
               for (var i=(this.scale2.labels.length - 1); i>=0; --i) {
                   var y = this.gutterTop + ((this.halfgrapharea / numYLabels) * (i + 1)) + this.halfgrapharea;
                   var text = this.scale2.labels[i];
                   RG.Text2(this, {'font':font, 'size':text_size,'x':xpos,'y':y,'text': '-' + text,'valign':'center','halign': align,'bordered': boxed,'tag':'scale'});
               }





               /**
                * Show the minimum value if its not zero
                */
               if (this.scale2.min != 0 || prop['chart.scale.zerostart']) {
                   RG.Text2(this, {'font':font,'size':text_size, 'x':xpos, 'y':this.gutterTop + this.halfgrapharea,'text': RGraph.number_format(this,(this.scale2.min.toFixed((prop['chart.scale.decimals']))), units_pre, units_post),'valign':'center', 'valign':'center','halign': align, 'bordered': boxed, 'tag':'scale'});
               }
           }
       }




       /**
        * Draws the X axdis at the bottom (the default)
        */
       this.Drawlabels_bottom = function ()
       {
           var co   = this.context;
           var ca   = this.canvas;
           var prop = this.properties;

           var text_size  = prop['chart.text.size'];
           var units_pre  = prop['chart.units.pre'];
           var units_post = prop['chart.units.post'];
           var context    = this.context;
           var align      = prop['chart.yaxispos'] == 'left' ? 'right' : 'left';
           var font       = prop['chart.text.font'];
           var numYLabels = prop['chart.ylabels.count'];
           var ymin       = prop['chart.ymin'];

           co.beginPath();
           co.fillStyle = prop['chart.text.color'];
           co.strokeStyle = 'black';

           if (prop['chart.ylabels.inside'] == true) {
               var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft + 5 : ca.width - this.gutterRight - 5;
               var align = prop['chart.yaxispos'] == 'left' ? 'left' : 'right';
               var boxed = true;
           } else {
               var xpos  = prop['chart.yaxispos'] == 'left' ? this.gutterLeft - 5 : ca.width - this.gutterRight + 5;
               var boxed = false;
           }

           /**
            * Draw specific Y labels here so that the local variables can be reused
            */
           if (prop['chart.ylabels.specific'] && typeof(prop['chart.ylabels.specific']) == 'object') {

               var labels = prop['chart.ylabels.specific'];
               var grapharea = ca.height - this.gutterTop - this.gutterBottom;

               for (var i=0; i<labels.length; ++i) {
                   var y = this.gutterTop + (grapharea * (i / (labels.length - 1)));

                   RGraph.Text2(this, {'font':font,
                       'size':text_size,
                       'x':xpos,
                       'y':y,
                       'text': labels[i],
                       'valign':'center',
                       'halign': align,
                       'bordered': boxed,
                       'tag':'scale'
                   });
               }

               return;
           }

           var gutterTop      = this.gutterTop;
           var halfTextHeight = this.halfTextHeight;
           var scale          = this.scale;


           for (var i=0; i<numYLabels; ++i) {
               var text = this.scale2.labels[i];
               RGraph.Text2(this, {'font':font,
                   'size':text_size,
                   'x':xpos,
                   'y':this.gutterTop + this.grapharea - ((this.grapharea / numYLabels) * (i+1)),
                   'text': text,
                   'valign':'center',
                   'halign': align,
                   'bordered': boxed,
                   'tag':'scale'});
           }


           /**
            * Show the minimum value if its not zero
            */
           if (prop['chart.ymin'] != 0 || prop['chart.noxaxis'] || prop['chart.scale.zerostart']) {
               RG.Text2(this, {'font':font,
                   'size':text_size,
                   'x':xpos,
                   'y':ca.height - this.gutterBottom,
                   'text': RG.number_format(this,(this.scale2.min.toFixed((prop['chart.scale.decimals']))), units_pre, units_post),
                   'valign':'center',
                   'halign': align,
                   'bordered': boxed,
                   'tag':'scale'});
           }

           co.fill();
       }


       /**
        * This function is used by MSIE only to manually draw the shadow
        *
        * @param array coords The coords for the bar
        */
       this.DrawIEShadow = function (coords)
       {
           var co   = this.context;
           var ca   = this.canvas;
           var prop = this.properties;

           var prevFillStyle = co.fillStyle;
           var offsetx       = prop['chart.shadow.offsetx'];
           var offsety       = prop['chart.shadow.offsety'];

           co.lineWidth = prop['chart.linewidth'];
           co.fillStyle = prop['chart.shadow.color'];
           co.beginPath();

           // Draw shadow here
           co.fillRect(coords[0] + offsetx, coords[1] + offsety, coords[2], coords[3]);

           co.fill();

           // Change the fillstyle back to what it was
           co.fillStyle = prevFillStyle;
       }


       /**
        * Not used by the class during creating the graph, but is used by event handlers
        * to get the coordinates (if any) of the selected bar
        *
        * @param object e The event object
        * @param object   OPTIONAL You can pass in the bar object instead of the
        *                          function using "this"
        */
       this.getShape =
               this.getBar = function (e)
               {
                   // This facilitates you being able to pass in the bar object as a parameter instead of
                   // the function getting it from itself
                   var obj = arguments[1] ? arguments[1] : this;

                   var mouseXY = RGraph.getMouseXY(e);
                   var mouseX  = mouseXY[0];
                   var mouseY  = mouseXY[1];
                   var canvas  = obj.canvas;
                   var context = obj.context;
                   var coords  = obj.coords

                   for (var i=0,len=coords.length; i<len; i+=1) {

                       if (obj.coords[i].length == 0) {
                           continue;
                       }

                       var left   = coords[i][0];
                       var top    = coords[i][1];
                       var width  = coords[i][2];
                       var height = coords[i][3];
                       var prop   = obj.properties;

                       if (mouseX >= left && mouseX <= (left + width) && mouseY >= top && mouseY <= (top + height)) {


                           if (prop['chart.tooltips']) {
                               var tooltip = RGraph.parseTooltipText ? RGraph.parseTooltipText(prop['chart.tooltips'], i) : prop['chart.tooltips'][i];
                           }

                           // Work out the dataset
                           var dataset = 0;
                           var idx = i;

                           while (idx >=  (typeof(obj.data[dataset]) == 'object' && obj.data[dataset] ? obj.data[dataset].length : 1)) {

                               if (typeof(obj.data[dataset]) == 'number') {
                                   idx -= 1;
                               } else if (obj.data[dataset]) { // Accounts for null being an object
                                   idx -= obj.data[dataset].length;
                               } else {
                                   idx -= 1;
                               }

                               dataset++;
                           }

                           if (typeof(obj.data[dataset]) == 'number') {
                               idx = null;
                           }


                           return {
                               0: obj, 1: left, 2: top, 3: width, 4: height, 5: i,
                               'object': obj, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip, 'index_adjusted': idx, 'dataset': dataset
                           };
                       }
                   }

                   return null;
               }




       /**
        * This retrives the bar based on the X coordinate only.
        *
        * @param object e The event object
        * @param object   OPTIONAL You can pass in the bar object instead of the
        *                          function using "this"
        */
       this.getShapeByX = function (e)
       {
           var canvas      = e.target;
           var mouseCoords = RGraph.getMouseXY(e);


           // This facilitates you being able to pass in the bar object as a parameter instead of
           // the function getting it from itself
           var obj = arguments[1] ? arguments[1] : this;


           /**
            * Loop through the bars determining if the mouse is over a bar
            */
           for (var i=0,len=obj.coords.length; i<len; i++) {

               if (obj.coords[i].length == 0) {
                   continue;
               }

               var mouseX = mouseCoords[0];
               var mouseY = mouseCoords[1];
               var left   = obj.coords[i][0];
               var top    = obj.coords[i][1];
               var width  = obj.coords[i][2];
               var height = obj.coords[i][3];
               var prop   = obj.properties;

               if (mouseX >= left && mouseX <= (left + width)) {

                   if (prop['chart.tooltips']) {
                       var tooltip = RGraph.parseTooltipText ? RGraph.parseTooltipText(prop['chart.tooltips'], i) : prop['chart.tooltips'][i];
                   }



                   return {
                       0: obj, 1: left, 2: top, 3: width, 4: height, 5: i,
                       'object': obj, 'x': left, 'y': top, 'width': width, 'height': height, 'index': i, 'tooltip': tooltip
                   };
               }
           }

           return null;
       }


       /**
        * When you click on the chart, this method can return the Y value at that point. It works for any point on the
        * chart (that is inside the gutters) - not just points within the Bars.
        *
        * EITHER:
        *
        * @param object arg The event object
        *
        * OR:
        *
        * @param object arg A two element array containing the X and Y coordinates
        */
       this.getValue = function (arg)
       {
           var co   = this.context;
           var ca   = this.canvas;
           var prop = this.properties;

           if (arg.length == 2) {
               var mouseX = arg[0];
               var mouseY = arg[1];
           } else {
               var mouseCoords = RGraph.getMouseXY(arg);
               var mouseX      = mouseCoords[0];
               var mouseY      = mouseCoords[1];
           }

           if (   mouseY < prop['chart.gutter.top']
                   || mouseY > (ca.height - prop['chart.gutter.bottom'])
                   || mouseX < prop['chart.gutter.left']
                   || mouseX > (ca.width - prop['chart.gutter.right'])
                   ) {
               return null;
           }

           if (prop['chart.xaxispos'] == 'center') {
               var value = (((this.grapharea / 2) - (mouseY - prop['chart.gutter.top'])) / this.grapharea) * (this.scale2.max - this.scale2.min)
               value *= 2;

               if (value >= 0) {
                   value += this.scale2.min;
               } else {
                   value -= this.scale2.min;
               }

           } else if (prop['chart.xaxispos'] == 'top') {
               var value = ((this.grapharea - (mouseY - prop['chart.gutter.top'])) / this.grapharea) * (this.scale2.max - this.scale2.min)
               value = this.scale2.max - value;
               value = Math.abs(value) * -1;
           } else {
               var value = ((this.grapharea - (mouseY - prop['chart.gutter.top'])) / this.grapharea) * (this.scale2.max - this.scale2.min)
               value += this.scale2.min;
           }

           return value;
       }


       /**
        * This function can be used when the canvas is clicked on (or similar - depending on the event)
        * to retrieve the relevant Y coordinate for a particular value.
        *
        * @param int value The value to get the Y coordinate for
        */
       this.getYCoord = function (value)
       {
           if (value > this.scale2.max) {
               return null;
           }

           var co   = this.context;
           var ca   = this.canvas;
           var prop = this.properties;

           var y;
           var xaxispos = prop['chart.xaxispos'];

           if (xaxispos == 'top') {

               // Account for negative numbers
               if (value < 0) {
                   value = Math.abs(value);
               }

               y = ((value - this.scale2.min) / (this.scale2.max - this.scale2.min)) * this.grapharea;
               y = y + this.gutterTop

           } else if (xaxispos == 'center') {

               y = ((value - this.scale2.min) / (this.scale2.max - this.scale2.min)) * (this.grapharea / 2);
               y = (this.grapharea / 2) - y;
               y += this.gutterTop;

           } else {

               if (value < this.scale2.min) {
                   value = this.scale2.min;
               }

               y = ((value - this.scale2.min) / (this.scale2.max - this.scale2.min)) * this.grapharea;

               y = ca.height - this.gutterBottom - y;
           }

           return y;
       }



       /**
        * Each object type has its own Highlight() function which highlights the appropriate shape
        *
        * @param object shape The shape to highlight
        */
       this.Highlight = function (shape)
       {
           // Add the new highlight
           RGraph.Highlight.Rect(this, shape);
       }



       /**
        * The getObjectByXY() worker method
        */
       this.getObjectByXY = function (e)
       {
           var ca   = this.canvas;
           var prop = this.properties;

           var mouseXY = RGraph.getMouseXY(e);

           if (
                   mouseXY[0] >= prop['chart.gutter.left']
                           && mouseXY[0] <= (ca.width - prop['chart.gutter.right'])
                           && mouseXY[1] >= prop['chart.gutter.top']
                           && mouseXY[1] <= (ca.height - prop['chart.gutter.bottom'])
                   ) {

               return this;
           }
       }




       /**
        * This method handles the adjusting calculation for when the mouse is moved
        *
        * @param object e The event object
        */
       this.Adjusting_mousemove = function (e)
       {
           /**
            * Handle adjusting for the Bar
            */
           if (prop['chart.adjustable'] && RG.Registry.Get('chart.adjusting') && RG.Registry.Get('chart.adjusting').uid == this.uid) {

               // Rounding the value to the given number of decimals make the chart step
               var value   = Number(this.getValue(e));
               var shape   = this.getShapeByX(e);

               if (shape) {

                   RG.Registry.Set('chart.adjusting.shape', shape);

                   if (this.stackedOrGrouped && prop['chart.grouping'] == 'grouped') {

                       var indexes = RG.sequentialIndexToGrouped(shape['index'], this.data);

                       if (typeof this.data[indexes[0]] == 'number') {
                           this.data[indexes[0]] = Number(value);
                       } else if (!RG.is_null(this.data[indexes[0]])) {
                           this.data[indexes[0]][indexes[1]] = Number(value);
                       }
                   } else if (typeof this.data[shape['index']] == 'number') {

                       this.data[shape['index']] = Number(value);
                   }

                   RG.RedrawCanvas(e.target);

                   RG.FireCustomEvent(this, 'onadjust');
               }
           }
       }




       /**
        * This function positions a tooltip when it is displayed
        *
        * @param obj object    The chart object
        * @param int x         The X coordinate specified for the tooltip
        * @param int y         The Y coordinate specified for the tooltip
        * @param objec tooltip The tooltips DIV element
        */
       this.positionTooltip = function (obj, x, y, tooltip, idx)
       {
           var prop       = obj.properties;
           var coordX     = obj.coords[tooltip.__index__][0];
           var coordY     = obj.coords[tooltip.__index__][1];
           var coordW     = obj.coords[tooltip.__index__][2];
           var coordH     = obj.coords[tooltip.__index__][3];
           var canvasXY   = RGraph.getCanvasXY(obj.canvas);
           var gutterLeft = prop['chart.gutter.left'];
           var gutterTop  = prop['chart.gutter.top'];
           var width      = tooltip.offsetWidth;
           var height     = tooltip.offsetHeight;
           var value      = obj.data_arr[tooltip.__index__];


           // Set the top position
           tooltip.style.left = 0;
           tooltip.style.top  = canvasXY[1] + coordY - height - 7 + 'px';

           /**
            * If the tooltip is for a negative value - position it underneath the bar
            */
           if (value < 0) {
               tooltip.style.top =  canvasXY[1] + coordY + coordH + 7 + 'px';
           }


           // By default any overflow is hidden
           tooltip.style.overflow = '';

           // Inverted arrow
           // data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAFCAMAAACkeOZkAAAAK3RFWHRDcmVhdGlvbiBUaW1lAFNhdCA2IE9jdCAyMDEyIDEyOjQ5OjMyIC0wMDAw2S1RlgAAAAd0SU1FB9wKBgszM4Ed2k4AAAAJcEhZcwAACxIAAAsSAdLdfvwAAAAEZ0FNQQAAsY8L/GEFAAAACVBMVEX/AAC9vb3//+92Pom0AAAAAXRSTlMAQObYZgAAAB1JREFUeNpjYAABRgY4YGRiRDCZYBwQE8qBMEEcAANCACqByy1sAAAAAElFTkSuQmCC

           // The arrow
           var img = new Image();
           img.style.position = 'absolute';
           img.id = '__rgraph_tooltip_pointer__';
           if (value >= 0) {
               img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAFCAYAAACjKgd3AAAARUlEQVQYV2NkQAN79+797+RkhC4M5+/bd47B2dmZEVkBCgcmgcsgbAaA9GA1BCSBbhAuA/AagmwQPgMIGgIzCD0M0AMMAEFVIAa6UQgcAAAAAElFTkSuQmCC';
               img.style.top = (tooltip.offsetHeight - 2) + 'px';
           } else {
               img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAFCAMAAACkeOZkAAAAK3RFWHRDcmVhdGlvbiBUaW1lAFNhdCA2IE9jdCAyMDEyIDEyOjQ5OjMyIC0wMDAw2S1RlgAAAAd0SU1FB9wKBgszM4Ed2k4AAAAJcEhZcwAACxIAAAsSAdLdfvwAAAAEZ0FNQQAAsY8L/GEFAAAACVBMVEX/AAC9vb3//+92Pom0AAAAAXRSTlMAQObYZgAAAB1JREFUeNpjYAABRgY4YGRiRDCZYBwQE8qBMEEcAANCACqByy1sAAAAAElFTkSuQmCC';
               img.style.top = '-5px';
           }

           tooltip.appendChild(img);

           // Reposition the tooltip if at the edges:

           // LEFT edge
           if ((canvasXY[0] + coordX + (coordW / 2) - (width / 2)) < 10) {
               tooltip.style.left = (canvasXY[0] + coordX - (width * 0.1)) + (coordW / 2) + 'px';
               img.style.left = ((width * 0.1) - 8.5) + 'px';

               // RIGHT edge
           } else if ((canvasXY[0] + coordX + (width / 2)) > document.body.offsetWidth) {
               tooltip.style.left = canvasXY[0] + coordX - (width * 0.9) + (coordW / 2) + 'px';
               img.style.left = ((width * 0.9) - 8.5) + 'px';

               // Default positioning - CENTERED
           } else {
               tooltip.style.left = (canvasXY[0] + coordX + (coordW / 2) - (width * 0.5)) + 'px';
               img.style.left = ((width * 0.5) - 8.5) + 'px';
           }
       }




       /**
        * This allows for easy specification of gradients
        */
       this.parseColors = function ()
       {
           // Save the original colors so that they can be restored when the canvas is reset
           if (this.original_colors.length === 0) {
               this.original_colors['chart.colors']                = RGraph.array_clone(prop['chart.colors']);
               this.original_colors['chart.key.colors']            = RGraph.array_clone(prop['chart.key.colors']);
               this.original_colors['chart.crosshairs.color']      = prop['chart.crosshairs.color'];
               this.original_colors['chart.highlight.stroke']      = prop['chart.highlight.stroke'];
               this.original_colors['chart.highlight.fill']        = prop['chart.highlight.fill'];
               this.original_colors['chart.text.color']            = prop['chart.text.color'];
               this.original_colors['chart.background.barcolor1']  = prop['chart.background.barcolor1'];
               this.original_colors['chart.background.barcolor2']  = prop['chart.background.barcolor2'];
               this.original_colors['chart.background.grid.color'] = prop['chart.background.grid.color'];
               this.original_colors['chart.strokecolor']           = prop['chart.strokecolor'];
               this.original_colors['chart.axis.color']            = prop['chart.axis.color'];
           }


           // chart.colors
           var colors = prop['chart.colors'];
           if (colors) {
               for (var i=0; i<colors.length; ++i) {
                   colors[i] = this.parseSingleColorForGradient(colors[i]);
               }
           }

           // chart.key.colors
           var colors = prop['chart.key.colors'];
           if (colors) {
               for (var i=0; i<colors.length; ++i) {
                   colors[i] = this.parseSingleColorForGradient(colors[i]);
               }
           }

           prop['chart.crosshairs.color']      = this.parseSingleColorForGradient(prop['chart.crosshairs.color']);
           prop['chart.highlight.stroke']      = this.parseSingleColorForGradient(prop['chart.highlight.stroke']);
           prop['chart.highlight.fill']        = this.parseSingleColorForGradient(prop['chart.highlight.fill']);
           prop['chart.text.color']            = this.parseSingleColorForGradient(prop['chart.text.color']);
           prop['chart.background.barcolor1']  = this.parseSingleColorForGradient(prop['chart.background.barcolor1']);
           prop['chart.background.barcolor2']  = this.parseSingleColorForGradient(prop['chart.background.barcolor2']);
           prop['chart.background.grid.color'] = this.parseSingleColorForGradient(prop['chart.background.grid.color']);
           prop['chart.strokecolor']           = this.parseSingleColorForGradient(prop['chart.strokecolor']);
           prop['chart.axis.color']            = this.parseSingleColorForGradient(prop['chart.axis.color']);
       }



       /**
        * This parses a single color value
        */
       this.parseSingleColorForGradient = function (color)
       {
           if (!color || typeof(color) != 'string') {
               return color;
           }

           if (color.match(/^gradient\((.*)\)$/i)) {

               var parts = RegExp.$1.split(':');

               // Create the gradient
               var grad = co.createLinearGradient(0,ca.height - prop['chart.gutter.bottom'], 0, prop['chart.gutter.top']);

               var diff = 1 / (parts.length - 1);

               grad.addColorStop(0, RG.trim(parts[0]));

               for (var j=1,len=parts.length; j<len; ++j) {
                   grad.addColorStop(j * diff, RGraph.trim(parts[j]));
               }
           }

           return grad ? grad : color;
       }



       this.DrawBevel = function ()
       {
           var coords  = this.coords;
           var coords2 = this.coords2;

           var prop    = this.properties;
           var co      = this.context;
           var ca      = this.canvas;

           if (prop['chart.grouping'] == 'stacked') {
               for (var i=0; i<coords2.length; ++i) {
                   if (coords2[i] && coords2[i][0] && coords2[i][0][0]) {

                       var x = coords2[i][0][0];
                       var y = coords2[i][0][1];
                       var w = coords2[i][0][2];

                       var arr = [];
                       for (var j=0; j<coords2[i].length; ++j) {
                           arr.push(coords2[i][j][3]);
                       }
                       var h = RGraph.array_sum(arr);


                       co.save();

                       co.strokeStyle = 'black';

                       // Clip to the rect
                       co.beginPath();
                       co.rect(x, y, w, h);
                       co.clip();

                       // Add the shadow
                       co.shadowColor = 'black';
                       co.shadowOffsetX = 0;
                       co.shadowOffsetY = 0;
                       co.shadowBlur = 20;

                       co.beginPath();
                       co.rect(x - 3, y - 3, w + 6, h + 100);
                       co.lineWidth = 5;
                       co.stroke();
                       co.restore();
                   }
               }
           } else {

               for (var i=0; i<coords.length; ++i) {
                   if (coords[i]) {

                       var x = coords[i][0];
                       var y = coords[i][1];
                       var w = coords[i][2];
                       var h = coords[i][3];

                       var xaxispos = prop['chart.xaxispos'];
                       var xaxis_ycoord = ((ca.height - this.gutterTop - this.gutterBottom) / 2) + this.gutterTop;


                       co.save();

                       co.strokeStyle = 'black';

                       // Clip to the rect
                       co.beginPath();
                       co.rect(x, y, w, h);

                       co.clip();

                       // Add the shadow
                       co.shadowColor = 'black';
                       co.shadowOffsetX = 0;
                       co.shadowOffsetY = 0;
                       co.shadowBlur =  20;

                       if (xaxispos == 'top' || (xaxispos == 'center' && (y + h) > xaxis_ycoord)) {
                           y = y - 100;
                           h = h + 100;
                       } else {
                           y = y;
                           h = h + 100;
                       }

                       co.beginPath();
                       co.rect(x - 3, y - 3, w + 6, h + 6);
                       co.lineWidth = 5;
                       co.stroke();
                       co.restore();
                   }
               }
           }
       }




       /**
        * This function handles highlighting an entire data-series for the interactive
        * key
        *
        * @param int index The index of the data series to be highlighted
        */
       this.interactiveKeyHighlight = function (index)
       {
           this.coords2.forEach(function (value, idx, arr)
           {
               if (typeof value[index] == 'object' && value[index]) {

                   var x = value[index][0]
                   var y = value[index][1]
                   var w = value[index][2]
                   var h = value[index][3]

                   co.fillStyle = prop['chart.key.interactive.highlight.chart.fill'];
                   co.strokeStyle = prop['chart.key.interactive.highlight.chart.stroke'];
                   co.lineWidth   = 2;
                   co.fillRect(x, y, w, h);
                   co.strokeRect(x, y, w, h);
               }
           });
       }




       /**
        * Register the object
        */
       RGraph.Register(this);
   }





   /*********************************************************************************************************
    * This is the combined bar and Line class which makes creating bar/line combo charts a little bit easier *
    /*********************************************************************************************************/







   RGraph.CombinedChart = function ()
   {
       /**
        * Create a default empty array for the objects
        */
       this.objects = [];

       var objects = arguments;

       if (RGraph.is_array(arguments[0])) {
           objects = arguments[0];
       }

       for (var i=0; i<objects.length; ++i) {

           this.objects[i] = objects[i];

           /**
            * Set the Line chart gutters to match the Bar chart gutters
            */
           this.objects[i].Set('chart.gutter.left',  this.objects[0].Get('chart.gutter.left'));
           this.objects[i].Set('chart.gutter.right',  this.objects[0].Get('chart.gutter.right'));
           this.objects[i].Set('chart.gutter.top',    this.objects[0].Get('chart.gutter.top'));
           this.objects[i].Set('chart.gutter.bottom', this.objects[0].Get('chart.gutter.bottom'));

           if (this.objects[i].type == 'line') {

               /**
                * Set the line chart hmargin
                */
               this.objects[i].Set('chart.hmargin', ((this.objects[0].canvas.width - this.objects[0].Get('chart.gutter.right') - this.objects[0].Get('chart.gutter.left')) / this.objects[0].data.length) / 2 );


               /**
                * No labels, axes or grid on the Line chart
                */
               this.objects[i].Set('chart.noaxes', true);
               this.objects[i].Set('chart.background.grid', false);
               this.objects[i].Set('chart.ylabels', false);
           }

           /**
            * Resizing
            */
           if (this.objects[i].Get('chart.resizable')) {
               var resizable_object = this.objects[i];
           }
       }

       /**
        * Resizing
        */
       if (resizable_object) {
           /**
            * This recalculates the Line chart hmargin when the chart is resized
            */
           function myOnresizebeforedraw (obj)
           {
               var gutterLeft = obj.Get('chart.gutter.left');
               var gutterRight = obj.Get('chart.gutter.right');

               obj.Set('chart.hmargin', (obj.canvas.width - gutterLeft - gutterRight) / (obj.original_data[0].length * 2));
           }

           RGraph.AddCustomEventListener(resizable_object,
                   'onresizebeforedraw',
                   myOnresizebeforedraw);
       }
   }


   /**
    * The Add method can be used to add methods to the CombinedChart object.
    */
   RGraph.CombinedChart.prototype.Add = function (obj)
   {
       this.objects.push(obj);
   }


   /**
    * The Draw method goes through all of the objects drawing them (sequentially)
    */
   RGraph.CombinedChart.prototype.Draw = function ()
   {
       for (var i=0; i<this.objects.length; ++i) {
           if (typeof(arguments[i]) == 'function') {
               arguments[i](this.objects[i]);
           } else {
               this.objects[i].Draw();
           }
       }
   }
   </script>

<script>
    $(document).ready(function(){
        var  htmlbody = $('html,body');

        var button = htmlbody.find('.button');


//        $('.button').bind('mouseover',function(e){
//            button.removeAttr("active");
//            e.target.setAttribute("active","active");
//        })
//                .bind('mouseout',function(e){
//                    button.removeAttr("active");
//                });

        $('a[title]').bind('click',function(e){
//            alert('ok');
//            e.preventDefault();
          var data= $(this).attr('data-slide');

            if(data!=7){

                htmlbody.animate({
                    scrollTop: $('#slider'+data).offset().top
//                scrollTop:"200px"
                }, 2000, 'easeInOutQuint');
            }else{

                htmlbody.animate({
                    scrollTop: $('#slider1').offset().top
//                scrollTop:"200px"
                }, 1000, 'linear');
            }



        });


        $('li[class$=one]').bind('click',function(){
           var right =  $(this).parents('div#left').next().find("div[class$=one]");
            var show = right.css('display');
            if(show=='none'){
                $(this).parents('div#left').next().find("div[class^=article]:not(.one)").css("display","none");
                right.show(1000)
                     .css("display","table");
            }else{
                right.hide(1000);
            }

        });


        $('li[class$=two]').bind('click',function(){
            var right =  $(this).parents('div#left').next().find("div[class$=two]");
            var show = right.css('display');
            if(show=='none'){
                $(this).parents('div#left').next().find("div[class^=article]:not(.two)").css("display","none");
                right.fadeIn(2000)
                        .css("display","table");
            }else{
                right.fadeOut(1000);
            }

        });


        $('li[class$=three]').bind('click',function(){
            var right =  $(this).parents('div#left').next().find("div[class$=three]");
            var show = right.css('display');
            if(show=='none'){
                $(this).parents('div#left').next().find("div[class^=article]:not(.three)").css("display","none");
                right.slideDown(1500)
                        .css("display","table");
            }else{
                right.slideUp(1000);
            }

        });


        $('li[class$=four]').bind('click',function(){
            var right =  $(this).parents('div#left').next().find("div[class$=four]");
            var show = right.css('display');
            if(show=='none'){
                $(this).parents('div#left').next().find("div[class^=article]:not(.four)").css("display","none");
                right.slideDown(1500)
                        .css("display","table");
            }else{
                right.slideUp(1000);
            }

        });

    });


    $(document).ready(function(){
        var page=1;
        $('a[class$=next]').bind('click',function(){         //下一张图片动画


            var $parent= $(this).parents("div#activity");
            var $show = $parent.find("div#ac-wrapper");

            var width = $($parent).width();
            var len = $show.find('li').length;
//            alert($show.attr('id'));
//            alert(len);
//            alert(page);
            if(!$show.is(":animated")){
                if(page==len){
                    $show.animate({left:0},0);
//                    $show.css("left",'-='+width).fadeIn(1000);
                    page=1;
                }else{
                    $show.animate({left:'-='+width},1000);
                    page++;
                }
            }
            $parent.find("li:not(.ac-content)").eq((page-1)).addClass("current").siblings().removeClass("current");

        });


        $('a[class$=pre]').bind('click',function(){


            var $parent= $(this).parents("div#activity");
            var $show = $parent.find("div#ac-wrapper");
//            alert($parent.find("li:not(.ac-content)").length);

            var width = $($parent).width();
            var len = $show.find('li').length;
//            alert($show.attr('id'));
//            alert(len);
//            alert(page);
            if(!$show.is(":animated")){
                if(page==1){
                    $show.animate({left:'-='+width*(len-1)},0);
                    page=len;
                }else{
                    $show.animate({left:'+='+width},1000);
                    page--;
                }
            }
            $parent.find("li:not(.ac-content)").eq((page-1)).addClass("current").siblings().removeClass("current");

        });
    });

    var color=["#27255F","#2F368F","#3666B0","#2CA8E0","#77D1F6"];
    var data = [15,25,25,15,20];
    var position=0;

    function drawCircle(){
        var canvas= document.getElementById('circle');
        var ctx = canvas.getContext('2d');
        for(var i=0;i<data.length;i++){
            ctx.fillStyle=color[i];
            ctx.beginPath();
            ctx.moveTo(200,150);

            ctx.arc(200,150,150,position,position+Math.PI*2*(data[i]/100),false);
            ctx.fill();
            position+=Math.PI*2*(data[i]/100);
        }

    }
    drawCircle();

    function drawBar(){
        var bar4 = new RGraph.Bar('cvs', [70,70,65,60,60])
                .Set('colors', ['#77D1F6'])
                .Set('labels', ['JavaScript', 'CSS', 'Java', 'HTML', 'JQuery'])
                .Set('numyticks', 5)
                .Set('ylabels.count', 10)
                .Set('gutter.left', 35)
                .Set('variant', '3d')
                .Set('strokestyle', 'transparent')
                .Set('hmargin.grouped', 0)
                .Set('scale.round', true)
                .Draw();
    }
    drawBar();


    $('img.icon-img').bind('mouseover',function(e){
//        alert(e.target.className);
        $(this).parents("a").next().css("color","blue");
//        $('span.icon-text').css();
    })
            .bind('mouseout',function(){
                $(this).parents("a").next().css("color","#FBD244");
            });

    $('img.tel').bind('click',function(){
        var photo = $(this).parents('div#icon-show').next();
        var dis = photo.css("display");
        if(dis=="none"){
            photo.next().css("display","none");
            photo.fadeIn(2000);
        }else{
            photo.fadeOut(1000);
        }
    });

    $('img.wechat').bind('click',function(){
        var photo = $(this).parents('div#icon-show').next().next();
        var dis = photo.css("display");
        if(dis=="none"){
            photo.prev().css("display","none");
            photo.fadeIn(2000);
        }else{
            photo.fadeOut(1000);
        }
    });



</script>


</body>
</html>